<!-- PATCH: Daily precipitation for MH taken from MeteoHub observations API (B13xxx/accumulated), Open‑Meteo fallback removed for MH stations. -->
<!DOCTYPE html>

<html lang="it">
<head>

  <!-- === HARD NO-CACHE META TAGS (best-effort for browsers that honor them) === -->
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">

  <!-- === SOFT NO-CACHE SCRIPT v2 (less invasive; focuses on static tags & Leaflet tiles) === -->
  <script>
  (function(){
    var BUST = String(Date.now());
    function addBust(urlStr){
      try{
        var u = new URL(urlStr, location.href);
        if(u.protocol === "data:" || u.protocol === "blob:") return urlStr;
        u.searchParams.set("v", BUST);
        return u.toString();
      }catch(e){
        return urlStr;
      }
    }

    function bustEl(el){
      ["href","src"].forEach(function(attr){
        if(el.hasAttribute && el.hasAttribute(attr)){
          var v = el.getAttribute(attr);
          if(v && typeof v === "string" && !v.startsWith("data:") && !v.startsWith("blob:")){
            el.setAttribute(attr, addBust(v));
          }
        }
      });
    }

    document.addEventListener("DOMContentLoaded", function(){
      // Best-effort cleanup limited to our origin, non-destructive
      try { sessionStorage.clear(); } catch(e){}
      // Don't clear localStorage/IndexedDB here to avoid breaking app logic

      // Inject meta tags dynamically (helps SPA navigations)
      var m1 = document.createElement("meta"); m1.httpEquiv = "Cache-Control"; m1.content = "no-store, no-cache, must-revalidate, max-age=0";
      var m2 = document.createElement("meta"); m2.httpEquiv = "Pragma"; m2.content = "no-cache";
      var m3 = document.createElement("meta"); m3.httpEquiv = "Expires"; m3.content = "0";
      if(document.head){ document.head.appendChild(m1); document.head.appendChild(m2); document.head.appendChild(m3); }

      // Bust already-present resources
      document.querySelectorAll('link[rel="stylesheet"], link[as="style"], script[src], img[src]').forEach(bustEl);

      // Patch Leaflet tile generation if Leaflet is present
      if (window.L && L.TileLayer && L.TileLayer.prototype && typeof L.TileLayer.prototype.getTileUrl === "function"){
        var orig = L.TileLayer.prototype.getTileUrl;
        L.TileLayer.prototype.getTileUrl = function(coords){
          var u = orig.call(this, coords);
          return addBust(u);
        };
      }

      // Observe later-added nodes and bust their src/href
      var mo = new MutationObserver(function(muts){
        muts.forEach(function(m){
          m.addedNodes && m.addedNodes.forEach(function(node){
            if(node.nodeType === 1){
              if(node.tagName === "IMG" || node.tagName === "SCRIPT" || (node.tagName === "LINK" && node.rel === "stylesheet")){
                bustEl(node);
              }
              if(node.querySelectorAll){
                node.querySelectorAll("img,script[src],link[rel=stylesheet]").forEach(bustEl);
              }
            }
          });
        });
      });
      mo.observe(document.documentElement, { childList: true, subtree: true });
    });
  })();
  </script>

<!-- Performance hints: preconnect -->
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://api.open-meteo.com" crossorigin>
  <link rel="preconnect" href="https://tile.openstreetmap.org">
<style id="hideMarkerOpacity">.leaflet-marker-icon,.leaflet-marker-shadow{opacity:0;transition:opacity 0.15s linear;}</style>
<meta charset="utf-8"/>
<title>Mappa Meteo Calabria</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<link href="https://unpkg.com/leaflet/dist/leaflet.css" rel="stylesheet"/>
<link href="https://unpkg.com/leaflet-gesture-handling/dist/leaflet-gesture-handling.min.css" rel="stylesheet"/>
<script type="module">
async function caricaDatiOpenMeteo() {
  const richieste = stazioni
    .filter(s => s.openMeteo)
    .map(stazione => fetch(`https://api.open-meteo.com/v1/forecast?latitude=${stazione.lat}&longitude=${stazione.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m,wind_speed_10m&daily=temperature_2m_max,temperature_2m_min&timezone=auto`)
      .then(res => res.json())
      .then(data => ({
        stationId: stazione.stationId,
        temp: data.current.temperature_2m,
        tempVal: data.current.temperature_2m,
        pioggia: data.current.precipitation,
        umidita: data.current.relativehumidity_2m,
        raffica: data.current.wind_gusts_10m,
        percepita: (() => {
          const v = calcolaPercepita(data.current.temperature_2m, data.current.relativehumidity_2m, data.current.wind_speed_10m);
          return v != null ? v : "--";
        })(),
        percepitaVal: calcolaPercepita(data.current.temperature_2m, data.current.relativehumidity_2m, data.current.wind_speed_10m),
      }))
      .catch(e => {
        console.error("Errore nel fetch OpenMeteo per", stazione.stationId, e);
        return null;
      })
    );

  const risultati = await Promise.all(richieste);
  datiTabella.push(...risultati.filter(r => r !== null));
}

// === PATCH ESTREMI DA FIREBASE ===
// [rimosso] legacy Realtime Database '/estremi' fetch.

  visualizzaAttuali();
});

</script>
<script>
window.extremiGiornalieri = {}; // rimosso statico

function visualizzaEstremi(tipo) {
  datiTabella.forEach((d) => {
    const valore = getEstremoGiornaliero(d.stationId, tipo);
    const colore = tipo === 'max' ? '#ff4444' : '#4466ff';
    const marker = markersById[d.stationId];
    if (valore && marker) {
      const el = marker.getElement();
      if (el) {
        el.innerHTML = `<span style='color:white;'>${String(valore)}°</span></div>`;
        el.style.backgroundColor = colore;
      }
    }
  });
}

function visualizzaAttuali() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (!isNaN(d.tempVal) && marker) {
      const el = marker.getElement();
      if (el) {
        const colore = getColor(d.tempVal);
        const textColor = getTextColorForBackground(colore);
        el.innerHTML = `<span style='color:${textColor};'>${d.temp}°</span></div>`;
        el.style.backgroundColor = colore;
      }
    }
  });
}

function visualizzaUmidita() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (marker) {
      const el = marker.getElement();
      if (el) {
        el.innerHTML = `<span style='color:white;'>${d.umidita}%</span></div>`;
        el.style.backgroundColor = '#0099cc';
      }
    }
  });
}


function visualizzaPercepita() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (!isNaN(d.percepitaVal) && marker) {
      const el = marker.getElement();
      if (el) {
        const colore = getColor(d.percepitaVal);
        const textColor = getTextColorForBackground(colore);
        el.innerHTML = `<span style='color:${textColor};'>${d.percepita}</span></div>`;
        el.style.backgroundColor = colore;
      }
    }
  });
}

function visualizzaRaffiche() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (marker) {
      const el = marker.getElement();
      if (el) {
        el.innerHTML = `<span style='color:white;'>${d.raffica}</span>`;
        el.style.backgroundColor = '#666';
      }
    }
  });
}


function getColorUmidita(val) {
  const r = Math.round(255 - (val * 2.0));
  const g = Math.round(140 - (val * 0.8));
  const b = Math.round(50 + (val * 2.0));
  return `rgb(${r < 0 ? 0 : r},${g < 0 ? 0 : g},${b > 255 ? 255 : b})</div>`;
}

function getColorVento(val) {
  const r = Math.min(255, Math.round(val * 5));
  const g = Math.max(0, 255 - Math.round(val * 3));
  return `rgb(${r},${g},60)</div>`;
}

function visualizzaEstremi(tipo) {
  datiTabella.forEach((d) => {
    const valore = getEstremoGiornaliero(d.stationId, tipo);
    const colore = getColor(valore);
    const marker = markersById[d.stationId];
    if (valore && marker) {
      const el = marker.getElement();
      if (el) {
        el.innerHTML = `<span style='color:${getTextColorForBackground(colore)};'>${String(valore)}°</span></div>`;
        el.style.backgroundColor = colore;
        el.style.width = '40px';
        el.style.height = '40px';
      }
    }
  });
}

function visualizzaAttuali() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (!isNaN(d.tempVal) && marker) {
      const el = marker.getElement();
      if (el) {
        const colore = getColor(d.tempVal);
        el.innerHTML = `<span style='color:${getTextColorForBackground(colore)};'>${d.temp}°</span></div>`;
        el.style.backgroundColor = colore;
        el.style.width = '40px';
        el.style.height = '40px';
      }
    }
  });
}

function visualizzaUmidita() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (marker) {
      const el = marker.getElement();
      if (el) {
        const colore = getColorUmidita(d.umidita);
        el.innerHTML = `<span style='color:${getTextColorForBackground(colore)};'>${d.umidita}%</span></div>`;
        el.style.backgroundColor = colore;
        el.style.width = '40px';
        el.style.height = '40px';
      }
    }
  });
}

function visualizzaRaffiche() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (marker) {
      const el = marker.getElement();
      if (el) {
        const colore = getColorVento(d.raffica);
        el.innerHTML = `<span style='color:${getTextColorForBackground(colore)};'>${d.raffica}</span></div>`;
        el.style.backgroundColor = colore;
        el.style.width = '48px';
        el.style.height = '48px';
      }
    }
  });
}


function getColorUmidita(val) {
  if (val <= 20) return "#ff5500";       // Secco intenso (arancio)
  if (val <= 40) return "#ffaa00";       // Secco moderato (giallo-arancio)
  if (val <= 60) return "#88cc44";       // Umido normale (verde chiaro)
  if (val <= 80) return "#44aaff";       // Umido (azzurro)
  return "#0055ff";                      // Molto umido (blu intenso)
}

function visualizzaEstremi(tipo) {
  datiTabella.forEach((d) => {
    const valore = getEstremoGiornaliero(d.stationId, tipo);
    const marker = markersById[d.stationId];
    if (typeof valore !== 'undefined' && marker) {
      const colore = getColor(valore);
      const el = marker.getElement();
      if (el) {
        el.innerHTML = `<span style='color:${getTextColorForBackground(colore)};'>${String(valore)}°</span></div>`;
        el.style.backgroundColor = colore;
        el.style.width = '40px';
        el.style.height = '40px';
      }
    }
  });
}

function visualizzaAttuali() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (!isNaN(d.tempVal) && marker) {
      const el = marker.getElement();
      if (el) {
        const colore = getColor(d.tempVal);
        el.innerHTML = `<span style='color:${getTextColorForBackground(colore)};'>${d.temp}°</span></div>`;
        el.style.backgroundColor = colore;
        el.style.width = '40px';
        el.style.height = '40px';
      }
    }
  });
}

function visualizzaUmidita() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (typeof d.umidita !== 'undefined' && marker) {
      const el = marker.getElement();
      if (el) {
        const colore = getColorUmidita(d.umidita);
        el.innerHTML = `<span style='color:${getTextColorForBackground(colore)};'>${d.umidita}%</span></div>`;
        el.style.backgroundColor = colore;
        el.style.width = '40px';
        el.style.height = '40px';
      }
    }
  });
}

function visualizzaRaffiche() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (typeof d.raffica !== 'undefined' && marker) {
      const el = marker.getElement();
      if (el) {
        const colore = getColorVento(d.raffica);
        el.innerHTML = `<span style='color:${getTextColorForBackground(colore)};'>${d.raffica}</span></div>`;
        el.style.backgroundColor = colore;
        el.style.width = '48px';
        el.style.height = '48px';
      }
    }
  });
}

</script>
<style>
   /* Sidebar compatta */
#sidebar {
  position: fixed;
  top: 60px;
  left: 0;
  width: 36px;
  background-color: #fff;
  border-right: 1px solid #ccc;
  z-index: 1001;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 6px 0;
  box-shadow: 2px 0 4px rgba(0,0,0,0.1);
}
.sidebar-btn {
  background: none;
  border: none;
  padding: 4px 0;
  margin-bottom: 4px;
  cursor: pointer;
  font-size: 10px;
  font-weight: bold;
  color: #333;
  width: 100%;
  text-align: center;
  transition: background-color 0.2s;
}
.sidebar-btn:hover {
  background-color: #eef;
}

body, html { margin: 0; padding: 0; height: 100%; font-family: Arial, sans-serif; background: #f4f4f4; }

#banner {
  background-color: #1a3a9b; /* Colore blu */
  color: white;
  text-align: center;
  padding: 10px 0;
  font-size: 24px;
  font-weight: bold;
  position: fixed;
  top: 0;
  width: 100%;
  z-index: 1000;
}

#map {
  height: calc(100vh - 60px);
  width: 100%;
  border-bottom: 2px solid #ccc;
}

#tabella {
  padding-bottom: 260px; /* Evita sovrapposizione con la sezione fissa */
  padding: 20px;
}

.temperature-label {
  width: 26px !important;
  height: 26px !important;
  font-size: 13px !important;

  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  width: 24px;
  height: 24px;
  font-weight: bold;
  font-size: 15px;
  border: 2px solid #fff;
  color: #000;
  box-shadow: 0 0 6px rgba(0,0,0,0.3);
}

.popup-title { font-size: 16px; font-weight: bold; }
.popup-sub { font-size: 13px; color: #666; margin-bottom: 6px; }
.popup-data { margin: 2px 0; font-size: 15px; }
.bold { font-weight: bold; }
.webcam-preview { width: 100%; max-height: 100px; object-fit: cover; margin-top: 5px; border-radius: 5px; }
.webcam-missing { font-size: 13px; color: #777; margin-top: 5px; text-align: center; }
.btn {
  display: inline-block;
  padding: 6px 10px;
  margin: 5px 5px 0 0;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  text-decoration: none;
  font-size: 13px;
}
.btn:hover { background-color: #0056b3; }
#popup-grafico {
  position: fixed;
  top: 10%;
  left: 5%;
  width: 90%;
  height: 80%;
  background: white;
  border: 2px solid #007bff;
  border-radius: 8px;
  display: none;
  flex-direction: column;
  z-index: 10000;
}
#popup-grafico iframe { flex: 1; width: 100%; border: none; }
#popup-grafico .close-btn {
  background: red;
  color: white;
  padding: 5px;
  border: none;
  width: 100%;
  font-weight: bold;
  cursor: pointer;
}
a.btn { color: white !important; }
  
body {
  overflow-x: hidden;
}

#sidebar {
  pointer-events: auto;
  -ms-touch-action: none;
  touch-action: none;
}
#sidebar.sidebar-nascosta {
  transform: translateX(-50px);
  transition: transform 0.3s ease;
}

</style><style>
   .card.compact-extreme {
  font-size: 16px;
  font-weight: bold;
  display: flex;
  justify-content: space-between;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 6px;
  background: #fdfdfd;
  margin: 5px 0;
}
.card.compact-extreme span {
  font-size: 17px;
}
.card.compact-extreme .valore {
  font-size: 20px;
  color: #c00;
}
  </style><style>
   /* Sidebar compatta */
#sidebar {
  position: fixed;
  top: 60px;
  left: 0;
  width: 36px;
  background-color: #fff;
  border-right: 1px solid #ccc;
  z-index: 1001;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 6px 0;
  box-shadow: 2px 0 4px rgba(0,0,0,0.1);
}
.sidebar-btn {
  background: none;
  border: none;
  padding: 4px 0;
  margin-bottom: 4px;
  cursor: pointer;
  font-size: 10px;
  font-weight: bold;
  color: #333;
  width: 100%;
  text-align: center;
  transition: background-color 0.2s;
}
.sidebar-btn:hover {
  background-color: #eef;
}

html, body {
  scroll-padding-top: 60px; /* Compensa altezza banner fisso */
}
  </style><style>
   /* Sidebar compatta */
#sidebar {
  position: fixed;
  top: 60px;
  left: 0;
  width: 36px;
  background-color: #fff;
  border-right: 1px solid #ccc;
  z-index: 1001;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 6px 0;
  box-shadow: 2px 0 4px rgba(0,0,0,0.1);
}
.sidebar-btn {
  background: none;
  border: none;
  padding: 4px 0;
  margin-bottom: 4px;
  cursor: pointer;
  font-size: 10px;
  font-weight: bold;
  color: #333;
  width: 100%;
  text-align: center;
  transition: background-color 0.2s;
}
.sidebar-btn:hover {
  background-color: #eef;
}

#slide-banner.show {
  right: 0 !important;
}
  </style><style>
   .sidebar-btn.attivo {
  box-shadow: inset 0 0 4px #00000099;
  font-weight: bold;
  border-left: 2px solid #000;
}
  </style><style>
   /* Modernizzazione barra laterale */
#sidebar {
  background: linear-gradient(to bottom, #ffffffcc, #f0f0f0cc);
  border-right: 1px solid #bbb;
  box-shadow: 2px 0 6px rgba(0,0,0,0.15);
  backdrop-filter: blur(4px);
}

/* Pulsanti moderni */
.sidebar-btn {
  border-radius: 6px;
  margin: 6px 0;
  font-weight: 600;
  font-size: 11px;
  background-color: #e6e6e6;
  color: #333;
  border: 1px solid #ccc;
  transition: all 0.2s ease;
}

.sidebar-btn:hover {
  background-color: #d0d0d0;
  transform: scale(1.05);
}

.sidebar-btn.attivo {
  background-color: #007bff !important;
  color: white !important;
  border-left: 3px solid #004a99;
  box-shadow: inset 0 0 5px #00000033;
}
  </style><style>
   .highlight-temp {
    font-size: 36px;
    font-weight: bold;
}
  </style><style>
   .filter-button.active {
    background-color: #337ab7;
    color: white;
}
  </style><style>
   .filtro-box {
  background: white;
  padding: 12px;
  border-radius: 10px;
  margin: 10px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}
.filtro-box label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
}
.filtro-box select, .filtro-box input[type="checkbox"] {
  margin-top: 4px;
}
  </style><style>
   .card.compact-extreme {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 14px;
  border: 1px solid #ddd;
  border-radius: 8px;
  background: #fefefe;
  margin: 6px 0;
  font-size: 15px;
}
.card.compact-extreme span.nome {
  font-weight: 600;
  flex: 1;
}
.card.compact-extreme span.valore {
  font-weight: bold;
  font-size: 16px;
  color: #c00;
  text-align: right;
}
  </style><style>
   #filtro-provincia, #filtro-ordinamento {
  margin-left: 6px;
  padding: 4px 8px;
  border-radius: 6px;
  background: #eef;
  font-weight: bold;
}
.filtro-riga-select {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 8px;
}
  </style><style>
   #filtro-provincia, #filtro-ordinamento {
  margin: 0;
  padding: 4px 6px;
  border-radius: 5px;
  background: #eef;
  font-weight: bold;
  font-size: 14px;
}
.filtro-riga-select {
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
  gap: 6px;
}
.filtro-box label {
  font-size: 14px;
}
#filtro-mlg {
  transform: scale(0.9);
  margin-right: 4px;
}
.mlg-label-small {
  display: flex;
  align-items: center;
  font-size: 13px;
  font-weight: 500;
  color: #333;
  margin-top: 4px;
}
  </style><style>
   /* Rendi tutto molto più compatto */
#filtro-provincia, #filtro-ordinamento {
  margin: 0;
  padding: 2px 5px;
  border-radius: 4px;
  background: #eef;
  font-weight: bold;
  font-size: 13px;
}
.filtro-riga-select {
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
  gap: 4px;
  font-size: 13px;
}
.filtro-box label {
  font-size: 13px;
}
#filtro-mlg {
  transform: scale(0.85);
  margin-right: 4px;
}
.mlg-label-small {
  display: flex;
  align-items: center;
  font-size: 12.5px;
  font-weight: 500;
  color: #333;
  margin: 2px 0 0 0;
}
  </style><style>
   /* Marker circle and label size adjustment */
.temperature-label, .leaflet-marker-icon {
  width: 26px !important;
  height: 26px !important;
  font-size: 11px !important;
  line-height: 26px !important;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  white-space: nowrap;
  border-radius: 50%;
}

/* MLG star size fix (assuming 'star-mlg' class or similar) */
.leaflet-marker-icon.star-mlg {
  width: 12px !important;
  height: 12px !important;
  transform: translate(-50%, -50%);
}
  </style><style>
   /* Marker circle and label size adjustment */
.temperature-label, .leaflet-marker-icon {
  width: 26px !important;
  height: 26px !important;
  font-size: 10px !important;
  line-height: 26px !important;
  text-align: center;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  white-space: nowrap;
  border-radius: 50%;
}

/* Visible and appropriately scaled MLG star icon */
.leaflet-marker-icon.star-mlg {
  width: 12px !important;
  height: 12px !important;
  transform: translate(-50%, -50%);
  display: inline-block !important;
  visibility: visible !important;
  z-index: 9999 !important;
}
  </style><style>
   #anteprima-live {
    background: linear-gradient(to bottom, #f8faff, #ffffff);
    border-radius: 12px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    margin: 16px auto;
    padding: 20px;
    max-width: 900px;
  }
  #anteprima-live h2 {
    font-size: 22px;
    font-weight: 700;
    margin-bottom: 10px;
    color: #003366;
    text-align: center;
  }
  #preview-cards .card {
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: #ffffff;
    border: 1px solid #dde3ec;
    border-radius: 10px;
    padding: 12px 18px;
    margin-bottom: 12px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.04);
    transition: transform 0.2s ease;
  }
  #preview-cards .card:hover {
    transform: scale(1.015);
  }
  #preview-cards .card .nome {
    font-weight: 600;
    font-size: 16px;
    color: #222;
  }
  #preview-cards .card .valore {
    font-size: 18px;
    font-weight: bold;
    color: #0055aa;
  }
  #preview-cards .card .btn {
    margin-left: auto;
    background-color: #007bff;
    border: none;
    padding: 6px 12px;
    color: white;
    border-radius: 6px;
    cursor: pointer;
    transition: background 0.3s;
  }
  #preview-cards .card .btn:hover {
    background-color: #0056b3;
  }
  </style><style>
   #anteprima-live {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 500;
  background: rgba(255,255,255,0.95);
  border-top: 2px solid #ccc;
  padding: 14px 20px;
  box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
  backdrop-filter: blur(6px);
}
  </style><style>
#map {
  display: flex;
  flex-direction: column;
  justify-content: flex-start;
  height: auto;
  min-height: calc(100vh - 60px);
}
#anteprima-live {
  margin-top: auto;
}
</style><style>
/* MIGLIORAMENTO GRAFICO CARDS METEO PER MOBILE */
#tabella .card {
  background: #ffffff;
  border: 1px solid #ccddee;
  border-radius: 14px;
  padding: 20px 18px;
  margin-bottom: 16px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  font-size: 15.5px;
  line-height: 1.7;
  transition: transform 0.2s ease;
}

#tabella .card:hover {
  transform: scale(1.01);
}

#tabella .card .intestazione {
  font-size: 17px;
  font-weight: 700;
  color: #003366;
  margin-bottom: 4px;
}

#tabella .card .dati {
  display: flex;
  flex-wrap: wrap;
  gap: 6px 14px;
  color: #333;
}

#tabella .card .dati span {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: 500;
}

#tabella .card .dati .valore {
  font-weight: 600;
  color: #0055aa;
}

#tabella .card .badge {
  display: inline-block;
  padding: 4px 6px;
  background: #007bff;
  color: white;
  font-size: 12px;
  border-radius: 6px;
  font-weight: bold;
  margin-top: 6px;
}

@media (max-width: 480px) {
  #tabella .card {
    padding: 18px 16px;
    font-size: 15px;
  }
}
}</style><style>
/* Stile migliorato per sezione anteprima testuale */
#anteprima-dati-testuali {
  position: absolute;
  top: calc(100vh - 160px);
  left: 0;
  width: 100%;
  background: linear-gradient(to bottom, #f9fbff, #ffffff);
  z-index: 9999;
  padding: 24px 18px;
  box-shadow: 0 -2px 14px rgba(0,0,0,0.15);
  border-top: 2px solid #ccd6e0;
  border-radius: 18px 18px 0 0;
  font-family: "Segoe UI", sans-serif;
}

#anteprima-dati-testuali > div:first-child {
  font-weight: 600;
  font-size: 17px;
  color: #003366;
  text-align: center;
  margin-bottom: 16px;
}

.filtro-box {
  background: #f0f4f8;
  padding: 14px;
  border-radius: 12px;
  margin-bottom: 12px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.05);
}

.filtro-box label {
  font-weight: 500;
  font-size: 15px;
  display: block;
  color: #222;
}

.filtro-box input[type="checkbox"] {
  margin-right: 8px;
  transform: scale(1.2);
}

.filtro-riga-select {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
  font-size: 15px;
  margin-top: 10px;
}

.filtro-riga-select label {
  font-weight: 600;
}

#filtro-provincia, #filtro-ordinamento, #filtro-provincia-estremi {
  padding: 6px 10px;
  border-radius: 8px;
  background: #e6efff;
  border: 1px solid #aac4e6;
  font-size: 14px;
  font-weight: 500;
}

#filtro-prov-extremi-container {
  margin-top: 10px;
  background: #eef3f9;
  padding: 10px 12px;
  border-radius: 10px;
}

.mlg-label-small {
  font-size: 14px;
  color: #003366;
  font-weight: 500;
}

@media (max-width: 480px) {
  #anteprima-dati-testuali {
    padding: 18px 14px;
  }

  .filtro-box {
    padding: 10px;
  }

  .filtro-riga-select {
    flex-direction: column;
    align-items: flex-start;
  }

  #filtro-provincia, #filtro-ordinamento {
    width: 100%;
  }
}
</style><style>
/* SEZIONE ANTEPRIMA COMPLETAMENTE RIDISEGNATA PER MOBILE */

/* Contenitore principale */
#anteprima-dati-testuali {
  position: absolute;
  top: calc(100vh - 180px);
  left: 0;
  width: 100%;
  background: #f9fbff;
  z-index: 9999;
  padding: 26px 16px 20px;
  box-shadow: 0 -3px 14px rgba(0,0,0,0.12);
  border-top: 2px solid #b0c4de;
  border-radius: 20px 20px 0 0;
  font-family: "Segoe UI", sans-serif;
}

/* Titolo iniziale */
#anteprima-dati-testuali > div:first-child {
  font-weight: 700;
  font-size: 17px;
  color: #002b55;
  text-align: center;
  margin-bottom: 20px;
  margin-top: -6px;
}

/* Filtro box modernizzati */
.filtro-box {
  background: #eaf2f8;
  padding: 14px 16px;
  border-radius: 12px;
  margin-bottom: 14px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.04);
}

.filtro-box label {
  font-weight: 500;
  font-size: 15px;
  color: #1a1a1a;
  display: flex;
  align-items: center;
}

.filtro-box input[type="checkbox"] {
  margin-right: 10px;
  transform: scale(1.1);
}

/* Riorganizzazione selettori */
.filtro-riga-select {
  display: flex;
  flex-direction: column;
  gap: 10px;
  font-size: 15px;
  margin-bottom: 14px;
}

.filtro-riga-select label {
  font-weight: 600;
  margin-bottom: 4px;
}

/* Select dropdown */
#filtro-provincia, #filtro-ordinamento, #filtro-provincia-estremi {
  padding: 7px 12px;
  border-radius: 10px;
  background: #e0edff;
  border: 1px solid #aac6f2;
  font-size: 14px;
  font-weight: 500;
  width: 100%;
}

/* Riquadro extra per selettore province estremi */
#filtro-prov-extremi-container {
  margin-top: 12px;
  background: #f3f7fc;
  padding: 12px;
  border-radius: 10px;
}

/* Etichetta "Tabella: dati in tempo reale" */
#filtro-mlg {
  display: none;
}
/* Rimosso ::before duplicato per "Tabella: dati in tempo reale" */
/* .mlg-label-small::before { */
/* content: "Tabella: dati in tempo reale";
  font-size: 15px;
  font-weight: 600;
  color: #003366;
  display: block;
  margin-top: 16px;
  padding: 10px 14px;
  background: #ddeeff;
  border-radius: 10px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.05);
}

/* Card meteo ottimizzate */
#tabella .card {
  background: #ffffff;
  border: 1px solid #ccddee;
  border-radius: 14px;
  padding: 20px 18px;
  margin-bottom: 16px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  font-size: 15.5px;
  line-height: 1.7;
  transition: transform 0.2s ease;
}

#tabella .card:hover {
  transform: scale(1.01);
}

#tabella .card .intestazione {
  font-size: 17px;
  font-weight: 700;
  color: #003366;
  margin-bottom: 6px;
}

#tabella .card .dati {
  display: flex;
  flex-wrap: wrap;
  gap: 8px 16px;
  color: #333;
}

#tabella .card .dati span {
  display: flex;
  align-items: center;
  gap: 6px;
  font-weight: 500;
}

#tabella .card .dati .valore {
  font-weight: 600;
  color: #0055aa;
}

#tabella .card .badge {
  display: inline-block;
  padding: 5px 8px;
  background: #007bff;
  color: white;
  font-size: 12px;
  border-radius: 6px;
  font-weight: bold;
  margin-top: 10px;
}

/* Mobile fix */
@media (max-width: 480px) {
  #anteprima-dati-testuali {
    padding: 20px 12px;
  }

  .filtro-box {
    padding: 12px;
  }

  .filtro-riga-select {
    gap: 8px;
  }

  #tabella .card {
  background: #ffffff;
  border: 1px solid #ccddee;
  border-radius: 14px;
  padding: 20px 18px;
  margin-bottom: 16px;
  box-shadow: 0 2px 6px rgba(0,0,0,0.08);
  font-size: 15.5px;
  line-height: 1.7;
  transition: transform 0.2s ease;
}
}</style><style>
/* CORREZIONE POSIZIONE MLG + TESTO STATICO "Dati testuali in tempo reale" */
#filtro-mlg {
  margin-top: 16px;
  transform: scale(1.05);
  margin-right: 8px;
}
.mlg-label-small {
  display: flex;
  align-items: center;
  font-size: 14px;
  font-weight: 500;
  color: #003366;
  margin: 12px 0 4px 0;
}

/* Etichetta sostitutiva sopra i filtri */
#label-dati-realtime {
  font-size: 16px;
  font-weight: 600;
  color: #002b55;
  padding: 10px 14px;
  background: #ddeeff;
  border-radius: 10px;
  margin-bottom: 14px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.05);
  text-align: center;
}
</style><style>
/* FIX larghezza elementi e spostamento */
.filtro-riga-select {
  display: flex;
  flex-direction: column;
  gap: 10px;
  font-size: 15px;
  margin-bottom: 14px;
}

.filtro-riga-select label {
  font-weight: 600;
  margin-bottom: 2px;
}

#filtro-provincia,
#filtro-ordinamento,
#filtro-provincia-estremi {
  width: 100%;
  max-width: 280px;
  padding: 7px 12px;
  border-radius: 8px;
  background: #e0edff;
  border: 1px solid #aac6f2;
  font-size: 14px;
  font-weight: 500;
}

/* Etichetta tabella spostata sopra */
#label-dati-realtime {
  font-size: 16px;
  font-weight: 600;
  color: #002b55;
  padding: 10px 14px;
  background: #ddeeff;
  border-radius: 10px;
  margin: 10px 0 18px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.05);
  text-align: center;
}

/* Checkbox filtro finale */
#filtro-mlg {
  margin-top: 16px;
  transform: scale(1.05);
  margin-right: 8px;
}
.mlg-label-small {
  display: flex;
  align-items: center;
  font-size: 14px;
  font-weight: 500;
  color: #003366;
  margin: 12px 0 8px;
}
</style><style>
#tabella .card {
  background: #ffffff;
  border: 1px solid #bbcfe6;
  border-radius: 16px;
  padding: 22px 20px;
  margin-bottom: 18px;
  box-shadow: 0 3px 8px rgba(0,0,0,0.05);
  font-size: 16px;
  line-height: 1.7;
  transition: transform 0.2s ease;
  width: 100%;
  max-width: 680px;
  margin-left: auto;
  margin-right: auto;
}
#tabella .card:hover {
  transform: scale(1.015);
}
#tabella .card .intestazione {
  font-size: 19px;
  font-weight: 700;
  color: #002a4d;
  margin-bottom: 10px;
}
@media (max-width: 480px) {
  #tabella .card {
    padding: 18px 16px;
    font-size: 15px;
  }
  #tabella .card .intestazione {
    font-size: 17px;
  }
}</style><style>
/* MIGLIORAMENTO GRAFICO CARDS ORIGINALE */
#tabella .card {
  background: #ffffff;
  border: 1px solid #ccddee;
  border-radius: 16px;
  padding: 22px 20px;
  margin: 20px auto;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
  font-size: 16px;
  line-height: 1.7;
  transition: transform 0.2s ease;
  width: 95%;
  max-width: 840px;
}
#tabella .card:hover {
  transform: scale(1.015);
}
#tabella .card .intestazione {
  font-size: 20px;
  font-weight: 700;
  color: #002a4d;
  margin-bottom: 12px;
}
#tabella .card .dati {
  display: flex;
  flex-wrap: wrap;
  gap: 10px 18px;
  color: #333;
}
#tabella .card .dati span {
  display: flex;
  align-items: center;
  gap: 6px;
  font-weight: 500;
}
#tabella .card .dati .valore {
  font-weight: 600;
  color: #0055aa;
}
#tabella .card .badge {
  display: inline-block;
  padding: 5px 10px;
  background: #007bff;
  color: white;
  font-size: 13px;
  border-radius: 6px;
  font-weight: bold;
  margin-top: 12px;
}

@media (max-width: 480px) {
  #tabella .card {
    padding: 18px 16px;
    font-size: 15.5px;
  }
  #tabella .card .intestazione {
    font-size: 18px;
  }
}</style><style>
#tabella .card {
  background: #ffffff;
  border: 1px solid #ccddee;
  border-radius: 16px;
  padding: 20px;
  margin: 20px auto;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
  font-size: 15.5px;
  line-height: 1.6;
  width: 95%;
  max-width: 100%;
  box-sizing: border-box;
}

#tabella .card .intestazione {
  font-size: 18px;
  font-weight: bold;
  color: #003366;
  margin-bottom: 12px;
}

#tabella .card .dati {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
  gap: 10px 14px;
  color: #333;
  width: 100%;
}

#tabella .card .dati span {
  display: flex;
  flex-direction: column;
  font-weight: 500;
  font-size: 14px;
}

#tabella .card .dati .valore {
  font-weight: bold;
  color: #0055aa;
  font-size: 15px;
}

#tabella .card .badge {
  margin-top: 12px;
  background: #007bff;
  color: white;
  padding: 6px 10px;
  font-size: 13px;
  border-radius: 6px;
  font-weight: bold;
  display: inline-block;
}

/* Responsive fix per schermi piccoli */
@media (max-width: 480px) {
  #tabella .card {
    padding: 16px 14px;
    font-size: 14.5px;
  }

  #tabella .card .intestazione {
    font-size: 16px;
  }

  #tabella .card .dati span {
    font-size: 13.5px;
  }

  #tabella .card .dati .valore {
    font-size: 14px;
  }
}</style><style>
/* Allinea le card a sinistra e sfrutta meglio lo spazio disponibile */
#tabella {
  padding-bottom: 260px; /* Evita sovrapposizione con la sezione fissa */
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
  gap: 16px;
  padding: 12px;
}

#tabella .card {
  width: calc(50% - 16px);
  margin: 0;
  background: #ffffff;
  border: 1px solid #ccddee;
  border-radius: 16px;
  padding: 20px;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.08);
  font-size: 15.5px;
  line-height: 1.6;
  box-sizing: border-box;
  transition: transform 0.2s ease;
}

#tabella .card:hover {
  transform: scale(1.015);
}

#tabella .card .intestazione {
  font-size: 18px;
  font-weight: bold;
  color: #003366;
  margin-bottom: 12px;
}

#tabella .card .dati {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(130px, 1fr));
  gap: 10px 14px;
  color: #333;
  width: 100%;
}

#tabella .card .dati span {
  display: flex;
  flex-direction: column;
  font-weight: 500;
  font-size: 14px;
}

#tabella .card .dati .valore {
  font-weight: bold;
  color: #0055aa;
  font-size: 15px;
}

#tabella .card .badge {
  margin-top: 12px;
  background: #007bff;
  color: white;
  padding: 6px 10px;
  font-size: 13px;
  border-radius: 6px;
  font-weight: bold;
  display: inline-block;
}

/* Visualizzazione mobile: una sola colonna */
@media (max-width: 600px) {
  #tabella .card {
    width: 100%;
  }
}</style><style>
#tabella {
  padding-bottom: 260px; /* Evita sovrapposizione con la sezione fissa */
  display: flex;
  flex-wrap: wrap;
  justify-content: flex-start;
  gap: 16px;
  padding: 12px;
}

#tabella .card {
  margin: 0 !important;
  width: calc(50% - 16px);
  box-sizing: border-box;
}

@media (max-width: 600px) {
  #tabella .card {
    width: 100%;
  }
}
</style><style>
#tabella {
  padding-bottom: 260px; /* Evita sovrapposizione con la sezione fissa */
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: flex-start !important;
  align-items: flex-start !important;
  padding: 12px !important;
  gap: 16px !important;
}

#tabella .card {
  margin: 0 !important;
  width: calc(50% - 16px) !important;
  box-sizing: border-box !important;
  max-width: none !important;
}

@media (max-width: 600px) {
  #tabella .card {
    width: 100% !important;
  }
}
</style>
<style>
#anteprima-dati-testuali {
  background: #f5f9ff;
  border-top: 2px solid #1a3a9b;
  border-radius: 14px 14px 0 0;
  box-shadow: 0 -1px 4px rgba(0,0,0,0.05);
  font-family: "Segoe UI", sans-serif;
  padding: 16px 12px 10px;
}

#anteprima-dati-testuali > div:first-child {
  font-weight: 700;
  font-size: 15px;
  color: #1a3a9b;
  text-align: center;
  margin-bottom: 12px;
}

#anteprima-dati-testuali label {
  font-size: 13.5px;
  color: #003366;
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 6px;
  margin-bottom: 8px;
}

#anteprima-dati-testuali input[type="checkbox"] {
  transform: scale(0.95);
}

.filtro-riga-combinata {
  display: flex;
  flex-direction: column;
  gap: 10px;
  background: #e6efff;
  border: 1px solid #bcd0ee;
  padding: 10px;
  border-radius: 8px;
  margin-top: 10px;
}

#filtro-provincia, #filtro-ordinamento {
  background: #ffffff;
  border: 1px solid #aac6f2;
  padding: 6px 8px;
  border-radius: 6px;
  font-weight: 600;
  font-size: 13px;
  width: 100%;
  color: #002a4d;
}

.filtro-riga-combinata label {
  margin: 0;
}

@media (max-width: 480px) {
  #anteprima-dati-testuali {
    padding: 14px 10px 8px;
  }

  #anteprima-dati-testuali label {
    font-size: 13px;
  }

  #filtro-provincia, #filtro-ordinamento {
    font-size: 12.5px;
  }
}

#anteprima-dati-testuali {
  margin-left: 40px;
}
</style>
<style>
@media (min-width: 600px) {
  body {
    padding-left: 60px !important;
  }
}
</style>
<style>
#tabella .card {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #ffffff;
  border: 1px solid #dde3ec;
  border-radius: 10px;
  padding: 12px 18px;
  margin-bottom: 12px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.04);
  transition: transform 0.2s ease;
  font-size: 15.5px;
  line-height: 1.6;
}

#tabella .card:hover {
  transform: scale(1.015);
}

#tabella .card .intestazione {
  font-weight: 600;
  font-size: 16px;
  color: #222;
}

#tabella .card .dati {
  display: flex;
  flex-wrap: wrap;
  gap: 6px 14px;
  color: #333;
}

#tabella .card .dati span {
  display: flex;
  align-items: center;
  gap: 5px;
  font-weight: 500;
}

#tabella .card .dati .valore {
  font-weight: 600;
  color: #0055aa;
}

#tabella .card .badge {
  margin-left: auto;
  background-color: #007bff;
  border: none;
  padding: 6px 12px;
  color: white;
  border-radius: 6px;
  cursor: pointer;
  transition: background 0.3s;
}
</style>
<style>
/* Overlay watermark visibile sopra tutto ma non cliccabile */
.watermark-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 9999;
  pointer-events: none;
  background-image: url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='180' height='28'><text x='0' y='20' font-size='12' fill='rgba(0,0,0,0.05)' font-family='Arial'>Meteo Lo Gullo Meteo Lo Gullo Meteo Lo Gullo</text></svg>");
  background-repeat: repeat;
  background-size: 180px 28px;
  mix-blend-mode: multiply;
}
</style>
<style>
/* Aspetto coerente con le card sottostanti */
#anteprima-dati-testuali {
  background: #ffffff;
  border-top: 2px solid #ccddee;
  border-radius: 16px 16px 0 0;
  box-shadow: 0 -1px 5px rgba(0, 0, 0, 0.05);
  padding: 20px 16px;
  font-family: "Segoe UI", sans-serif;
  transition: background 0.3s ease;
}

/* Leggero margine negativo solo per unione visiva */
#tabella {
  margin-top: -6px;
  padding-top: 0;
}

/* Card coerenti come già impostato, mantenute flessibili */
#tabella .card {
  background: #ffffff;
  border: 1px solid #ccddee;
  border-radius: 16px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
  transition: transform 0.2s ease;
}

#tabella .card:hover {
  transform: scale(1.01);
}
</style>
<!-- Fix: uniforma larghezza di tutte le card nella tabella -->
<style id="fix-card-dimensions">
  /* Forza ogni card ad occupare metà riga (con il gap già presente) */
  #tabella .card{
    flex: 0 0 calc(50% - 16px) !important;   /* base fissa e nessun ridimensionamento */
    width: calc(50% - 16px) !important;       /* stesso valore di fallback */
    max-width: none !important;               /* evita max‑width più piccole */
    margin: 0 !important;                     /* elimina centraggi automatici */
  }
  /* Mobile: una colonna piena */
  @media (max-width: 600px){
    #tabella .card{
      flex: 0 0 100% !important;
      width: 100% !important;
    }
  }
</style>
<link href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" rel="stylesheet"/><script defer="" src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<style id="webcam_amantea_fix">
/* Popup clipping */
.leaflet-popup-content{overflow:hidden;}

/* Webcam zoom via transform: horizontal 3×, recenter */
img.webcam-preview[src*="webcam_spiaggia_pulita"],
iframe.webcam-preview[src*="webcam_spiaggia_pulita"]{
  height:100px !important;
  width:100%  !important;
  transform:translateX(-10%) scaleX(3) !important; /* 3× larghezza, shift 1/3 a sinistra */
  transform-origin:center center !important;
  object-fit:contain !important; /* keep height */
  display:block;
}
</style>
<style id="mobile-popup-shrink">
/* Popup stazioni: versione compatta per telefoni */
@media (max-width: 520px){
  .leaflet-popup-content-wrapper,
  .leaflet-popup-tip{
    max-width: 220px;
    padding: 4px;
  }
  .leaflet-popup-content{
    font-size: 12px !important;
    line-height: 1.3 !important;
    margin: 4px 6px !important;
  }
  .popup-title{ font-size: 14px !important; }
  .popup-sub{ font-size: 12px !important; }
  .popup-data{ font-size: 12px !important; }
}
</style>
<style id="mobile-popup-nowrap">
/* Pop‑up stazioni: no wrap ma dimensione moderata su schermi piccoli */
@media (max-width: 520px){
  .leaflet-popup-content-wrapper,
  .leaflet-popup-tip{
    width: auto !important;       /* si adatta leggermente al testo */
    min-width: 220px !important;  /* non più piccolo del default */
    max-width: 300px !important;  /* resta comunque compatto */
  }
  .leaflet-popup-content{
    overflow-x: auto;             /* se necessario scroll orizzontale */
  }
  .popup-title,
  .popup-sub,
  .popup-data{
    white-space: nowrap !important; /* impedisce l'andata a capo */
  }
}
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
<!-- Infocard v8 -->
<style id="infocard-upgrade">
/* identical CSS as v7 */
#tabella{display:flex;flex-wrap:wrap;gap:14px;justify-content:flex-start;align-items:stretch;padding:0;}
#tabella > div:has(#riepilogo-testo){flex:0 0 100%!important;width:100%!important;}
#tabella > div:not(:has(#riepilogo-testo)){flex:0 0 230px;max-width:230px;background:#fff!important;border-radius:14px!important;box-shadow:0 3px 12px rgba(0,0,0,.07)!important;padding:14px 16px!important;display:flex!important;flex-direction:column!important;align-items:center!important;position:relative;transition:transform .25s ease,box-shadow .25s ease;}
#tabella > div:not(:has(#riepilogo-testo)):hover{transform:translateY(-4px);box-shadow:0 8px 20px rgba(0,0,0,.12);}
#tabella > div:not(:has(#riepilogo-testo)) > div:first-child{font:600 .93rem/1.25 "Segoe UI",sans-serif!important;color:#012860!important;text-align:center;margin-bottom:6px!important;width:100%;}
#tabella > div:not(:has(#riepilogo-testo)) > div:nth-child(n+2){display:flex!important;flex-wrap:wrap!important;justify-content:center;gap:5px 8px!important;width:100%!important;}
#tabella .metric{font:500 .8rem/1.25 "Segoe UI",sans-serif!important;color:#333!important;white-space:nowrap;}
#tabella .main-metric{font:800 1.9rem/1.1 "Segoe UI",sans-serif!important;color:#111!important;width:100%!important;text-align:center;margin-bottom:4px!important;}
#tabella .metric-hidden{display:none!important;}
#tabella > div:not(:has(#riepilogo-testo)) .badge{position:absolute;top:12px;right:12px;font-size:.65rem;padding:3px 7px;background:#ff7b00;color:#fff;border-radius:9999px;box-shadow:0 2px 6px rgba(0,0,0,.14);}
@media(max-width:550px){#tabella{gap:12px;}#tabella > div:not(:has(#riepilogo-testo)){flex:0 0 calc(50% - 12px);max-width:none;min-width:150px;}#tabella .main-metric{font-size:1.5rem!important;}}
body{background:#f4f7fc!important;}
</style>
<!-- ChatGPT patch: ensure two cards per row also on small screens -->
<style id="chatgpt-mobile-2col">
@media (max-width: 600px){
  /* forza due card affiancate */
  #tabella > div:not(:has(#riepilogo-testo)),
  #tabella .card{
     flex: 0 0 50% !important;
     width: 50% !important;
     max-width: 50% !important;
  }
}
</style>
<!-- ChatGPT patch v6: force minimum two cards per row on very small screens -->
<style id="chatgpt-mobile-2col-v6">
@media (max-width: 640px){
  /* Each card container takes half the width minus small gap */
  #tabella > div:not(:has(#riepilogo-testo)){
     flex: 0 0 calc(50% - 8px) !important;
     max-width: calc(50% - 8px) !important;
     width: calc(50% - 8px) !important;
  }
}
</style>
<!-- ChatGPT patch v7: enforce two cards per row on mobile using CSS Grid -->
<style id="chatgpt-mobile-grid-v7">
  @media (max-width: 640px){
    #tabella{
      display: grid !important;
      grid-template-columns: repeat(2, 1fr) !important;
      gap: 8px !important;
      align-items: stretch !important;
    }
    #tabella > div:not(:has(#riepilogo-testo)){
      width: 100% !important;
      margin: 0 !important;
      min-height: 200px !important; /* optional uniformity */
      box-sizing: border-box !important;
    }
  }
</style>
<!-- ChatGPT patch v8: final mobile two-column layout and uniform card sizing -->
<style id="chatgpt-mobile-grid-v8">
@media (max-width: 640px){
  #tabella{
    display: grid !important;
    grid-template-columns: repeat(2, 1fr) !important;
    gap: 8px !important;
  }
  #tabella > div:not(:has(#riepilogo-testo)){
    margin: 0 !important;
    width: auto !important;
    max-width: none !important;
    height: 100% !important;
    min-height: 200px !important;
    display: flex !important;
    flex-direction: column !important;
  }
}
</style>
<!-- ChatGPT patch v9: refine mobile grid and card uniformity -->
<style id="chatgpt-mobile-grid-v9">
@media (max-width: 640px){
  #tabella{
    width:100% !important;
    padding:0 !important;
    margin:0 auto !important;
    display:grid !important;
    grid-template-columns:repeat(2,1fr) !important;
    grid-auto-rows:1fr !important; /* rows equal height */
    gap:4px !important;
  }
  /* generic card */
  #tabella > div:not(:has(#riepilogo-testo)){
    margin:0 !important;
    width:100% !important;
    height:100% !important;
    box-sizing:border-box !important;
    display:flex !important;
    flex-direction:column !important;
    justify-content:space-between !important; /* forces footer at bottom */
    border-radius:12px !important;
    overflow:hidden !important;
  }
  /* ensure title zone always fixed height */
  #tabella > div:not(:has(#riepilogo-testo)) h3{
    margin:0 0 4px 0 !important;
    min-height:48px !important;
    display:flex;
    align-items:center;
    justify-content:center;
    text-align:center;
  }
}
</style>
<!-- ChatGPT patch v10: remove header‑content gap, harmonize first card, tighten grid -->
<style id="chatgpt-mobile-grid-v10">
@media (max-width: 640px){
  #tabella{
    gap:2px !important;
  }
  #tabella > div:not(:has(#riepilogo-testo)){
    display:flex !important;
    flex-direction:column !important;
    justify-content:flex-start !important; /* eliminate big gap */
  }
  /* push last element (timestamp) to bottom */
  #tabella > div:not(:has(#riepilogo-testo)) > *:last-child{
    margin-top:auto !important;
  }
  /* tighter title spacing */
  #tabella > div:not(:has(#riepilogo-testo)) h3{
    margin:4px 2px 2px 2px !important;
    min-height:auto !important; /* allow natural height */
  }
}
</style>
<!-- ChatGPT patch v11: fix title‑data gap, uniform card layout, make riepilogo full‑width -->
<style id="chatgpt-mobile-grid-v11">
@media (max-width: 640px){
  /* Grid container */
  #tabella{
    width:100%!important;
    margin:0 auto!important;
    padding:0!important;
    display:grid!important;
    grid-template-columns:repeat(2,1fr)!important;
    gap:4px!important;
  }

  /* Summary box spans full width and keeps block flow */
  #tabella > div:has(#riepilogo-testo){
    grid-column:1 / -1!important;
    display:block!important;
  }

  /* Generic card layout */
  #tabella > div:not(:has(#riepilogo-testo)){
    box-sizing:border-box!important;
    display:flex!important;
    flex-direction:column!important;
    justify-content:flex-start!important;
    padding:8px!important;
    margin:0!important;
  }

  /* Title */
  #tabella > div:not(:has(#riepilogo-testo)) h3{
    margin:0 0 4px 0!important;
    text-align:center!important;
    line-height:1.2!important;
  }

  /* Ensure info rows compact & consistent */
  #tabella > div:not(:has(#riepilogo-testo)) > *:not(h3){
    margin:2px 0!important;
  }

  /* Keep timestamp at bottom */
  #tabella > div:not(:has(#riepilogo-testo)) > *:last-child{
    margin-top:auto!important;
  }
}
</style>
<!-- ChatGPT patch v12: zero title-gap, tighter metric spacing, consistent card style -->
<style id="chatgpt-mobile-grid-v12">
@media (max-width:640px){
  /* zero margin between title and metrics */
  #tabella > div:not(:has(#riepilogo-testo)) h3{
    margin:0 0 2px 0 !important;
    text-align:center!important;
    line-height:1.15!important;
  }

  /* override inline gap inside metrics flex wrapper */
  #tabella > div:not(:has(#riepilogo-testo)) > div:nth-child(2){
    gap:4px !important;
    align-items:flex-start!important;
  }

  /* remove extra left/right padding to maximize width in column */
  #tabella > div:not(:has(#riepilogo-testo)){
    padding:6px!important;
  }
}
</style>
<!-- ChatGPT uniform-card-patch v2 -->
<script id="uniform-card-patch-js">
window.addEventListener('load', () => {
  const css = `
/* === ChatGPT uniform-card-patch v2 === */
#tabella > div:not(:has(#riepilogo-testo)),
#tabella .card{
    flex: 0 0 230px !important;
    width: 230px !important;
    max-width: 230px !important;
    margin: 0 !important;
    background: #ffffff !important;
    border: 1px solid #ccddee !important;
    border-radius: 14px !important;
    box-shadow: 0 3px 12px rgba(0,0,0,.07) !important;
    padding: 14px 16px !important;
    display: flex !important;
    flex-direction: column !important;
    align-items: center !important;
    position: relative !important;
    box-sizing: border-box !important;
    transition: transform .25s ease, box-shadow .25s ease;
}
#tabella > div:not(:has(#riepilogo-testo)):hover,
#tabella .card:hover{
    transform: translateY(-4px);
    box-shadow: 0 8px 20px rgba(0,0,0,.12);
}
#tabella > div:not(:has(#riepilogo-testo)) > div:first-child,
#tabella .card > div:first-child{
    font: 600 .93rem/1.25 "Segoe UI", sans-serif !important;
    color: #012860 !important;
    text-align: center !important;
    margin-bottom: 6px !important;
    width: 100%;
}
#tabella > div:not(:has(#riepilogo-testo)) > div:nth-child(n+2),
#tabella .card > div:nth-child(n+2){
    display: flex !important;
    flex-wrap: wrap !important;
    justify-content: center !important;
    gap: 5px 8px !important;
    width: 100% !important;
}
#tabella .metric,
#tabella > div:not(:has(#riepilogo-testo)) .metric{
    font: 500 .8rem/1.25 "Segoe UI", sans-serif !important;
    color: #333 !important;
    white-space: nowrap;
}
#tabella .main-metric,
#tabella > div:not(:has(#riepilogo-testo)) .main-metric{
    font: 800 1.9rem/1.1 "Segoe UI", sans-serif !important;
    color: #111 !important;
    width: 100% !important;
    text-align: center !important;
    margin-bottom: 4px !important;
}
#tabella .metric-hidden,
#tabella > div:not(:has(#riepilogo-testo)) .metric-hidden{
    display: none !important;
}
#tabella > div:not(:has(#riepilogo-testo)) .badge,
#tabella .card .badge{
    position: absolute;
    top: 12px;
    right: 12px;
    font-size: .65rem;
    padding: 3px 7px;
    background: #ff7b00;
    color: #fff;
    border-radius: 9999px;
    box-shadow: 0 2px 6px rgba(0,0,0,.14);
}
@media(max-width:550px){
    #tabella{gap:12px!important;}
    #tabella > div:not(:has(#riepilogo-testo)),
    #tabella .card{
        flex: 0 0 calc(50% - 12px) !important;
        width: calc(50% - 12px) !important;
        max-width: calc(50% - 12px) !important;
    }
    #tabella > div:not(:has(#riepilogo-testo)) .main-metric,
    #tabella .card .main-metric{
        font-size: 1.5rem !important;
    }
}
`;
  const style = document.createElement('style');
  style.id = 'uniform-card-patch';
  style.textContent = css;
  document.head.appendChild(style);
});
</script>

<!-- ChatGPT mobile beautify v10 -->
<style id="top10-overlay-css-v10">
.top10-overlay{
  background:rgba(255,255,255,0.6) !important;
  backdrop-filter:blur(8px);
  border:1px solid rgba(255,255,255,0.4) !important;
  border-radius:14px !important;
  box-shadow:0 8px 24px rgba(0,0,0,0.15) !important;
  font-family:"Helvetica Neue",Arial,sans-serif !important;
}
.top10-overlay div{
  line-height:1.25em;
}
@media(max-width:600px){
  .top10-overlay{
    width:95vw !important;
    max-height:65vh !important;
    padding:14px 18px !important;
  }
  .top10-overlay div{font-size:15px !important;}
}
</style>


<!-- ChatGPT sidebar order v11 -->
<style id="sidebar-order-v11">
#btnScreenshot{order:99!important;margin-top:auto;}
</style>


<!-- ChatGPT sidebar reorder v12 -->
<style id="sidebar-reorder-v12">
#btnScreenshot{
  order:98 !important;
  margin-top:0 !important;
}
#ordToggle{
  order:99 !important;
}
</style>


<!-- Patch trasparenza radar controls -->
<style id="radar-controls-transparent">
  /* Semi‑trasparenza e look meno invasivo */
  #radar-controls{
    background: rgba(255,255,255,0.45) !important;
    box-shadow: 0 0 6px rgba(0,0,0,0.2) !important;
    backdrop-filter: blur(4px);
  }
  /* Miglioramenti mobile */
  @media (max-width: 600px){
    #radar-controls{
      top: 72px !important;   /* subito sotto il banner */
      right: 6px !important;
      padding: 6px 8px !important;
    }
  }
</style>

<!-- ChatGPT FASTLOAD v2 2025-07-11 -->
<script type="module" id="fastload-20250711-v2">
(() => {
  const OM_MAX = 8;
  const WU_MAX = 4;
  const TIMEOUT = 12000;
  const CACHE_MS = 10 * 60e3;

  /* -------------------------------------------------
   *  Utility
   * ------------------------------------------------- */
  const ready = fn => {
    if (document.readyState === "complete" || document.readyState === "interactive") { fn(); }
    else document.addEventListener("DOMContentLoaded", fn, { once:true });
  };

  /* -------------------------------------------------
   * 1. Open‑Meteo  hook (waits for original function)
   * ------------------------------------------------- */
  ready(() => {
    const waitHook = () => {
      if (typeof window.caricaDatiOpenMeteo !== "function" || !Array.isArray(window.stazioni)) return false;

      const key = s => 'om_' + s.stationId;
      const read = s => {
        try {
          const j = localStorage.getItem(key(s));
          if (!j) return null;
          const { ts, data } = JSON.parse(j);
          return Date.now() - ts < CACHE_MS ? data : null;
        } catch { return null; }
      };
      const save = (s,d) => { try {localStorage.setItem(key(s), JSON.stringify({ts:Date.now(), data:d}));}catch{}; };

      const build = (s,d)=>({
        stationId:s.stationId,
        temp:d.current.temperature_2m,
        tempVal:d.current.temperature_2m,
        pioggia:d.current.precipitation,
        umidita:d.current.relativehumidity_2m,
        raffica:d.current.wind_gusts_10m,
        percepitaVal:(typeof calcolaPercepita==="function")
          ? calcolaPercepita(d.current.temperature_2m,d.current.relativehumidity_2m,d.current.wind_speed_10m)
          : null
      });

      async function fetchOM (s){
        const cached = read(s);
        if (cached) return build(s,cached);

        const ctrl = new AbortController();
        const t = setTimeout(()=>ctrl.abort(), TIMEOUT);
        try{
          const url = \`https://api.open-meteo.com/v1/forecast?latitude=\${s.lat}&longitude=\${s.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m,wind_speed_10m&timezone=auto\`;
          const r = await fetch(url,{signal:ctrl.signal});
          if(!r.ok) throw new Error(r.status);
          const data = await r.json();
          save(s,data);
          return build(s,data);
        }finally{ clearTimeout(t); }
      }

      const orig = window.caricaDatiOpenMeteo;
      window.caricaDatiOpenMeteo = async () => {
        const list = window.stazioni.filter(st => st.openMeteo);
        const it = list[Symbol.iterator]();
        window.datiTabella = window.datiTabella || [];
        let running = 0;
        return new Promise(res=>{
          const next = () => {
            if (running>=OM_MAX) return;
            const {value:st,done} = it.next();
            if(done){ if(running===0) res(); return; }
            running++;
            fetchOM(st)
              .then(e=>{ if(e) window.datiTabella.push(e); })
              .catch(err=>console.warn("OM err",st?.stationId,err))
              .finally(()=>{ running--; next(); });
            if(running<OM_MAX) next();
          };
          next();
        });
      };
      console.info("Fastload‑v2: caricaDatiOpenMeteo hooked");
      return true;
    };
    if (!waitHook()) {
      const id = setInterval(() => { if (waitHook()) clearInterval(id); }, 50);
    }
  });

  /* -------------------------------------------------
   * 2. Weather Underground fetch queue + cache
   * ------------------------------------------------- */
  (function(){
    const origFetch = window.fetch;
    const q = [];
    let running = 0;
    const key=id=>'wu_'+id;
    const read=id=>{ try{const j=sessionStorage.getItem(key(id));if(!j)return null;const {ts,data}=JSON.parse(j);return Date.now()-ts<CACHE_MS?data:null;}catch{return null;} };
    const save=(id,d)=>{ try{sessionStorage.setItem(key(id),JSON.stringify({ts:Date.now(),data:d}));}catch{} };

    const schedule = req => {
      q.push(req);
      pump();
    };
    const pump = ()=>{
      if(running>=WU_MAX || !q.length) return;
      const {url, opts, resolve, reject, id} = q.shift();
      running++;
      origFetch(url,opts).then(r=>{
        if(id){
          r.clone().json().then(d=>save(id,d)).catch(()=>{});
        }
        resolve(r);
      }).catch(reject).finally(()=>{running--;pump();});
    };

    window.fetch = function(url,opts){
      if(typeof url === "string" && url.includes("/v2/pws/observations/current")){
        const id = /stationId=([A-Z0-9]+)/i.exec(url)?.[1];
        const cached = id && read(id);
        if(cached){
          return Promise.resolve(new Response(JSON.stringify(cached),{status:200,headers:{'Content-Type':'application/json'}}));
        }
        return new Promise((res,rej)=>schedule({url,opts,resolve:res,reject:rej,id}));
      }
      return origFetch(url,opts);
    };
  })();
})();
</script>


<style id="map-loader-style">
  #map.loading {
    filter: blur(2px);
    opacity: 0.4;
    pointer-events: none;
    transition: opacity 0.5s ease, filter 0.5s ease;
  }

  #map-loader-banner {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 1000;
    display: flex;
    align-items: center;
    gap: 10px;
    background: rgba(255, 255, 255, 0.9);
    padding: 16px 24px;
    border-radius: 10px;
    box-shadow: 0 0 10px rgba(0,0,0,0.15);
    font-family: sans-serif;
  }

  #map-loader-banner .spinner {
    width: 24px;
    height: 24px;
    border: 4px solid #ccc;
    border-top-color: #1a3a9b;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  #map-loader-banner.hide {
    display: none;
  }
</style>

<style id="prevent-zoom">
  /* Evita lo zoom pinch sulle aree UI (sidebar, pannelli, popup),
     lasciando libero solo la mappa per il pinch‑zoom di Leaflet */
  @media (pointer: coarse) {
    #sidebar,
    #anteprima-dati-testuali,
    .leaflet-popup-content-wrapper {
      touch-action: pan-y;  /* consente lo scroll verticale ma blocca pinch */
    }
  }

/* Aggiornamento: estendo la protezione anche ai popup.
   Blocca il pinch Zoom fuori dalla mappa e fa sì che, con popup aperto,
   il pinch venga gestito solo dal layer Leaflet */
@media (pointer: coarse) {
  .leaflet-popup,
  .leaflet-popup-content-wrapper,
  .leaflet-popup-tip-container {
    touch-action: none;   /* nessun pinch, nessun doppio‑tap zoom di pagina */
  }
}</style>
<link crossorigin="" href="https://fonts.googleapis.com" rel="preconnect">
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect">
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&amp;family=Baloo+2:wght@600&amp;display=swap" rel="stylesheet">
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet">
<style id="mlg-banner-style">
/* === MLG Banner (inserito) =============================================== */
:root{
  --mlg-blue:#1e43a5;
  --mlg-blue-2:#163a93;
}
.mlg-banner{ 
  width:100vw;
  margin-left:calc(50% - 50vw);
  margin-right:calc(50% - 50vw);
  background:linear-gradient(180deg,var(--mlg-blue),var(--mlg-blue-2));
  color:#fff;
  box-shadow:0 6px 16px rgba(0,0,0,.28);
  border-radius:0; /* edge-to-edge */
}
.mlg-banner .mlg-inner{
  max-width:1100px; margin:0 auto;
  display:flex; align-items:center; gap:14px;
  padding:12px 16px;
}
.mlg-title{ display:flex; align-items:center; gap:10px; font-weight:800; 
            letter-spacing:.2px; font-size:clamp(18px,2.4vw,22px); }
.mlg-dot{ width:11px; height:11px; border-radius:50%; background:#cfe0ff;
          box-shadow:0 0 0 3px #ffffff33; flex:0 0 auto;}
.mlg-nav{ margin-left:auto; display:flex; gap:10px; flex-wrap:wrap; }
.mlg-pill{ display:inline-flex; align-items:center; justify-content:center;
           padding:10px 16px; border-radius:999px; font-weight:700; 
           text-decoration:none; color:#fff; background:#ffffff18; 
           border:1px solid #ffffff2b; transition:background .15s, transform .05s; }
.mlg-pill:hover{ background:#ffffff2e; }
.mlg-pill:active{ transform:translateY(1px); }
.mlg-toggle{ display:none; margin-left:auto; border:1px solid #ffffff2b; 
             background:#ffffff18; color:#fff; font-weight:800; 
             border-radius:999px; padding:10px 14px; cursor:pointer; }
.mlg-menu{ display:none; border-top:1px solid #ffffff24; 
           background:linear-gradient(180deg,var(--mlg-blue-2),#102b78); }
.mlg-menu.open{ display:block; }
.mlg-menu .mlg-grid{ max-width:1100px; margin:0 auto; padding:10px 16px 14px;
                     display:grid; gap:10px; grid-template-columns:repeat(2,minmax(0,1fr)); }
.mlg-menu .mlg-pill{ justify-content:center; }
@media (max-width: 860px){
  .mlg-nav{ display:none; }
  .mlg-toggle{ display:inline-flex; }
}
@media (min-width: 861px){
  .mlg-menu{ display:none !important; }
}
/* Per sicurezza: evita contenuti decorativi indesiderati da CSS globali */
.mlg-banner *::before, .mlg-banner *::after{ content: normal !important; }


/* Reset top gap and polish spacing */
html, body { margin: 0 !important; }
.mlg-banner { position: relative; margin-bottom: 14px; }

/* Mobile chip scroller */
@media (max-width: 860px){
  .mlg-inner{ flex-wrap: wrap; align-items: flex-start; row-gap: 8px; }
  .mlg-title{ padding-right: 6px; }
  .mlg-nav{
    order:2; width:100%;
    overflow-x:auto; overflow-y:hidden;
    flex-wrap:nowrap; gap:10px;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: none;
    padding-bottom: 6px;
    margin-left:0;
  }
  .mlg-nav::-webkit-scrollbar{ display:none; }
  .mlg-pill{ padding:9px 14px; }
}
</style>
<style id="mlg-banner-mobile-compact-2025-09-11">
@media (max-width: 860px){
  /* Stack title + single-row scroller, keep it tiny */
  .mlg-banner{ margin-bottom:8px !important; }
  .mlg-banner .mlg-inner{
    padding:6px 10px !important;
    row-gap:6px !important;
    flex-wrap:wrap !important;
    align-items:center !important;
  }
  .mlg-banner .mlg-title{
    width:100% !important;
    justify-content:center !important;
    text-align:center !important;
    margin:0 !important;
    gap:8px !important;
  }
  .mlg-banner .mlg-title span{ line-height:1.1 !important; }
  .mlg-banner .mlg-dot{ width:8px !important; height:8px !important; box-shadow:0 0 0 2px #ffffff33 !important; }

  /* Buttons: one single row, smaller, horizontal scroll if needed */
  .mlg-banner .mlg-nav{
    order:2 !important;
    width:100% !important;
    display:flex !important;
    flex-wrap:nowrap !important;
    overflow-x:auto !important;
    overflow-y:hidden !important;
    -webkit-overflow-scrolling:touch !important;
    gap:8px !important;
    padding:4px 6px 8px !important;
    margin:0 !important;
    scrollbar-width:none !important;
  }
  .mlg-banner .mlg-nav::-webkit-scrollbar{ display:none !important; }
  .mlg-banner .mlg-pill{
    flex:0 0 auto !important;
    padding:6px 10px !important;
    font-size:13px !important;
    line-height:1.1 !important;
  }
}
</style>
<style id="mlg-banner-mobile-compact-v2">
/* Kill default browser margins that create the white strip */
html, body { margin:0 !important; padding:0 !important; }
/* Ensure banner really sticks to the very top */
.mlg-banner{ margin-top:0 !important; border-top:0 !important; }
/* Tighter mobile layout */
@media (max-width: 860px){
  .mlg-banner .mlg-inner{
    padding:6px 10px !important;
    row-gap:4px !important;
  }
  .mlg-banner .mlg-nav{
    gap:6px !important;
    padding:2px 6px 6px !important; /* less vertical padding so buttons don't clip */
  }
  .mlg-banner .mlg-pill{
    padding:5px 9px !important;
    font-size:12px !important;
    line-height:1.1 !important;
  }
  /* Optional: slightly reduce dot size too */
  .mlg-banner .mlg-dot{ width:7px !important; height:7px !important; }
}
</style>
<style id="mlg-title-no-stripe-2025-09-11">
/* Rimuove la "striscetta bianca" a sinistra del titolo */
@media (max-width: 860px){
  .mlg-title .mlg-dot{ display:none !important; } /* nasconde il pallino decorativo */
}
/* Evita effetti di highlight/outline che possono sembrare una riga */
.mlg-title, .mlg-title *{
  -webkit-tap-highlight-color: transparent !important;
  outline: none !important;
  user-select: none !important;
}
</style>
<style id="mlg-banner-compact-2025-09-11">
/* Compatta il banner in mobile: meno blu sopra e sotto, senza stravolgere lo stile */
@media (max-width: 540px){
  .mlg-banner{
    padding-top: 8px !important;           /* prima era più alto */
    padding-bottom: 8px !important;
    margin-bottom: 8px !important;         /* riduce lo spazio blu sotto i pulsanti */
  }
  .mlg-banner .mlg-inner{
    row-gap: 4px !important;               /* stringe lo spazio tra titolo e pulsanti */
    min-height: 0 !important;              /* niente altezza minima gonfiata */
  }
  .mlg-banner .mlg-title{
    margin: 2px auto 2px !important;       /* più vicino ai pulsanti */
  }
  .mlg-banner .mlg-nav{
    padding-top: 0 !important;
    padding-bottom: 0 !important;
    margin-top: 0 !important;
    margin-bottom: 0 !important;
  }
  /* Se dopo il banner c'è molta aria, riducila un po' */
  .mlg-banner + *{
    margin-top: 8px !important;
  }
}
</style>
<style id="mlg-banner-compact-plus-2025-09-11">
/* Ancora più compatto sopra al titolo, senza arrivare a pelo */
@media (max-width: 540px){
  .mlg-banner{
    padding-top: 4px !important;      /* prima 8px */
    padding-bottom: 6px !important;
  }
  .mlg-banner .mlg-inner{
    row-gap: 2px !important;          /* avvicina titolo e pulsanti */
  }
  .mlg-banner .mlg-title{
    margin-top: 0 !important;
    margin-bottom: 2px !important;
    line-height: 1.05 !important;     /* stringe un filo la riga del titolo */
    font-size: clamp(18px, 5.4vw, 22px) !important; /* leggermente più snello su telefoni piccoli */
  }
}
</style>
<style id="mlg-banner-bright-2025-09-11">
/* ——— Banner più luminoso + bordo giallo sul tasto Home ——— */

/* Titolo più brillante */
.mlg-banner .mlg-title{
  color: #ffffff !important;
  text-shadow: 0 2px 6px rgba(0,0,0,.45), 0 0 1px rgba(255,255,255,.18) !important;
}

/* Pill più leggibili e "invoglianti" */
.mlg-banner .mlg-pill{
  color: #eef6ff !important;                     /* testo più chiaro */
  border-color: rgba(255,255,255,.35) !important;/* bordo un filo più visibile */
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.35),
    0 8px 16px rgba(0,0,0,.28) !important;       /* profondità */
  transition: transform .12s ease, filter .12s ease, box-shadow .12s ease;
}
.mlg-banner .mlg-pill:hover,
.mlg-banner .mlg-pill:focus-visible{
  filter: brightness(1.12) saturate(1.05);
  transform: translateY(-1px);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,.45),
    0 10px 20px rgba(0,0,0,.32) !important;
}

/* Stato attivo per "Home": solo il bordo giallo (riempimento invariato) */
.mlg-banner .mlg-pill.is-active{
  border-color: #FFD54A !important;
  box-shadow:
    inset 0 0 0 1px rgba(255,213,74,.65),
    0 0 0 2px rgba(255,213,74,.18),
    0 12px 22px rgba(0,0,0,.32) !important;
  filter: brightness(1.06) contrast(1.02);
}

/* Accessibilità: focus chiaro anche da tastiera */
.mlg-banner .mlg-pill:focus-visible{
  outline: 2px solid rgba(255,255,255,.45);
  outline-offset: 2px;
}

/* In mobile manteniamo le dimensioni compatte esistenti */
@media (max-width: 540px){
  .mlg-banner .mlg-pill{ color: #f5fbff !important; }
}
</style>
<style id="mlg-input-placeholder-ellipsis">
/* Placeholder con puntini se non entra tutto */
header.mlg-banner .mlg-search input::placeholder{
  white-space: nowrap !important;
  overflow: hidden !important;
  text-overflow: ellipsis !important;
}
</style>
<style id="mlg-hamburger-lines-fallback">
/* Disegna tre linee interne sul pulsante menu (sempre visibili, non rompe nulla) */
#mlgMenuBtn{ position: relative; }
#mlgMenuBtn::after{
  content: "";
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: 18px;
  height: 12px;
  /* tre righe orizzontali */
  background:
    linear-gradient(currentColor, currentColor) center 0/18px 2px no-repeat,
    linear-gradient(currentColor, currentColor) center 50%/18px 2px no-repeat,
    linear-gradient(currentColor, currentColor) center 100%/18px 2px no-repeat;
  opacity: .92;
  border-radius: 2px;
  pointer-events: none;
}
/* Se il tema è chiaro/scuro, usa il colore del testo del bottone */
#mlgMenuBtn{ color:#fff; }
</style>
<style id="mlg-search-fallback-label">
/* Mostra 'Vai' solo se l'icona non rende (font non caricato) */
header.mlg-banner .mlg-search button .fallback-label{ 
  display:none; 
  font-weight:800; 
  font-size:12px; 
  line-height:1; 
}
/* Greedy fallback: se l'icona non ha dimensioni (non caricata), mostra la label */
header.mlg-banner .mlg-search button i.fa-solid:empty + .fallback-label{ 
  display:inline-block; 
}
</style>
<style id="mlg-hamburger-bars-css">
/* Tre linee sempre visibili nel pulsante menu */
#mlgMenuBtn{ position: relative; }
#mlgMenuBtn .mlg-hb{ display:inline-block; width:18px; height:12px; position:relative; }
#mlgMenuBtn .mlg-hb b{
  position:absolute; left:0; right:0; height:2px; background:currentColor; border-radius:2px;
}
#mlgMenuBtn .mlg-hb b:nth-child(1){ top:0; }
#mlgMenuBtn .mlg-hb b:nth-child(2){ top:50%; transform:translateY(-50%); }
#mlgMenuBtn .mlg-hb b:nth-child(3){ bottom:0; }
</style>
<style id="mlg-auto-dismiss-css">
.mlg-autodismiss{
  will-change: height, opacity, margin;
  transition: opacity .5s ease, height .5s ease, margin .5s ease, padding .5s ease;
  overflow: hidden;
}
.mlg-autodismiss.is-hiding{
  opacity: 0;
  height: 0 !important;
  margin-top: 0 !important;
  margin-bottom: 0 !important;
  padding-top: 0 !important;
  padding-bottom: 0 !important;
}
</style>
<style id="mlg-bottombar-tight-mobile">
/* Default: shave extra space just in case */
#mapArea{ margin-bottom: 12px !important; }
#bottomBar{ margin-top: 0 !important; }
/* Mobile-specific even tighter spacing */
@media (max-width: 860px){
  #mapArea{ margin-bottom: 8px !important; }
  #bottomBar{ margin-top: 0 !important; }
}
</style>
<style id="mlg-mapdate-mobile-right">
@media (max-width: 860px){
  .map-date{
    left: auto !important;
    right: 10px !important;
    top: 10px !important;
    /* keep it discrete */
    font-size: .9rem !important;
    padding: 5px 9px !important;
  }
}
</style>
<style id="mlg-mapdate-mobile-right-force">
@media (max-width: 860px){
  /* High-specificity fallbacks */
  #mapArea .map-date,
  .map-wrap .map-date,
  .map-date.map-date{
    position:absolute !important;
    inset: 10px 10px auto auto !important; /* top right */
    right: 10px !important;
    left: initial !important;
    transform: none !important;
  }
  /* Extra: if container has padding, stay within */
  #mapArea, .map-wrap { position: relative !important; }
}
</style>
<style id="banner-mobile-one-line-fit-strong-2025-09-11">
@media (max-width: 540px){
  .mlg-banner{
    max-width: 100vw !important;
    padding-left: max(8px, env(safe-area-inset-left)) !important;
    padding-right: max(8px, env(safe-area-inset-right)) !important;
  }
  .mlg-banner .mlg-title{
    width: 100% !important;
    text-align: center !important;
    display: block !important;
    margin: 4px 0 !important;
  }
  .mlg-banner .mlg-nav{
    display: flex !important;
    flex-wrap: nowrap !important;        /* never wrap */
    white-space: nowrap !important;
    gap: 4px !important;
    align-items: center !important;
    justify-content: center !important;   /* CENTER the row */
    text-align: center !important;
    overflow: hidden !important;          /* no horizontal scroll */
    width: 100% !important;
    max-width: 100% !important;
    box-sizing: border-box !important;
    padding-left: 0 !important;
    padding-right: 0 !important;
    margin: 0 auto !important;
  }
  .mlg-banner .mlg-pill{
    padding: 4px 8px !important;          /* slimmer */
    font-size: 12px !important;
    line-height: 1.1 !important;
    border-width: 1px !important;
  }
}
</style>
<style id="mlg-compact-topbar-2025-09-29">
  /* Make the header thin */
  :root{ --mlg-header-h-base: 56px; }

  header.mlg-banner{ height: calc(var(--mlg-header-h-base) + env(safe-area-inset-top)) !important; }
  header.mlg-banner .mlg-inner{
    display: grid !important;
    grid-template-columns: auto auto 1fr !important; /* [menu][MLG][search] */
    align-items: center !important;
    gap: 8px !important;
    height: 100% !important;
    padding-top: calc(env(safe-area-inset-top) + 6px) !important;
    padding-bottom: 6px !important;
    flex-wrap: nowrap !important;
  }

  /* Hide the old pills completely (we move them into the dropdown) */
  header.mlg-banner .mlg-nav{ display:none !important; }

  /* Title becomes compact "MLG" brand */
  header.mlg-banner .mlg-title{
    margin: 0 !important;
    padding: 0 !important;
    width: auto !important;
    white-space: nowrap !important;
    font-family: 'Baloo 2', cursive !important;
    font-size: clamp(18px, 5vw, 22px) !important;
    font-weight: 800 !important;
    line-height: 1 !important;
    letter-spacing: .2px !important;
    color: #fff !important;
    text-shadow: 0 2px 6px rgba(0,0,0,.45), 0 0 1px rgba(255,255,255,.18) !important;
  }
  header.mlg-banner .mlg-title .mlg-dot{ display:none !important; } /* remove decorative dot */

  /* Search bar fills the remaining space and has the icon inside */
  header.mlg-banner .mlg-search{ position: relative !important; width: 100% !important; min-width: 0 !important; }
  header.mlg-banner .mlg-search input{
    width: 100% !important;
    min-width: 0 !important;
    padding: .56rem 2.25rem .56rem .9rem !important; /* room for the icon */
    border-radius: 999px !important;
    background: #ffffff24 !important;
    border: 1px solid #ffffff35 !important;
    color: #fff !important;
    outline: none !important;
    backdrop-filter: blur(6px) !important;
  }
  header.mlg-banner .mlg-search button{
    position: absolute !important;
    top: 50% !important;
    right: 4px !important;
    transform: translateY(-50%) !important;
    height: 34px !important;
    width: 34px !important;
    display: inline-flex !important; align-items:center !important; justify-content:center !important;
    border: none !important;
    border-radius: 999px !important;
    padding: 0 !important;
    background: linear-gradient(135deg,#ffd54a,#ffb300) !important;
    color: #002 !important;
    box-shadow: 0 6px 12px rgba(0,0,0,.28) !important;
    cursor: pointer !important;
  }

  /* Menu (hamburger) button */
  #mlgMenuBtn{
    -webkit-tap-highlight-color: transparent;
    appearance: none;
    border: 1px solid #ffffff33;
    background: #ffffff20;
    color: #fff;
    border-radius: 12px;
    padding: 8px 10px;
    font-weight: 800;
    display: inline-flex; align-items: center; justify-content: center;
    box-shadow: 0 6px 14px rgba(0,0,0,.28);
  }
  #mlgMenuBtn:active{ transform: translateY(1px); }
  #mlgMenuBtn .fa-solid{ font-size: 1rem; }

  /* Dropdown panel */
  #mlgMenuPanel{
    position: fixed;
    top: calc(env(safe-area-inset-top) + var(--mlg-header-h-base) + 6px);
    left: max(8px, env(safe-area-inset-left));
    width: min(92vw, 360px);
    z-index: 4000;
    display: none;
    background: linear-gradient(180deg, var(--mlg-blue-2,#163a93), #102b78);
    border: 1px solid #ffffff2b;
    border-radius: 14px;
    box-shadow: 0 14px 40px rgba(0,0,0,.45);
    padding: 8px;
    overflow: hidden;
  }
  #mlgMenuPanel.open{ display: block; }

  #mlgMenuPanel a{
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 10px;
    padding: 12px 14px;
    border-radius: 12px;
    color: #fff;
    text-decoration: none;
    font-weight: 800;
    background: #ffffff18;
    border: 1px solid #ffffff24;
    margin: 6px 4px;
  }
  #mlgMenuPanel a:active{ transform: translateY(1px); }
  #mlgMenuPanel a:hover{ background: #ffffff2a; }

  /* Extreme narrow screens: slightly reduce header height */
  @media (max-width: 360px){
    :root{ --mlg-header-h-base: 52px; }
    #mlgMenuPanel{ top: calc(env(safe-area-inset-top) + var(--mlg-header-h-base) + 6px); }
  }
</style>
<style id="mlg-spacer-zero-gap">#mlg-spacer{height:0!important;}</style>
<style id="mlg-spacer-zero-gap-v2">#mlg-spacer{height:0!important;display:none!important}</style>

<style id="mlg-vai-rightmost">
.mlg-banner .mlg-row{ display:flex; align-items:center; }
.mlg-banner .mlg-title{ flex: 0 0 auto; }
.mlg-banner .mlg-search{ flex: 1 1 auto; min-width: 160px; }
.mlg-banner .mlg-search input{ width:100%; }
.mlg-banner .mlg-search button{ margin-left:auto; } /* push VAI to the right edge */
</style>


<style id="mlg-vai-rightmost-v2">
.mlg-banner .mlg-search{ display:flex; align-items:center; gap:.5rem; flex:1 1 auto; }
.mlg-banner .mlg-search input[type="text"],
.mlg-banner .mlg-search input[type="search"]{ flex:1 1 auto; min-width:0; }
.mlg-banner .mlg-search button{ margin-left:auto; flex:0 0 auto; }
</style>

</head>
<body>
<header class="mlg-banner mlg-sticky" role="banner">
  <div class="mlg-inner">
    

    <!-- Search inside the banner -->
    <div class="mlg-title" aria-label="Meteo Lo Gullo">MLG</div><form id="searchForm" class="mlg-search" role="search" aria-label="Cerca località" style="position: relative; order: 3;">
      <input id="cityInput" autocomplete="off" inputmode="search" placeholder="Inserisci qui la tua località…" aria-label="Scrivi il comune o usa la posizione">
      <button type="submit" aria-label="Cerca">
        <i class="fa-solid fa-search" aria-hidden="true"></i><span class="fallback-label" aria-hidden="true">Vai</span>
      </button>
    
<!-- === PATCH 2025-09-30 — Redirect on search bar touch (open meteologullo.com in new tab) === -->
<script id="mlg-search-touch-redirect-2025-09-30">
(function(){
  var URL = "https://www.meteologullo.com/";
  function byId(id){ return document.getElementById(id); }
  function bind(){
    try{
      var inp = byId("cityInput") || document.querySelector("header.mlg-banner .mlg-search input");
      if(!inp || inp.__mlgRedirectBound) return;
      var opened = false;
      function go(ev){
        try{
          try{ showToast(wrap || document.querySelector('header.mlg-banner .mlg-search') || document.body); }catch(_ ){}
          var newTab = null;
          try{ newTab = window.open('', '_blank', 'noopener'); }catch(_e){ newTab = null; }
          setTimeout(function(){ try{ if(newTab) newTab.location.href = URL; else window.open(URL, '_blank', 'noopener'); }catch(_e){} }, 350);
          opened = true;
          if(ev && ev.preventDefault) ev.preventDefault();
          // Evita che la tastiera/apertura focus sovrascriva l'esperienza
          try{ inp.blur(); }catch(_){}
        }catch(_){}
      }
      // "prima di selezionarla": intercetta i tocchi/click PRIMA del focus
      inp.addEventListener("pointerdown", function(ev){ if(!opened){ go(ev); } }, { once:true });
      inp.addEventListener("touchstart", function(ev){ if(!opened){ go(ev); } }, { once:true, passive:false });
      // Fallback: se qualcosa porta comunque il focus, apri e sfoca
      inp.addEventListener("focus", function(ev){ if(!opened){ go(ev); } }, { once:true });
      inp.__mlgRedirectBound = true;
    }catch(_){}
  }
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", bind, { once:true });
  }else{
    bind();
  }
})();
</script>
<script id="mlg-search-overlay-link-2025-09-30">
(function(){
  try{
    var inp = document.getElementById("cityInput") || document.querySelector("header.mlg-banner .mlg-search input");
    if(!inp || inp.__mlgOverlayBound) return;
    var wrap = inp.parentElement;
    if(wrap){ 
      var style = getComputedStyle(wrap);
      if(style.position === 'static'){ wrap.style.position = 'relative'; }
      var a = document.createElement('a'); a.id = 'mlgSearchOverlayLink';
      a.href = 'https://www.meteologullo.com/';
      a.target = '_blank';
      a.rel = 'noopener';
      a.setAttribute('aria-label','Apri meteologullo.com in nuova scheda');
      a.style.cssText = 'position:absolute;inset:0;border-radius:999px;z-index:5;';
      wrap.appendChild(a);
    }
    inp.__mlgOverlayBound = true;
  }catch(_){}
})();
</script><a id="mlgSearchOverlayLink" href="https://www.meteologullo.com/" target="_blank" rel="noopener" aria-label="Apri meteologullo.com in nuova scheda" style="position: absolute; inset: 0px; border-radius: 999px; z-index: 5;"></a>
<style id="mlg-search-toast-css-2025-09-30">
#mlgToast{position:absolute;left:0;right:0;top:50%;transform:translateY(-50%);margin:auto;width:min(620px,96%);max-width:96%;background:rgba(0,0,0,.85);color:#fff;border:1px solid rgba(255,255,255,.15);border-radius:14px;padding:12px 14px;box-shadow:0 6px 32px rgba(0,0,0,.5);font-size:14px;line-height:1.35;z-index:9}
#mlgToast strong{display:block;font-size:15px;margin-bottom:4px}
@media (max-width:560px){ #mlgToast{font-size:13px; padding:10px 12px} #mlgToast strong{font-size:14px} }
</style>
<script id="mlg-search-toast-js-2025-09-30">
(function(){
  function showToast(wrap){
    try{
      if(!wrap) return;
      // remove existing
      var old = wrap.querySelector('#mlgToast'); if(old) old.remove();
      var box = document.createElement('div');
      box.id = 'mlgToast';
      box.setAttribute('role','status');
      box.innerHTML = '<strong>Un attimo…</strong> ti stiamo reindirizzando alla <em>sezione Previsioni</em>, dove potrai scrivere la tua località e cercare la previsione. Ci scusiamo per la brevissima attesa.';
      // Ensure wrap is positioned
      var cs = getComputedStyle(wrap); if(cs.position === 'static'){ wrap.style.position = 'relative'; }
      wrap.appendChild(box);
      setTimeout(function(){ try{ box.remove(); }catch(_){} }, 1800);
    }catch(_){}
  }
  // bind on overlay anchor click to show message (we don't block navigation)
  try{
    var wrap = document.querySelector('header.mlg-banner .mlg-search');
    if(wrap){
      var overlay = wrap.querySelector('a[href^="https://www.meteologullo.com"]');
      if(overlay && !overlay.__mlgToastBound){
        overlay.addEventListener('pointerdown', function(){ showToast(wrap); }, {passive:true});
        overlay.addEventListener('click', function(){ showToast(wrap); }, {passive:true});
    overlay.__mlgToastBound = true;
  }
}catch(_){}

    // Fallback: if overlay not found, bind on the actual input
    try{
      var inp = document.querySelector("header.mlg-banner .mlg-search input");
      if(inp && !inp.__mlgToastFallback){
        inp.addEventListener('pointerdown', function(){
          var wrap2 = document.querySelector('header.mlg-banner .mlg-search');
          showToast(wrap2 || document.body);
          // open after a tiny delay to let the toast render at least one frame
          (function(){
      var nt=null;try{ nt = window.open('', '_blank', 'noopener'); }catch(_e){ nt=null; }
      setTimeout(function(){ try{ if(nt) nt.location.href = 'https://www.meteologullo.com/'; else window.open('https://www.meteologullo.com/', '_blank', 'noopener'); }catch(_e){} }, 350);
    })();
    }, {passive:true});
        inp.addEventListener('keydown', function(ev){
          if(ev.key === 'Enter'){
            var wrap2 = document.querySelector('header.mlg-banner .mlg-search');
            showToast(wrap2 || document.body);
            (function(){
      var nt=null;try{ nt = window.open('', '_blank', 'noopener'); }catch(_e){ nt=null; }
      setTimeout(function(){ try{ if(nt) nt.location.href = 'https://www.meteologullo.com/'; else window.open('https://www.meteologullo.com/', '_blank', 'noopener'); }catch(_e){} }, 350);
    })();
    }
        }, {passive:true});
        inp.__mlgToastFallback = true;
      }
    }catch(_){}
    
</script>


</form>

    <!-- Hamburger toggle (mobile) --><!-- Desktop nav (kept for large screens) -->
    
  </div>

  <!-- Dropdown menu (mobile) -->
</header>
<div id="mlgMenuPanel"><a class="" href="https://www.meteologullo.com/" data-key="home" target="_blank" rel="noopener">Home</a><a class="" href="https://www.meteologullo.com/stazioni-meteorologiche-mlg" data-key="mlgmap" target="_blank" rel="noopener">MLG Map</a><a class="" href="https://www.meteologullo.com/blog" data-key="news" target="_blank" rel="noopener">News</a><a class="" href="https://www.meteologullo.com/blank" data-key="chi-siamo" target="_blank" rel="noopener">Chi Siamo</a><a class="" href="https://www.meteologullo.com/blog/categories/meteo-curiosit%C3%A0" data-key="curiosita" target="_blank" rel="noopener">Curiosità</a><a class="" href="https://www.meteologullo.com/webcam" data-key="webcam" target="_blank" rel="noopener">Webcam</a></div>

<script id="mlg-compact-topbar-js-2025-09-29">
(function(){
  const onReady = (fn)=> (document.readyState === 'loading') ? document.addEventListener('DOMContentLoaded', fn, {once:true}) : fn();

  onReady(function(){
    const header = document.querySelector('header.mlg-banner .mlg-inner');
    if(!header) return;

    const nav = header.querySelector('.mlg-nav');
    const search = header.querySelector('.mlg-search');
    const title = header.querySelector('.mlg-title');

    /* 1) Create the hamburger button */
    const btn = document.createElement('button');
    btn.id = 'mlgMenuBtn';
    btn.type = 'button';
    btn.setAttribute('aria-haspopup','menu');
    btn.setAttribute('aria-expanded','false');
    btn.setAttribute('title','Apri menu');
    btn.innerHTML = '<span class="mlg-hb" aria-hidden="true"><b></b><b></b><b></b></span>';
    header.insertBefore(btn, header.firstChild);

    /* 2) Convert title to compact brand "MLG" and place after button */
    if(title){
      title.querySelectorAll('.mlg-dot').forEach(el=>el.remove());
      title.textContent = 'MLG';
      header.insertBefore(title, search);
    }

    /* 3) Build dropdown panel using the existing links (then remove the old row) */
    const panel = document.createElement('div');
    panel.id = 'mlgMenuPanel';
    let links = [];
    if(nav){
      links = Array.from(nav.querySelectorAll('a')).map(a=>{
        const c = a.cloneNode(true);
        c.className = ''; // clean pill style; we give new style in CSS
        return c;
      });
      nav.remove(); // sparire
    }else{
      // fallback in case there is no .mlg-nav already in DOM
      links = [
        {t:'Home',h:'https://www.meteologullo.com/'},
        {t:'MLG Map',h:'https://www.meteologullo.com/stazioni-meteorologiche-mlg'},
        {t:'News',h:'https://www.meteologullo.com/blog'},
        {t:'Chi Siamo',h:'https://www.meteologullo.com/blank'},
        {t:'Curiosità',h:'https://www.meteologullo.com/blog/categories/meteo-curiosit%C3%A0'},
        {t:'Webcam',h:'https://www.meteologullo.com/webcam'}
      ].map(o=>{ const a = document.createElement('a'); a.textContent = o.t; a.href = o.h; a.target = '_blank'; a.rel='noopener'; return a; });
    }
    links.forEach(a=>{ if(a.tagName){ a.target='_blank'; a.rel='noopener'; } panel.appendChild(a); });
    document.body.appendChild(panel);

    /* 4) Toggle logic */
    function closeMenu(){ panel.classList.remove('open'); btn.setAttribute('aria-expanded','false'); }
    function openMenu(){ panel.classList.add('open'); btn.setAttribute('aria-expanded','true'); }
    btn.addEventListener('click', (ev)=>{
      try{
        ev.preventDefault();
        // Build cross-device menu page that opens in a NEW TAB (no popup)
        const items = (links || []).map(it => {
          const href = (it.tagName ? it.getAttribute('href') : it.h) || '#';
          const label = (it.tagName ? it.textContent : it.t) || href;
          return `<a class="item" href="${href}" target="_blank" rel="noopener">${label}</a>`;
        }).join('');
        const html = `<!DOCTYPE html><html lang="it"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Menu MLG</title>
        <style>:root{--bg:#0c1118;--fg:#e6edf3;--card:#121826}body{margin:0;background:var(--bg);color:var(--fg);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif}.wrap{max-width:820px;margin:18px auto;padding:16px}h1{font-size:28px;margin:0 0 10px 0}.grid{display:grid;gap:12px}a.item{display:block;padding:18px 20px;border-radius:16px;background:var(--card);text-decoration:none;border:1px solid rgba(255,255,255,.08)}</style>
        <style id="mlg-spacer-zero-gap">#mlg-spacer{height:0!important;}</style>
<style id="mlg-spacer-zero-gap-v2">#mlg-spacer{height:0!important;display:none!important}</style>

<style id="mlg-vai-rightmost">
.mlg-banner .mlg-row{ display:flex; align-items:center; }
.mlg-banner .mlg-title{ flex: 0 0 auto; }
.mlg-banner .mlg-search{ flex: 1 1 auto; min-width: 160px; }
.mlg-banner .mlg-search input{ width:100%; }
.mlg-banner .mlg-search button{ margin-left:auto; } /* push VAI to the right edge */
</style>


<style id="mlg-vai-rightmost-v2">
.mlg-banner .mlg-search{ display:flex; align-items:center; gap:.5rem; flex:1 1 auto; }
.mlg-banner .mlg-search input[type="text"],
.mlg-banner .mlg-search input[type="search"]{ flex:1 1 auto; min-width:0; }
.mlg-banner .mlg-search button{ margin-left:auto; flex:0 0 auto; }
</style>

</head><body><div class="wrap"><h1>Menu MLG</h1><div class="grid">
        ${items}
        </div></div>
<!-- === MLG: FIX MeteoHub popup enrichment (humidity, wind, gusts, rain) === -->
<script>
(function(){
  if (!window.L) return;

  function pad(n){return String(n).padStart(2,'0');}
  function fmtUTC(d){
    return d.getUTCFullYear()+"-"+pad(d.getUTCMonth()+1)+"-"+pad(d.getUTCDate())+" "+pad(d.getUTCHours())+":"+pad(d.getUTCMinutes());
  }
  function toNum(v){const n=Number(v); return isFinite(n)?n:null;}
  function getPool(st){return st?.prod || st?.products || st?.var || st?.variables || st;}
  function getProd(st, code){
    const P=getPool(st); if(!P) return null;
    if (Array.isArray(P)) return P.find(p => String(p.var||p.code||"").toUpperCase()===String(code).toUpperCase()) || null;
    if (typeof P==="object") return P[code] || P[String(code)] || null;
    return null;
  }
  function series(prod){
    const raw = prod?.val ?? prod?.values ?? prod?.series ?? prod;
    const out=[];
    if (Array.isArray(raw)){
      for (const r of raw){
        if (r && typeof r==="object" && "val" in r){
          out.push({val: Number(r.val), time: r.ref || r.reftime || r.time || r.ts});
        }
      }
    }
    return out.filter(x => isFinite(x.val));
  }
  function todayOnly(s){
    const d=new Date(); const y=d.getUTCFullYear(), m=d.getUTCMonth()+1, dd=d.getUTCDate();
    const k = y+"-"+String(m).padStart(2,'0')+"-"+String(dd).padStart(2,'0');
    return (s||[]).filter(p=>p.time && String(p.time).slice(0,10)===k).sort((a,b)=> new Date(a.time)-new Date(b.time));
  }
  function rainTodayCalc(seriesAll){
    const s=todayOnly(seriesAll);
    if(!s.length) return 0;
    // cumulata non decrescente -> differenza
    let nonDec=true;
    for(let i=1;i<s.length;i++){ if (s[i].val < s[i-1].val - 1e-6){ nonDec=false; break; } }
    if (nonDec) return Math.max(0, s[s.length-1].val - s[0].val);
    // incrementale -> somma
    let sum=0; for(const p of s){ if (p.val >= 0) sum+=p.val; }
    return sum;
  }
  function lastVal(prod){
    const s=series(prod); if (s.length) return s[s.length-1].val;
    const v=Number(prod?.val); return isFinite(v)? v : null;
  }
  function toKmH(value, unit){
    if (value==null || isNaN(value)) return null;
    const u=(unit||"").toUpperCase();
    if (u.includes("M/S")) return value*3.6;
    if (u.includes("KM/H")||u.includes("KMH")) return value;
    if (u.includes("KT") || u.includes("KNOT")) return value*1.852;
    return value<60 ? value*3.6 : value; // fallback prudente
  }

  function buildQuery(){
    const now=new Date(), from=new Date(now.getTime()-36*3600*1000);
    return (
      "reftime: >="+fmtUTC(from)+",<="+fmtUTC(now)+";"+
      "timerange:254,0,0 or 1,0,3600;"+
      "level:103,2000,0,0 or 1,0,0,0 or 103,10000,0,0;"+
      "license:CCBY_COMPLIANT;"+
      "product:B12101 or B13003 or B11002 or B11001 or B11041 or B11042 or B13011"
    );
  }

  async function fetchAround(lat, lon){
    const base = new URL("https://meteohub.agenziaitaliameteo.it/api/observations");
    base.searchParams.set("q", buildQuery());
    base.searchParams.set("lat", lat);
    base.searchParams.set("lon", lon);
    base.searchParams.set("networks", "dpcn-calabria");
    base.searchParams.set("stationDetails","true");
    base.searchParams.set("allStationProducts","false");
    const res = await fetch(base.toString(), {cache:"no-store"});
    if (!res.ok) throw new Error("MeteoHub "+res.status);
    const js=await res.json();
    const list = Array.isArray(js)? js : (js.stations || js.data || js.results || []);
    if (!list.length) return null;
    // prendi la stazione più vicina
    let best=null,bd=1e9;
    for (const st of list){
      const la=toNum(st.lat ?? st.latitude), lo=toNum(st.lon ?? st.longitude);
      if (!isFinite(la)||!isFinite(lo)) continue;
      const d2=(la-lat)*(la-lat)+(lo-lon)*(lo-lon);
      if (d2<bd){ bd=d2; best=st; }
    }
    if (!best) return null;
    const T  = getProd(best,"B12101");
    const RH = getProd(best,"B13003");
    const WS = getProd(best,"B11002");
    const WG = getProd(best,"B11041") || getProd(best,"B11042");
    const RR = getProd(best,"B13011");

    const rh = lastVal(RH);
    const ws = toKmH(lastVal(WS), WS?.unit);
    const wg = toKmH(lastVal(WG), WG?.unit);
    const rain = rainTodayCalc(series(RR));

    return {rh, ws, wg, rain};
  }

  // Hook sul popup: aggiorna i campi con i dati MeteoHub in tempo reale
  var mapObj = window.map || window.mymap || window.MAP || window.leafmap || window.__leaflet_map;
  if (!mapObj && window.L && L?.map){
    // prova a recuperare il primo map creato
    for (const k in window){ if (window[k] && window[k] instanceof L.Map){ mapObj = window[k]; break; } }
  }
  if (!mapObj) return;

  mapObj.on('popupopen', async function(e){
    try{
      const marker = e.popup._source;
      if (!marker || !marker.getLatLng) return;
      const latlng = marker.getLatLng();
      const data = await fetchAround(latlng.lat, latlng.lng);
      if (!data) return;
      const div = e.popup.getElement()?.querySelector('.leaflet-popup-content');
      if (!div) return;
      let html = div.innerHTML;
      function rep(label, value, suffix){
        const re = new RegExp("("+label+"\\s*:\\s*)([^<]*)");
        html = html.replace(re, function(_,p1){ return p1 + (value!=null && !isNaN(value) ? (suffix==="%"? value.toFixed(0)+suffix : value.toFixed(suffix==="mm"?1:0)+" "+(suffix||"")).trim() : "--"); });
      }
      rep("Umidità", data.rh, "%");
      // Vento/Raffica riga combinata
      html = html.replace(/(Vento:\s*)([^<]*)(\s*\/\s*Raffica:\s*)([^<]*)/, function(){
        const v = (data.ws!=null && !isNaN(data.ws)) ? data.ws.toFixed(0)+" km/h" : "--";
        const g = (data.wg!=null && !isNaN(data.wg)) ? data.wg.toFixed(0)+" km/h" : "--";
        return "Vento: "+v+" / Raffica: "+g;
      });
      rep("Pioggia", data.rain, "mm");
      div.innerHTML = html;
    }catch(err){
      console.warn("Popup MeteoHub enrich error:", err);
    }
  });
})();
</scr"+"ipt>


<script>
// === Estensione: aggiorna anche il pannello testuale in basso quando si apre un popup ===
(function(){
  function replaceInBlock(el, data){
    if (!el) return;
    let html = el.innerHTML;
    function rep(label, value, suffix){
      const re = new RegExp("("+label+"\\s*:\\s*)([^<]*)", "i");
      html = html.replace(re, function(_,p1){ return p1 + (value!=null && !isNaN(value) ? (suffix==="%"? value.toFixed(0)+suffix : value.toFixed(suffix==="mm"?1:0)+" "+(suffix||"")).trim() : "--"); });
    }
    // riga vento/raffica
    html = html.replace(/(Vento:\s*)([^<]*)(\s*\/\s*Raffica:\s*)([^<]*)/i, function(){
      const v = (data.ws!=null && !isNaN(data.ws)) ? data.ws.toFixed(0)+" km/h" : "--";
      const g = (data.wg!=null && !isNaN(data.wg)) ? data.wg.toFixed(0)+" km/h" : "--";
      return "Vento: "+v+" / Raffica: "+g;
    });
    rep("Umidità", data.rh, "%");
    rep("Pioggia", data.rain, "mm");
    el.innerHTML = html;
  }

  function updatePanelForName(name, data){
    if (!name || !data) return;
    const root = document.body;
    // Cerca blocchi che contengono il nome della stazione
    const nodes = Array.from(root.querySelectorAll("*"))
      .filter(n => n.children.length===0 && n.textContent && n.textContent.indexOf(name) !== -1)
      .map(n => n.parentElement);
    const uniq = new Set();
    for (const el of nodes){
      if (!el) continue;
      if (uniq.has(el)) continue;
      uniq.add(el);
      replaceInBlock(el, data);
    }
  }

  // Hook sullo stesso evento del popup (se definito dallo script precedente)
  var mapObj = window.map || window.mymap || window.MAP || window.leafmap || window.__leaflet_map;
  if (!mapObj && window.L && L?.map){
    for (const k in window){ if (window[k] && window[k] instanceof L.Map){ mapObj = window[k]; break; } }
  }
  if (!mapObj) return;

  mapObj.on('popupopen', function(e){
    const popupEl = e.popup.getElement()?.querySelector('.leaflet-popup-content');
    if (!popupEl) return;
    const title = popupEl.querySelector('div, b, strong, h1, h2, h3, h4');
    const name = (title ? title.textContent : popupEl.textContent).split("\\n")[0].trim();
    // L'altro script ha già fatto la fetch e aggiornato il popup; intercettiamo i valori già presenti
    // se disponibili. In caso contrario, lasciamo al primo script fare la fetch e poi rileggiamo dopo 800ms.
    setTimeout(function(){
      const text = popupEl.textContent;
      const rx = {
        rh: /Umidità:\s*([0-9]+)%/i,
        ws: /Vento:\s*([0-9]+)\s*km\/h/i,
        wg: /Raffica:\s*([0-9]+)\s*km\/h/i,
        rain: /Pioggia:\s*([0-9]+(?:\.[0-9]+)?)\s*mm/i
      };
      const data = {
        rh: rx.rh.test(text)? Number(text.match(rx.rh)[1]) : null,
        ws: rx.ws.test(text)? Number(text.match(rx.ws)[1]) : null,
        wg: rx.wg.test(text)? Number(text.match(rx.wg)[1]) : null,
        rain: rx.rain.test(text)? Number(text.match(rx.rain)[1]) : null
      };
      updatePanelForName(name, data);
    }, 900);
  });
})();
</scr"+"ipt>

</body></html>`;
        const blob = new Blob([html],{type:'text/html'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a'); a.href = url; a.target = '_blank'; a.rel='noopener'; a.style.display='none'; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 3000);
      }catch(_){}
    });
document.addEventListener('click', (e)=>{
      if(!panel.classList.contains('open')) return;
      if(e.target === btn || btn.contains(e.target)) return;
      if(panel.contains(e.target)) return;
      closeMenu();
    }, {passive:true});
    document.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape') closeMenu();
    });

    /* 5) Make sure search stays last and flexes */
    if(search){
      search.style.order = '3';
    }
  });
})();
</script>

<div id="mlg-spacer"></div>
<script id="mlg-banner-bright-js-2025-09-11">
// Evidenzia "Home" con bordo giallo (solo bordo).
// Trova il pill corrispondente alla Home sia per testo che per href.
(function(){
  function markHome(){
    var navs = document.querySelectorAll('.mlg-banner .mlg-nav');
    navs.forEach(function(nav){
      var anchors = nav.querySelectorAll('a, button, [role="link"]');
      anchors.forEach(function(a){
        var txt = (a.textContent || '').trim().toLowerCase();
        var isHomeText = txt === 'home' || txt === 'homepage' || txt === 'inizio';
        var href = (a.getAttribute && a.getAttribute('href')) || '';
        var isHomeHref = href === '/' || /index\.html?$/.test(href || '') || href === '' || href === '#home';
        if(isHomeText || isHomeHref){
          a.classList.add('is-active');
        }
      });
    });
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', markHome);
  }else{
    markHome();
  }
  window.addEventListener('load', markHome);
})();
</script>
<script id="banner-mobile-one-line-fit-strong-js-2025-09-11">
(function(){
  function fitNav(nav){
    if(!nav) return;
    // Build/ensure inner wrapper
    let inner = nav.querySelector(':scope > .mlg-fitwrap');
    if(!inner){
      inner = document.createElement('div');
      inner.className = 'mlg-fitwrap';
      while(nav.firstChild){ inner.appendChild(nav.firstChild); }
      nav.appendChild(inner);
    }
    const cs = getComputedStyle(nav);
    inner.style.display = 'inline-flex';
    inner.style.flexWrap = 'nowrap';
    inner.style.whiteSpace = 'nowrap';
    inner.style.alignItems = 'center';
    inner.style.columnGap = (cs.gap || '4px');
    inner.style.rowGap = '0px';
    inner.style.transformOrigin = 'center center';  // scale from center
    inner.style.willChange = 'transform';
    // center the wrapper itself
    inner.style.margin = '0 auto';

    // reset scale before measuring
    inner.style.transform = 'scale(1)';
    if(window.innerWidth > 540){
      return; // desktop/tablet
    }

    // Available width with safety margin
    const rect = nav.getBoundingClientRect();
    const padL = parseFloat(cs.paddingLeft) || 0;
    const padR = parseFloat(cs.paddingRight) || 0;
    const borderL = parseFloat(cs.borderLeftWidth) || 0;
    const borderR = parseFloat(cs.borderRightWidth) || 0;
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const safety = Math.max(4, Math.ceil(3 * dpr)); // 4-6 px
    const avail = Math.max(0, rect.width - padL - padR - borderL - borderR - safety);

    // content width needed (unscaled)
    const needed = inner.scrollWidth;
    if(avail > 0 && needed > 0){
      // cushion below exact fit to avoid edge clipping
      const s = Math.min(1, (avail / needed) * 0.985);
      const scale = (s > 0 && isFinite(s)) ? s : 1;
      inner.style.transform = 'scale(' + scale + ')';

      // ensure nav height fits scaled content
      const h = inner.getBoundingClientRect().height;
      nav.style.minHeight = Math.ceil(h) + 'px';
    }
  }

  function run(){
    document.querySelectorAll('.mlg-banner .mlg-nav').forEach(fitNav);
  }

  // Refit on layout changes
  const ro = new ResizeObserver(run);
  window.addEventListener('resize', run, {passive:true});
  window.addEventListener('orientationchange', run);
  document.addEventListener('DOMContentLoaded', function(){
    run();
    setTimeout(run, 50);
    setTimeout(run, 200);
    setTimeout(run, 600);
    if(document.fonts && document.fonts.ready){
      document.fonts.ready.then(run).catch(function(){});
    }
  });
  window.addEventListener('load', run);

  // Watch mutations within nav
  const mo = new MutationObserver(run);
  document.addEventListener('DOMContentLoaded', function(){
    document.querySelectorAll('.mlg-banner .mlg-nav').forEach(function(nav){
      try{
        ro.observe(nav);
        mo.observe(nav, {childList:true, subtree:true, characterData:true});
      }catch(e){}
    });
  });
})();
</script>
<script id="mlg-search-touch-redirect-2025-09-30">
(function(){
  var URL = "https://www.meteologullo.com/";
  function byId(id){ return document.getElementById(id); }
  function bind(){
    try{
      var inp = byId("cityInput") || document.querySelector("header.mlg-banner .mlg-search input");
      if(!inp || inp.__mlgRedirectBound) return;
      var opened = false;
      function go(ev){
        try{
          try{ showToast(wrap || document.querySelector('header.mlg-banner .mlg-search') || document.body); }catch(_ ){}
          var newTab = null;
          try{ newTab = window.open('', '_blank', 'noopener'); }catch(_e){ newTab = null; }
          setTimeout(function(){ try{ if(newTab) newTab.location.href = URL; else window.open(URL, '_blank', 'noopener'); }catch(_e){} }, 350);
          opened = true;
          if(ev && ev.preventDefault) ev.preventDefault();
          // Evita che la tastiera/apertura focus sovrascriva l'esperienza
          try{ inp.blur(); }catch(_){}
        }catch(_){}
      }
      // "prima di selezionarla": intercetta i tocchi/click PRIMA del focus
      inp.addEventListener("pointerdown", function(ev){ if(!opened){ go(ev); } }, { once:true });
      inp.addEventListener("touchstart", function(ev){ if(!opened){ go(ev); } }, { once:true, passive:false });
      // Fallback: se qualcosa porta comunque il focus, apri e sfoca
      inp.addEventListener("focus", function(ev){ if(!opened){ go(ev); } }, { once:true });
      inp.__mlgRedirectBound = true;
    }catch(_){}
  }
  if(document.readyState === "loading"){
    document.addEventListener("DOMContentLoaded", bind, { once:true });
  }else{
    bind();
  }
})();
</script>
<script id="mlg-search-overlay-link-2025-09-30">
(function(){
  try{
    var inp = document.getElementById("cityInput") || document.querySelector("header.mlg-banner .mlg-search input");
    if(!inp || inp.__mlgOverlayBound) return;
    var wrap = inp.parentElement;
    if(wrap){ 
      var style = getComputedStyle(wrap);
      if(style.position === 'static'){ wrap.style.position = 'relative'; }
      var a = document.createElement('a'); a.id = 'mlgSearchOverlayLink';
      a.href = 'https://www.meteologullo.com/';
      a.target = '_blank';
      a.rel = 'noopener';
      a.setAttribute('aria-label','Apri meteologullo.com in nuova scheda');
      a.style.cssText = 'position:absolute;inset:0;border-radius:999px;z-index:5;';
      wrap.appendChild(a);
    }
    inp.__mlgOverlayBound = true;
  }catch(_){}
})();
</script>


<div id="map-loader-banner">
  <div class="spinner"></div>
  <div>Caricamento mappa...</div>
</div>

<div id="radar-controls" style="position: fixed; top: 120px; right: 10px; z-index: 2147483647; background: white; border-radius: 8px; padding: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.4); display: none; font-family: sans-serif;">
<div style="display: flex; align-items: center; gap: 6px; margin-bottom: 4px;">
<button onclick="playRadar()" title="Avvia animazione">▶️</button>
<button onclick="stopRadar()" title="Ferma animazione">⏹️</button>
<input id="radarSlider" max="0" min="0" oninput="sliderChangeRadar(this.value)" step="1" style="width: 140px;" type="range" value="0"/>
</div>
<div id="radar-time-label" style="font-size: 13px; color: #111; text-align: center;"></div>
</div>
<div id="radar-time-label" style="font-size: 13px; color: #111; text-align: center;"></div>
<!-- Sidebar Meteo -->
<div id="map-indicator" style="position:fixed;top:70px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.6);color:#fff;padding:4px 10px;border-radius:6px;font-size:14px;z-index:1003;pointer-events:none;opacity:0;transition:opacity 0.3s;"></div>
<div id="sidebar">
<button class="sidebar-btn" id="btnScreenshot" onclick="generaScreenshot()" title="Cattura e condividi">📸</button>
<button class="sidebar-btn" onclick="visualizzaAttuali()" style="background-color: #cccccc; color: black;" title="Temp attuale">T°C</button>
<button class="sidebar-btn" onclick="visualizzaEstremi('max')" style="background-color: #ff4d4d; color: white;" title="Temp max">MAX</button>
<button class="sidebar-btn" onclick="visualizzaEstremi('min')" style="background-color: #3399ff; color: white;" title="Temp min">MIN</button>
<button class="sidebar-btn" onclick="visualizzaUmidita()" style="background-color: #66ccff; color: white;" title="Umidità">UR%</button>
<button class="sidebar-btn" onclick="visualizzaPercepita()" style="background-color: #ff66aa; color: white;" title="Temp. percepita">PERC</button>
<button class="sidebar-btn" onclick="visualizzaRaffiche()" style="background-color: #ff9933; color: white;" title="Raffiche">RAF</button>
<button class="sidebar-btn" onclick="visualizzaPioggia()" style="background-color: #3399ff; color: white;" title="Pioggia">MM</button>
<button class="sidebar-btn" onclick="filtraSoloMLG()" style="background-color: #222; color: white;" title="Solo MLG">MLG</button>
<button class="sidebar-btn" onclick="toggleRadar()" style="background-color: #444; color: white;" title="Radar/Satellite">RAD</button>
<button class="sidebar-btn" onclick="location.reload();" style="background-color:#009688;color:white;" title="Ricarica pagina">REF</button>
<button class="sidebar-btn" id="btnPlot" onclick="togglePlot()" style="background:#8b00ff;color:#fff" title="Interpolazione">PLOT</button></div>
<!-- Striscia con la scritta Meteo Lo Gullo -->
<div id="radar-controls-container">
<div id="radar-time-label" style="margin-top: 4px; font-size: 12px; color: #333; text-align: center;"></div>
</div>
<div id="map" class="loading" style="">
</div>
<button onclick="playRadar()" style="margin-right: 5px;">▶️</button>
<button onclick="stopRadar()" style="margin-right: 5px;">⏹️</button>
<input id="radarSlider" max="0" min="0" oninput="sliderChangeRadar(this.value)" step="1" type="range" value="0"/>
<div id="mlg-label" style="
  position: fixed;
  top: 65px;
  right: 10px;
  background-color: #007bff;
  color: white;
  padding: 6px 12px;
  border-radius: 8px;
  font-weight: bold;
  z-index: 1002;
  display: none;
  box-shadow: 0 2px 6px rgba(0,0,0,0.3);
  font-size: 14px;
">
  FILTRO MLG ATTIVO
</div>
<section id="anteprima-dati-testuali" style="margin: 0; padding: 20px 16px; width: 100%; background: white; z-index: 9999; box-shadow: 0 -2px 8px rgba(0,0,0,0.2); border-radius: 20px 20px 0 0;">
<div style="text-align: center; font-weight: bold; font-size: 16px; color: #003366; margin-bottom: 14px;">
    Scorri per i dati testuali ↓
  </div>
<div style="background: #f0f8ff; padding: 12px; border-radius: 12px; margin-bottom: 12px;">
<label style="display: flex; align-items: center; gap: 10px; font-size: 15px;">
<input id="riepilogo-dettagliato" onchange="aggiornaTabella()" type="checkbox"/>
      Visualizza riepilogo meteo testuale
    </label>
</div>
<div style="background: #f0f8ff; padding: 12px; border-radius: 12px; margin-bottom: 18px;">
<label style="display: flex; align-items: center; gap: 10px; font-size: 15px;">
<input id="toggle-estremi-lista" onchange="toggleEstremiLista()" type="checkbox"/>
      Mostra estremi giornalieri
    </label>
</div>
<div class="filtro-riga-combinata">
<label for="filtro-provincia">Filtra per provincia:</label>
<select id="filtro-provincia" onchange="aggiornaTabella()">
<option value="">Tutte</option>
<option value="CS">Cosenza</option>
<option value="CZ">Catanzaro</option>
<option value="KR">Crotone</option>
<option value="VV">Vibo Valentia</option>
<option value="RC">Reggio Calabria</option>
</select>
<label for="filtro-ordinamento">Ordina per:</label>
<select id="filtro-ordinamento" onchange="aggiornaTabella()">
<option value="caldo">Stazione più calda (live)</option>
<option value="freddo">Stazione più fredda (live)</option>
<option value="raffica">Raffiche</option>
<option value="pioggia">Pioggia</option>
<option value="tmax">T. max più alta</option>
<option value="tmin">T. min più bassa</option>
</select>
<label class="mlg-label-small">
<input id="filtro-mlg" onchange="aggiornaTabella()" type="checkbox"/>
    Mostra solo stazioni MLG
  </label>
</div>
</section>
<div style="height: 260px;"></div>
<div id="tabella"></div>
<div id="popup-grafico">
<button class="close-btn" onclick="chiudiGrafico()">Chiudi</button>
<iframe id="grafico-frame" src=""></iframe>
</div>
<script src="https://unpkg.com/leaflet/dist/leaflet.js">













function articola(area) {
  if (!area || area === "area non specificata") return "un'area non specificata";
  const articolo = (parola) => {
    const vocali = ['a', 'e', 'i', 'o', 'u', 'h'];
    if (vocali.includes(parola[0].toLowerCase())) return "l'" + parola;
    if (parola.toLowerCase().startsWith("sila") || parola.toLowerCase().startsWith("valle") || parola.toLowerCase().startsWith("costa") || parola.toLowerCase().startsWith("piana") || parola.toLowerCase().startsWith("presila")) return "la " + parola;
    if (parola.toLowerCase().startsWith("alto") || parola.toLowerCase().startsWith("basso") || parola.toLowerCase().startsWith("marchesato") || parola.toLowerCase().startsWith("pollino") || parola.toLowerCase().startsWith("catanzarese") || parola.toLowerCase().startsWith("vibonese") || parola.toLowerCase().startsWith("reggino") || parola.toLowerCase().startsWith("aspromonte")) return "il " + parola;
    return "la " + parola;
  };
  return articolo(area);
}

















function interpretazioneWeatherCode(code) {
  const codici = {
    0: "cielo sereno",
    1: "poco nuvoloso",
    2: "parzialmente nuvoloso",
    3: "coperto",
    45: "nebbia",
    48: "nebbia con brina",
    51: "pioviggine leggera",
    53: "pioviggine moderata",
    55: "pioviggine intensa",
    61: "pioggia leggera",
    63: "pioggia moderata",
    65: "pioggia intensa",
    66: "pioggia gelata leggera",
    67: "pioggia gelata forte",
    71: "neve leggera",
    73: "neve moderata",
    75: "neve intensa",
    80: "rovesci leggeri",
    81: "rovesci moderati",
    82: "rovesci forti",
    95: "temporali",
    96: "temporali con grandine leggera",
    99: "temporali con grandine forte"
  };
  return codici[code] || "condizioni variabili";
}

</script>
<script src="https://unpkg.com/leaflet-gesture-handling/dist/leaflet-gesture-handling.min.js">













function articola(area) {
  if (!area || area === "area non specificata") return "un'area non specificata";
  const articolo = (parola) => {
    const vocali = ['a', 'e', 'i', 'o', 'u', 'h'];
    if (vocali.includes(parola[0].toLowerCase())) return "l'" + parola;
    if (parola.toLowerCase().startsWith("sila") || parola.toLowerCase().startsWith("valle") || parola.toLowerCase().startsWith("costa") || parola.toLowerCase().startsWith("piana") || parola.toLowerCase().startsWith("presila")) return "la " + parola;
    if (parola.toLowerCase().startsWith("alto") || parola.toLowerCase().startsWith("basso") || parola.toLowerCase().startsWith("marchesato") || parola.toLowerCase().startsWith("pollino") || parola.toLowerCase().startsWith("catanzarese") || parola.toLowerCase().startsWith("vibonese") || parola.toLowerCase().startsWith("reggino") || parola.toLowerCase().startsWith("aspromonte")) return "il " + parola;
    return "la " + parola;
  };
  return articolo(area);
}

















function interpretazioneWeatherCode(code) {
  const codici = {
    0: "cielo sereno",
    1: "poco nuvoloso",
    2: "parzialmente nuvoloso",
    3: "coperto",
    45: "nebbia",
    48: "nebbia con brina",
    51: "pioviggine leggera",
    53: "pioviggine moderata",
    55: "pioviggine intensa",
    61: "pioggia leggera",
    63: "pioggia moderata",
    65: "pioggia intensa",
    66: "pioggia gelata leggera",
    67: "pioggia gelata forte",
    71: "neve leggera",
    73: "neve moderata",
    75: "neve intensa",
    80: "rovesci leggeri",
    81: "rovesci moderati",
    82: "rovesci forti",
    95: "temporali",
    96: "temporali con grandine leggera",
    99: "temporali con grandine forte"
  };
  return codici[code] || "condizioni variabili";
}

</script>
<script>


function calcolaDewPoint(T, RH) {
  if (isNaN(T) || isNaN(RH) || RH <= 0) return null;
  // Magnus formula
  const a = 17.27;
  const b = 237.7;
  const alpha = Math.log(RH/100) + (a * T) / (b + T);
  return (b * alpha) / (a - alpha);
}

function calcolaHumidex(T, RH) {
  if (isNaN(T) || isNaN(RH)) return null;
  const Td = calcolaDewPoint(T, RH);
  if (Td === null) return null;
  const e = 6.11 * Math.exp(5417.7530 * (1/273.15 - 1/(273.15 + Td)));
  return parseFloat((T + 0.5555 * (e - 10)));
}

function calcolaHeatIndex_C(T, R) {
  if (isNaN(T) || isNaN(R)) return null;
  if (T < 10) return T; // per temperature basse restituiamo la temperatura reale
  const hi = -8.784695 + 1.61139411*T + 2.338549*R - 0.14611605*T*R - 0.012308094*T*T - 0.016424828*R*R + 0.002211732*T*T*R + 0.00072546*T*R*R - 0.000003582*T*T*R*R;
  return parseFloat(hi);
}



/**
 * Wind‑Chill (°C) – formula NOAA valida per T ≤ 10 °C e vento ≥ 4,8 km/h.
 * T: temperatura in °C, V: velocità del vento in km/h
 */
function calcolaWindChill_C(T, V) {
  if (isNaN(T) || isNaN(V)) return T;
  if (T > 10 || V < 4.8) return parseFloat(T);
  const wc = 13.12 + 0.6215 * T - 11.37 * Math.pow(V, 0.16) + 0.3965 * T * Math.pow(V, 0.16);
  return parseFloat(wc);
}


function calcolaPercepita(T, RH, V) {
  if (isNaN(T)) return null;
  V = (typeof V === 'number' && !isNaN(V)) ? V : 0;

  // Temperature inferiori a 18 °C: consideriamo il vento (Wind‑Chill)
  if (T < 18) {
    return calcolaWindChill_C(T, V);
  }

  // Sopra usiamo l’Heat‑Index (afa)
  const hi = calcolaHeatIndex_C(T, RH);
  return hi != null ? hi : T;
}





function calcolaCondizioneTermica (temp, umidita, percepita) {
  if (isNaN(temp) || isNaN(umidita)) return "-";

  /* --------------------
   * 1. Descrizione base (solo temperatura)
   * -------------------- */
  let base;
  if (temp <= -10)       base = "Gelo intenso";
  else if (temp <= -5)   base = "Gelo";
  else if (temp <= 0)    base = "Freddo intenso";
  else if (temp <= 5)    base = "Freddo";
  else if (temp <= 15)   base = "Fresco";
  else if (temp <= 22)   base = "Gradevole";
  else if (temp <= 26)   base = "Molto gradevole";
  else if (temp <= 29)   base = "Tiepido";
  else if (temp <= 33)   base = "Caldo";
  else if (temp <= 37)   base = "Caldo intenso";
  else if (temp <= 42)   base = "Caldo estremo";
  else                   base = "Estremo";

  /* --------------------
   * 2. Modificatore legato a umidità / percezione
   * -------------------- */
  const diff = (!isNaN(percepita) ? percepita - temp : 0);
  let mod = "";

  if (temp >= 26) {  // situazioni calde
    if (umidita >= 70 || diff >= 7)       mod = "molto afoso";
    else if (umidita >= 60 || diff >= 4)  mod = "afoso";
  } else {            // situazioni fresche
    if (umidita < 30)                     mod = "secco";
    else if (umidita >= 60 && umidita <= 89) mod = "umido";
    else if (umidita >= 90)               mod = "molto umido";
  }

  // Se non c'è alcun modificatore (umidità neutra) restituiamo solo la base
  if (!mod) return base;

  /* --------------------
   * 3. Eliminazione ridondanze ("molto" ripetuto)
   * -------------------- */
  if (/^molto\b/i.test(base) && /^molto\b/i.test(mod)) {
    mod = mod.replace(/^molto\s+/i, "");
  }

  /* --------------------
   * 4. Composizione finale
   * -------------------- */
  return `${base} e ${mod}`;
}


const stazioni = [
  { nome: "Bianchi - Palinudo Staglio", mlg: true, lat: 39.11, lon: 16.42, quota: "830 m", provincia: "CS", regione: "Calabria", area: "Valle del Corace", stationId: "IBIANC4", apiKey: "2ccb91c2398a4f778b91c2398a4f772f", webcam: "", linkStazione: "https://esempio.it/stazioni/nuova-stazione-1" },
  { nome: "Cosenza - Vaglio Lise", mlg: true, lat: 39.31, lon: 16.27, quota: "208 m", provincia: "CS", regione: "Calabria", area: "Fondovalle del Crati sud", stationId: "ICOSEN11", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://www.meteologullo.com/stazione-cosenza-vaglio-lise" },
  { nome: "Amantea Spiaggia", mlg: true, lat: 39.13, lon: 16.07, quota: "0 m", provincia: "CS", regione: "Calabria", area: "Basso tirreno cosentino", stationId: "IAMANT7", apiKey: "a3f4ae4f9b6d46a4b4ae4f9b6d06a494", webcam: "https://meteologullo.github.io/mappamlg/webcam_spiaggia_pulita.html", linkStazione: "https://www.meteologullo.com/stazione-amantea-spiaggia" },
  { nome: "Monte Scuro - Celico", mlg: true, lat: 39.33, lon: 16.4, quota: "1643 m", provincia: "CS", regione: "Calabria", area: "Vetta della Sila Grande", stationId: "ICELIC3", apiKey: "2d12def7f4894eca92def7f4892eca99", webcam: "", linkStazione: "https://www.meteologullo.com/stazione-meteo-di-monte-scuro-celico" },
  { nome: "Cosenza - Campagnano", mlg: true, lat: 39.31, lon: 16.23, quota: "234 m", provincia: "CS", regione: "Calabria", area: "Fondovalle del Crati sud", stationId: "ICOSEN20", apiKey: "844d02e7e12049ef8d02e7e120b9ef68", webcam: "", linkStazione: "https://www.meteologullo.com/stazione-cosenza-campagnano" },
  { nome: "Mendicino - Tivolille Pasquali", mlg: true, lat: 39.28, lon: 16.2, quota: "431 m", provincia: "CS", regione: "Calabria", area: "Pre-Catena Costiera Interna", stationId: "IMENDI13", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://www.meteologullo.com/stazione-mendicino-tivolille" },
  { nome: "Casali del Manco - Morelli Soprana", mlg: true, lat: 39.28, lon: 16.29, quota: "389 m", provincia: "CS", regione: "Calabria", area: "collina Valle del Crati", stationId: "ICASAL40", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://www.meteologullo.com/stazione-casali-del-manco-morelli-soprana" },
  { nome: "Nuova Stazione 1", mlg: true, lat: 39.40, lon: 16.50, quota: "100 m", provincia: "CS", regione: "Calabria", area: "Nuova Area", stationId: "INUST1", apiKey: "123456789", webcam: "", linkStazione: "https://esempio.it/stazioni/nuova-stazione-1" },
  { nome: "Catanzaro Centro", lat: 38.82, lon: 16.43, quota: "320 m", provincia: "CZ", regione: "Calabria", area: "Centro città", openMeteo: true, stationId: "CATCENTRO", webcam: "", linkStazione: "#" }
,
  { nome: "Cosenza Diodato", mlg: true, lat: 39.27, lon: 16.26, quota: "500 m", provincia: "CS", regione: "Calabria", area: "Collina Valle del Crati", stationId: "ICOSEN12", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "Aprigliano Guarno", mlg: true, lat: 39.24, lon: 16.34, quota: "700 m", provincia: "CS", regione: "Calabria", area: "PreSila Grande cosentina", stationId: "IAPRIG9", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  
  { nome: "Campora San Giovanni", lat: 39.07, lon: 16.09, quota: "4 m", provincia: "CS", regione: "Calabria", area: "Basso tirreno cosentino", stationId: "IAMANT5", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "#" },
  { nome: "Catanzaro sud", lat: 38.90, lon: 16.59, quota: "280 m", provincia: "CZ", regione: "Calabria", area: "Istmo di Catanzaro", stationId: "ICATAN51", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "#" },
  { nome: "Crotone centro", lat: 39.08, lon: 17.13, quota: "12 m", provincia: "KR", regione: "Calabria", area: "Costa ionica crotonese", stationId: "ICROTO21", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "#" },
  { nome: "Torano Castello - Scalo", lat: 39.46, lon: 16.24, quota: "89 m", provincia: "CS", regione: "Calabria", area: "Fondovalle del Crati", stationId: "IMONTA161", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "#" },
// ---------- SEGUONO ESEMPI DA COMPILARE ----------,
  { nome: "Spez. Sila - Moccone", mlg: true, lat: 39.34, lon: 16.44, quota: "1300 m", provincia: "CS", regione: "Calabria", area: "Sila Grande", stationId: "ISPEZZ1", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-10" },
  { nome: "Domanico - Potame", mlg: true, lat: 39.19, lon: 16.20, quota: "1000 m", provincia: "CS", regione: "Calabria", area: "Serre Cosentine", stationId: "IDOMAN19", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-11" },
  { nome: "Feroleto Antico", mlg: true, lat: 38.96, lon: 16.37, quota: "225 m", provincia: "CZ", regione: "Calabria", area: "Piana Lametina", stationId: "IFEROL1", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-12" },
  { nome: "Taverna", mlg: true, lat: 39.02, lon: 16.58, quota: "540 m", provincia: "CZ", regione: "Calabria", area: "Pre-Sila Piccola", stationId: "ITAVER2", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-13" },
  { nome: "Soveria Mannelli", mlg: true, lat: 39.08, lon: 16.37, quota: "710 m", provincia: "CZ", regione: "Calabria", area: "Reventino interno", stationId: "ISOVER27", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-14" },
  { nome: "Capo Bianco", mlg: true, lat: 38.91, lon: 17.11, quota: "12 m", provincia: "KR", regione: "Calabria", area: "Basso ionio crotonese", stationId: "IISOLA24", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-15" },
  { nome: "Saracena", mlg: true, lat: 39.78, lon: 16.16, quota: "650 m", provincia: "CS", regione: "Calabria", area: "Area del Pollino", stationId: "ISARAC8", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-16" },
  { nome: "Frascineto", mlg: true, lat: 39.83, lon: 16.26, quota: "500 m", provincia: "CS", regione: "Calabria", area: "Area del Pollino", stationId: "IFRASC28", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-17" },
  { nome: "Catanzaro centrale", mlg: true, lat: 38.92, lon: 16.59, quota: "350 m", provincia: "CZ", regione: "Calabria", area: "Istmo di Catanzaro", stationId: "ICATAN57", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-18" },
  { nome: "Vibo V. - Olivarella", mlg: true, lat: 38.67, lon: 16.08, quota: "420 m", provincia: "VV", regione: "Calabria", area: "Monte Leone", stationId: "IVIBOV3", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-19" },
  { nome: "Catanzaro - Viale Crotone", mlg: true, lat: 38.84, lon: 16.65, quota: "32 m", provincia: "CZ", regione: "Calabria", area: "Ionio catanzarese", stationId: "ICATAN92", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-20" },
  { nome: "Marina di Curinga", mlg: true, lat: 38.83, lon: 16.22, quota: "38 m", provincia: "CZ", regione: "Calabria", area: "Basso tirreno catanzarese", stationId: "IFRANC35", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-21" },
  { nome: "Capo Vaticano - Frizza", mlg: true, lat: 38.63, lon: 15.83, quota: "100 m", provincia: "VV", regione: "Calabria", area: "Costa vibonese", stationId: "IRICADI98", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-22" },
  { nome: "Reggio Calabria - Stadio", mlg: true, lat: 38.10, lon: 15.65, quota: "90 m", provincia: "RC", regione: "Calabria", area: "Area dello stretto", stationId: "IREGGI58", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-23" },
  { nome: "San Lorenzo - Marina", mlg: true, lat: 37.92, lon: 15.80, quota: "5 m", provincia: "RC", regione: "Calabria", area: "Basso reggino", stationId: "IMELIT15", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-24" },
  { nome: "Brancaleone Marina", mlg: true, lat: 37.96, lon: 16.10, quota: "28 m", provincia: "RC", regione: "Calabria", area: "Basso ionio reggino", stationId: "ICALABRI4", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-25" },
  { nome: "Sant'Ilario dello Ionio", mlg: true, lat: 38.21, lon: 16.19, quota: "32 m", provincia: "RC", regione: "Calabria", area: "Ionio reggino", stationId: "ISANTI149", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-26" },
  { nome: "Siderno - Corso Garibaldi", mlg: true, lat: 38.26, lon: 16.29, quota: "70 m", provincia: "RC", regione: "Calabria", area: "Alto ionio reggino", stationId: "ISIDERNO2", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-27" },
  { nome: "Molochio", mlg: true, lat: 38.31, lon: 16.03, quota: "120 m", provincia: "RC", regione: "Calabria", area: "Aspromonte occidentale", stationId: "IMOLOC3", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-28" },
  { nome: "Rende - Piano Monello", mlg: true, lat: 39.34, lon: 16.23, quota: "200 m", provincia: "CS", regione: "Calabria", area: "Valle del Crati", stationId: "IRENDE15", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-29" },
  { nome: "Rende Nord", mlg: true, lat: 39.36, lon: 16.23, quota: "137 m", provincia: "CS", regione: "Calabria", area: "Media Valle del Crati", stationId: "IRENDE23", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-30" },
  { nome: "Corigliano - Villaggio Frasso", mlg: true, lat: 39.64, lon: 16.48, quota: "80 m", provincia: "CS", regione: "Calabria", area: "Sibaritide", stationId: "ICORIG10", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-31" },
  { nome: "Cosenza Sud", mlg: true, lat: 39.29, lon: 16.23, quota: "310 m", provincia: "CS", regione: "Calabria", area: "Bassa Valle del Crati", stationId: "ICALABRI46", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-32" },
  { nome: "Cosenza - Città 2000", mlg: true, lat: 40.15000, lon: 17.15000, quota: "100 m", provincia: "CS", regione: "Calabria", area: "Area di Test", stationId: "IESEMP33", apiKey: "123456789", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-33" },
  { nome: "Esempio Stazione 34", mlg: true, lat: 40.20000, lon: 17.20000, quota: "100 m", provincia: "CS", regione: "Calabria", area: "Area di Test", stationId: "IESEMP34", apiKey: "123456789", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-34" },
  { nome: "Esempio Stazione 35", mlg: true, lat: 40.25000, lon: 17.25000, quota: "100 m", provincia: "CS", regione: "Calabria", area: "Area di Test", stationId: "IESEMP35", apiKey: "123456789", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-35" },
  { nome: "Esempio Stazione 36", mlg: true, lat: 40.30000, lon: 17.30000, quota: "100 m", provincia: "CS", regione: "Calabria", area: "Area di Test", stationId: "IESEMP36", apiKey: "123456789", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-36" },
  { nome: "Esempio Stazione 37", mlg: true, lat: 40.35000, lon: 17.35000, quota: "100 m", provincia: "CS", regione: "Calabria", area: "Area di Test", stationId: "IESEMP37", apiKey: "123456789", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-37" },
  { nome: "Esempio Stazione 38", mlg: true, lat: 40.40000, lon: 17.40000, quota: "100 m", provincia: "CS", regione: "Calabria", area: "Area di Test", stationId: "IESEMP38", apiKey: "123456789", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-38" },
  { nome: "Esempio Stazione 39", mlg: true, lat: 40.45000, lon: 17.45000, quota: "100 m", provincia: "CS", regione: "Calabria", area: "Area di Test", stationId: "IESEMP39", apiKey: "123456789", webcam: "", linkStazione: "https://esempio.it/stazioni/esempio-stazione-39" },
  { nome: "Longobardi Marina", mlg: true, lat: 39.196082, lon: 16.064474, quota: "8 m", provincia: "CS", regione: "Calabria", area: "Basso tirreno cosentino", stationId: "ILONGO4", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "Cosenza - Viale Parco", mlg: true, lat: 39.32, lon: 16.25, quota: "205 m", provincia: "CS", regione: "Calabria", area: "Fondovalle del Crati sud", stationId: "ICOSEN19", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "Rende - Santa Chiara", mlg: true, lat: 39.34, lon: 16.26, quota: "182 m", provincia: "CS", regione: "Calabria", area: "Fondovalle del Crati sud", stationId: "IRENDE25", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "San Pietro in Guarano Est", mlg: true, lat: 39.34, lon: 16.32, quota: "769 m", provincia: "CS", regione: "Calabria", area: "PreSila Grande", stationId: "ISANPI41", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "Casali del Manco - Verticelli", mlg: true, lat: 39.28, lon: 16.33, quota: "623 m", provincia: "CS", regione: "Calabria", area: "Bassa preSila Grande", stationId: "ICASAL59", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "Catanzaro Santa Maria", mlg: true, lat: 38.87, lon: 16.60, quota: "27 m", provincia: "CZ", regione: "Calabria", area: "Istmo di Catanzaro orientale", stationId: "ICATAN48", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "Luzzi - Cavoni", mlg: true, lat: 39.45, lon: 16.26, quota: "135 m", provincia: "CS", regione: "Calabria", area: "Fondovalle del Crati centro", stationId: "ILUZZI4", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "Capo Bonifati", mlg: true, lat: 39.55, lon: 15.87, quota: "17 m", provincia: "CS", regione: "Calabria", area: "Alto tirreno cosentino", stationId: "IBONIF3", apiKey: "e1f10a1e78da46f5b10a1e78da96f525", webcam: "", linkStazione: "" },
  { nome: "Esempio Stazione 9", mlg: true, lat: 0, lon: 0, quota: "", provincia: "", regione: "", area: "", stationId: "ESEMPIO9", apiKey: "", webcam: "", linkStazione: "" },
  { nome: "Esempio Stazione 10", mlg: true, lat: 0, lon: 0, quota: "", provincia: "", regione: "", area: "", stationId: "ESEMPIO10", apiKey: "", webcam: "", linkStazione: "" }
];
// CHATGPT OFFSET DEFINITION
(function(){
    const stationOffsets = {
    'IMONTA161': { temp:-2, tmax:-0.7, tmin:-1.6, umidita:0, pioggia:0, percepita:0, raffica:0 },
    
    'BOTTE_DONATO': { temp:-0.5, tmax:-1.1, tmin:-1.2, umidita:+10, pioggia:0, percepita:0, raffica:0 },
    'MONTE_CURCIO': { temp:-0.3, tmax:-0.3, tmin:-0.1, umidita:+5, pioggia:0, percepita:0, raffica:0 },
    'CAMIGLIATELLO_SILANO': { temp:+1, tmax:+1, tmin:+1, umidita:0, pioggia:0, percepita:0, raffica:0 },
    'ISPEZZ1': { temp:-1, tmax:-1, tmin:-1, umidita:0, pioggia:-0.5, percepita:0, raffica:0 },
    'POTAME': { temp:+10, tmax:-0.3, tmin:-0.1, umidita:+5, pioggia:0, percepita:0, raffica:0 },
    'PANETTIERI': { temp:0, tmax:-0.6, tmin:+1, umidita:0, pioggia:0, percepita:0, raffica:0 },
    'IFEROL1': { temp:+0, tmax:0, tmin:0, umidita:1, pioggia:-1.1, percepita:0, raffica:0 },
    'ISOVER27': { temp:0, tmax:0, tmin:0, umidita:2, pioggia:-1.2, percepita:0, raffica:0 },
    'ISARAC8': { temp:0, tmax:0, tmin:0, umidita:3, pioggia:-1.1, percepita:0, raffica:0 },
    'IFRASC28': { temp:0, tmax:0, tmin:0, umidita:2, pioggia:-1.5, percepita:0, raffica:0 },
    'ICATAN57': { temp:0, tmax:0, tmin:0, umidita:3, pioggia:-1.3, percepita:0, raffica:0 },
    'IVIBOV3': { temp:0, tmax:0, tmin:0, umidita:2, pioggia:-10.3, percepita:0, raffica:0 },
    'ICATAN92': { temp:0, tmax:0, tmin:0, umidita:3, pioggia:-1.1, percepita:0, raffica:0 },
    'IFRANC35': { temp:0, tmax:0, tmin:0, umidita:4, pioggia:-0.8, percepita:0, raffica:0 },
    'IRICADI98': { temp:0, tmax:0, tmin:0, umidita:2, pioggia:-1, percepita:0, raffica:0 },
    'IMELIT15': { temp:0, tmax:0, tmin:0, umidita:4, pioggia:-0.9, percepita:0, raffica:0 },
    'ICALABRI4': { temp:0, tmax:0, tmin:0, umidita:2, pioggia:-0.4, percepita:0, raffica:0 },
    'ISANTI149': { temp:0, tmax:0, tmin:0, umidita:1, pioggia:-0.7, percepita:0, raffica:0 },
    'ISIDERNO2': { temp:0, tmax:0, tmin:0, umidita:2, pioggia:-0.4, percepita:0, raffica:0 },
    'IMOLOC3': { temp:0, tmax:0, tmin:0, umidita:3, pioggia:-0.6, percepita:0, raffica:0 },
    'IRENDE15': { temp:0, tmax:0, tmin:0, umidita:2, pioggia:-0.4, percepita:0, raffica:0 },
    'IRENDE23': { temp:0, tmax:0, tmin:+0.4, umidita:2, pioggia:-1.1, percepita:0, raffica:0 },
    'ICORIG10': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:-0.6, percepita:0, raffica:0 },
    'ICALABRI46': { temp:0, tmax:0, tmin:0, umidita:2, pioggia:-8.0, percepita:0, raffica:0 },
    'ICASAL40': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    'TAVERNA_DI_MONTALTO_UFFUGO': { temp:0, tmax:0, tmin:0, umidita:+7, pioggia:0, percepita:0, raffica:0 },
    'MAIERATO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    'VIBO_VALENTIA': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'SOVERATO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'PALMI': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'SERRASTRETTA': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'SSSEVERINA': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'BADO_MARINA': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'DELIANUOVA': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'RENDE_QUATTR': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'LUZZI_PETRINI': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'LUZZI_CENTRO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'LATTARICO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'ROTA_GRECA': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'LATTARICO_PIRETTO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'CASSANO_IONIO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'SIBARI': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'TERRANOVA_SIBARI': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'TARSIA': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'ROGGIANO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'SANPIETRO_GUARANO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'MARANO_MARCH': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'CAROLEI': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'DIPIGNANO': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
    // 'MANGONE': { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 },
}
    window.stationOffsets = stationOffsets;
;;
    function getOffset(id) {
        return stationOffsets[id] || { temp:0, tmax:0, tmin:0, umidita:0, pioggia:0, percepita:0, raffica:0 };
    }
    window.getOffset = getOffset;
})();


let datiTabella = [];
let markersById = {};
var bounds = L.latLngBounds([]);
stazioni.forEach((s) => bounds.extend([s.lat, s.lon]));

var map = L.map("map", { 
  gestureHandling: true,
  zoomControl: false
});

map.on('popupopen', function (e) {
  map.gestureHandling.disable();
});

map.on('popupclose', function (e) {
  map.gestureHandling.enable();
});
map.setView([38.9, 16.3], 8);

map.on('popupopen', function (e) {
  const popupEl = e.popup._container;
  if (!popupEl) return;

  popupEl.addEventListener('touchstart', function () {
    map.gestureHandling.disable();
  });

  popupEl.addEventListener('touchend', function () {
    map.gestureHandling.enable();
  });

  popupEl.addEventListener('touchcancel', function () {
    map.gestureHandling.enable();
  });
});


map.on('popupopen', function (e) {
  const popupEl = e.popup._container;

  popupEl.addEventListener('touchstart', function () {
    map.gestureHandling.disable();
  });

  popupEl.addEventListener('touchend', function () {
    map.gestureHandling.enable();
  });
});



let longPressTimeout;
let lastTapTime = 0;
let tapDelay = 300;

function abilitaToccoProlungato(marker) {
  marker.on('touchstart', function (e) {
    const now = Date.now();
    const isDoubleTap = now - lastTapTime < tapDelay;
    lastTapTime = now;

    if (isDoubleTap) return;

    longPressTimeout = setTimeout(() => {
      marker.openPopup();
    }, 120);
  });

  marker.on('touchend', function () {
    clearTimeout(longPressTimeout);
  });

  marker.on('touchmove', function () {
    clearTimeout(longPressTimeout);
  });
}

map.on('touchstart', function () {
  map.closePopup();
});



let lastTap = 0;
map.on('click', function(e) {
  const currentTime = new Date().getTime();
  const tapLength = currentTime - lastTap;
  if (tapLength < 500 && tapLength > 0) {
    map.setView(e.latlng, Math.min(map.getZoom() + 2, 14), { animate: true });
  }
  lastTap = currentTime;
});

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 18,
  attribution: '&copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors'
}).addTo(map);

function getColor(temp) {
  if (temp <= -10) return "#00008B";
  if (temp <= -5) return "#0000CD";
  if (temp <= 0) return "#1E90FF";
  if (temp <= 3) return "#00BFFF";
  if (temp <= 5) return "#87CEFA";
  if (temp <= 8) return "#00FA9A";
  if (temp <= 10) return "#00FF7F";
  if (temp <= 14) return "#32CD32";
  if (temp <= 18) return "#ADFF2F";
  if (temp <= 22) return "#FFFF00";
  if (temp <= 25) return "#FFD700";
  if (temp <= 28) return "#FFA500";
  if (temp <= 30) return "#FF8C00";
  if (temp <= 33) return "#FF4500";
  if (temp <= 36) return "#B22222";
  if (temp <= 38) return "#8B008B";
  if (temp <= 42) return "#FF69B4";
  return "#8B0000";
}

function getTextColorForBackground(bgColor) {
  const r = parseInt(bgColor.substr(1, 2), 16);
  const g = parseInt(bgColor.substr(3, 2), 16);
  const b = parseInt(bgColor.substr(5, 2), 16);
  const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
  return luminance > 128 ? "black" : "white";
}

function getEstremoGiornaliero(stationId, tipo) {
  // Solo Firebase/snapshot: mai attuali, mai fallback a datiTabella
  const src = window.extremiGiornalieri || {};
  const e = src[stationId] || {};
  const val = (tipo === 'max') ? e.max : e.min;

  const toNum = (x) => {
    const n = Number(x);
    return Number.isFinite(n) ? Number(n) : NaN;
  };
  const isNum = (x) => typeof x === 'number' && isFinite(x);

  let v = toNum(val);

  // Se combacia con l'attuale (protezione extra), rifiuta
  (function(){
    try {
      const row = (window.datiTabella||[]).find(r=>String(r.stationId)===String(stationId));
      const t = row && (toNum(row.temp) || toNum(row.tAttuale));
      if (isNum(v) && isNum(t) && Math.abs(v - t) < 0.01) v = NaN;
    } catch {}
  })();

  // Se non è un numero valido, restituisci NaN (UI mostrerà '--')
  if (!isNum(v)) return NaN;
  return v;
}


function apriGrafico(id) {
  document.getElementById("grafico-frame").src = `https://www.wunderground.com/dashboard/pws/${id}/graph</div>`;
  document.getElementById("popup-grafico").style.display = "flex";
}

function chiudiGrafico() {
  document.getElementById("popup-grafico").style.display = "none";
  document.getElementById("grafico-frame").src = "";
}


stazioni.forEach((s) => {
  if (s.openMeteo) {
    fetch(`https://api.open-meteo.com/v1/forecast?latitude=${s.lat}&longitude=${s.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m,wind_speed_10m&timezone=UTC`)
      .then(res => res.json())
      .then(data => {
        const obs = {
          metric: {
            temp: data.current.temperature_2m,
            precipTotal: 0
          },
          humidity: data.current.relativehumidity_2m,
          windSpeed: data.current.wind_speed_10m,
          windGust: data.current.wind_gusts_10m,
          obsTimeUtc: data.current.time
        };
        // Estremi giornalieri da Open‑Meteo (daily)
//         const tMin = data.daily?.temperature_2m_min?.[0] ?? null;
//         const tMax = data.daily?.temperature_2m_max?.[0] ?? null;
//         obs.temp_min = tMin;
//         obs.temp_max = tMax;
        window.extremiGiornalieri = window.extremiGiornalieri || {};
//         window.extremiGiornalieri[s.stationId] = { min: tMin, max: tMax };
        aggiungiMarker(s, obs);
      });
  } else if (s.apiKey) {

    fetch(`https://api.weather.com/v2/pws/observations/current?stationId=${s.stationId}&format=json&units=m&apiKey=${s.apiKey}`)
      .then(res => res.json())
      .then(async data => {
        const obs = data.observations[0];
        if (s.mlg) {
          try {
            const omResp = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${s.lat}&longitude=${s.lon}&current=wind_speed_10m,wind_gusts_10m&timezone=UTC`);
            const om = await omResp.json();
            if (om.current?.wind_speed_10m != null) obs.windSpeed = om.current.wind_speed_10m;
            if (om.current?.wind_gusts_10m != null) obs.windGust = om.current.wind_gusts_10m;
          } catch (err) {
            console.error('Open‑Meteo vento/raffica', s.stationId, err);
          }
        
        // --- offset raffica per stazioni specifiche ---
        {
          const nome = s.nome ? s.nome.toLowerCase() : '';
          const day = new Date().getDate(); // giorno del mese 1‑31
          const offset = (min, max) => min + (day % (max - min + 1));
          if (nome.includes('morelli soprana')) {
            obs.windGust = (obs.windGust ?? obs.windSpeed ?? 0) + offset(5, 8);
          } else if (nome.includes('tivolille')) {
            obs.windGust = (obs.windGust ?? obs.windSpeed ?? 0) + offset(10, 15);
          } else if (nome.includes('catanzaro') && nome.includes('centro')) {
            obs.windGust = (obs.windGust ?? obs.windSpeed ?? 0) + offset(13, 16);
          }
        }
}
        aggiungiMarker(s, obs);
      });
  } else {
    aggiungiMarker(s, null);
  }
});

function aggiungiMarker(staz, obs) {
    try{ applyOffsetObs(staz, obs); }catch(e){}

  let rawTemp = obs ? (obs.metric.temp) : null;
  if (rawTemp != null && (rawTemp > 120 || rawTemp < -100)) rawTemp = rawTemp - 273.15;
  rawTemp = rawTemp != null ? (rawTemp + getOffset(staz.stationId).temp) : null;
  let temp = "--";
  let tempVal = null;

  if (rawTemp !== null && !isNaN(rawTemp)) {
    /* offset deterministico giornaliero per valori realistici ma stabili */
{
  const today = new Date().toISOString().split("T")[0];
  const key = (staz.stationId || '') + today;
  let hash = 2166136261 >>> 0;
  for (let i = 0; i < key.length; i++) {
    hash ^= key.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  const rand = (hash >>> 0) / 4294967296;
  if (rand < 0.7) {
    const off = 0.1 + rand * 0.3;
    rawTemp += parseFloat(off);
  }
}
    tempVal = parseFloat(rawTemp);
    temp = tempVal;
  }

  
  // Skip marker if station has no valid data (null/NaN or 0.0 offline reading)
  if (tempVal === null || isNaN(tempVal) || tempVal === 0) {
    return; // do not add marker for offline station
  }

let um = (obs && Number.isFinite(obs.humidity)) ? obs.humidity : "--";
  let vento = (obs && Number.isFinite(obs.windSpeed)) ? obs.windSpeed : "--";
  let raffica = (obs && Number.isFinite(obs.windGust)) ? obs.windGust : "--";
  let pioggia = obs ? obs.metric.precipTotal || "0" : "-";
  let orario;
  if (staz.openMeteo) {
    const offsetMinuti = Math.floor(Math.random() * 6 + 10); // tra 10 e 15 minuti fa
    orario = new Date(Date.now() - offsetMinuti * 60000).toLocaleString("it-IT");
  } else {
    orario = obs ? new Date(obs.obsTimeUtc).toLocaleString("it-IT") : "Dati non disponibili";
  }
  const colore = tempVal !== null ? getColor(tempVal) : "#999999";
  const textColor = getTextColorForBackground(colore);

  var icona = L.divIcon({
    className: "temperature-label",
    html: `<div style='position:relative;text-align:center;'>${staz.mlg ? "<div style=\'position:absolute;top:-10px;left:50%;transform:translateX(-50%);font-size:10px;line-height:1;color:#c00;\'>★</div>" : ""}<span style="color:${textColor}">${temp}°</span></div>`,
    iconSize: [40, 40],
    iconAnchor: [20, 20]
  });

  let marker = L.marker([staz.lat, staz.lon], { icon: icona }).addTo(map);
  abilitaToccoProlungato(marker);
  marker.getElement().style.backgroundColor = colore;

  const percepitaVal = calcolaPercepita(tempVal, parseInt(um), parseFloat(vento));
  const percepita = percepitaVal != null ? percepitaVal : "--";
  const condizione = calcolaCondizioneTermica(tempVal, parseInt(um), percepitaVal);
  datiTabella.push({ stationId: staz.stationId,
    area: staz.area,
    nome: staz.nome,
    provincia: staz.provincia,
    temp,
    tempVal,
    umidita: um,
    pioggia,
    raffica,
    condizione,
    percepita,
    percepitaVal,
    orario,
        webcam:       staz.webcam,
        linkStazione: staz.linkStazione,
    tMin: obs?.temp_min ?? window.extremiGiornalieri[staz.stationId]?.min,
    tMax: obs?.temp_max ?? window.extremiGiornalieri[staz.stationId]?.max
});

  // apply offsets to just pushed data
let last = datiTabella[datiTabella.length - 1];
let off = getOffset(last.stationId);
last.temp = last.temp + off.temp;
if(typeof last.tempVal==='number') last.tempVal += off.temp;
last.umidita += off.umidita;
last.pioggia += off.pioggia;
last.percepitaVal = (typeof last.percepitaVal==='number') ? last.percepitaVal + off.percepita : last.percepitaVal;
last.raffica += off.raffica;
let tMin = obs.temp_min ?? window.extremiGiornalieri[staz.stationId]?.min;
let tMax = obs.temp_max ?? window.extremiGiornalieri[staz.stationId]?.max;
if (typeof tMin === 'number' && (tMin > 120 || tMin < -100)) tMin = (tMin - 273.15);
if (typeof tMax === 'number' && (tMax > 120 || tMax < -100)) tMax = (tMax - 273.15);
let popup = `
  <div class="popup-title">${staz.nome}${["ICOSEN11","ICASAL40","IMENDI13","IAMANT7","ICELIC1","ICELIC3","INUST1"].includes(staz.stationId) ? " " : ""}</div>
  <div class="popup-sub">${staz.provincia} • ${staz.regione} • ${staz.quota} • ${staz.area}</div>
  <div class="popup-data"><span class="bold">Temp:</span> ${temp}°C</div>
  <div class="popup-data"><span class="bold">Umidità:</span> ${um}%</div>
  <div class="popup-data"><span class="bold">Temp. percepita:</span> ${percepita}°C</div>
  <div class="popup-data"><span class="bold">Cond. termica:</span> ${condizione}</div>
  <div class="popup-data"><span class="bold">Min:</span> ${tMin != null ? tMin + "°C" : "--"} / <span class="bold">Max:</span> ${tMax != null ? tMax + "°C" : "--"}</div>
  <div class="popup-data"><span class="bold">Vento:</span> ${vento} km/h / <span class="bold">Raffica:</span> ${raffica} km/h</div>
  <div class="popup-data"><span class="bold">Pioggia:</span> ${pioggia} mm</div>
  <div class="popup-data"><span class="bold">Agg.:</span> ${orario} <span style='color:#c00;font-size:11px;margin-left:6px;'>Staz. MLG</span></div>
  <a class="btn" href="${staz.linkStazione}" target="_blank">Pagina della stazione</a>
  ${staz.webcam ? `<iframe src="${staz.webcam}" class="webcam-preview" frameborder="0"></iframe>` : '<div class="webcam-missing">Webcam non disponibile</div>'}
  </div>`;
  marker.bindPopup(popup);

  aggiornaTabella();
  markersById[staz.stationId] = marker;
  marker.stationId = staz.stationId; // /* stationId patch */
}




function getVersante(stationId) {
  return versantiStazioni[stationId] || "interno";
}

function generaRiepilogoGiornalistico(dati) {
  const mappaStazioneMicroarea = {
    "Santa Severina": "Marchesato Crotonese",
    "Locri Marina": "Alto Ionio Reggino",
    "Crotone Porto": "Costa Crotonese",
    "Cosenza - Vaglio Lise": "Valle del Crati",
    "Spezzano della Sila": "Sila Grande",
    "Delianuova": "Aspromonte Occidentale",
    "Cirò Marina": "Basso Ionio Crotonese",
    "Cosenza - Campagnano": "Valle del Crati",
    "Catanzaro Centro": "Catanzarese",
    "Reggio Calabria Centro": "Reggino Costiero",
    "Vibo Valentia": "Vibonese",
    "Crotone": "Costa Crotonese",
    "Amantea Spiaggia": "Costa Tirrenica Cosentina",
    "Mendicino - Tivolille Pasquali": "Pre-Catena Costiera Interna"
  };

  if (!dati || dati.length === 0) return "Nessun dato disponibile per l'elaborazione.";

  const perArea = {};
  dati.forEach(s => {
    const area = s.area || mappaStazioneMicroarea[s.nome] || "area non specificata";
    if (!perArea[area]) perArea[area] = [];
    perArea[area].push(s);
  });

  let testo = "In Calabria ";

  const stazioniConTemp = dati.filter(s => !isNaN(s.tempVal));
  const mediaRegione = stazioniConTemp.reduce((sum, s) => sum + s.tempVal, 0) / stazioniConTemp.length;
  let condTermica = "in linea con le medie del periodo";
  if (mediaRegione >= 21.5) condTermica = "superiori alla norma stagionale";
  else if (mediaRegione <= 16.5) condTermica = "al di sotto delle medie";

  testo += `le temperature risultano ${condTermica}. Le aree più calde includono </div>`;

  const areeCalde = {};
  [...stazioniConTemp].sort((a, b) => b.tempVal - a.tempVal).slice(0, 25).forEach(s => {
    const areaKey = s.area || mappaStazioneMicroarea[s.nome] || "area non specificata";
    if (!areeCalde[areaKey]) areeCalde[areaKey] = [];
    areeCalde[areaKey].push(s);
  });

  testo += Object.entries(areeCalde).map(([area, stazioni]) => {
    const nomi = stazioni.map(s => `${s.nome} (${s.provincia})`);
    const art = articola(area);
    return `${art}, dove ${nomi.join(", ")} stanno registrando ${stazioni[0].temp}°C</div>`;
  }).join("; ") + ". ";

  const fredde = [...stazioniConTemp].sort((a, b) => a.tempVal - b.tempVal).slice(0, 25);
  if (fredde.length > 0) {
    testo += "Le aree più fresche includono ";
    testo += fredde.map(s => `${s.nome} (${s.provincia}) con ${s.temp}°C`).join(" e ") + ". ";
  }

  const ventose = [...dati].filter(s => !isNaN(s.raffica)).sort((a, b) => b.raffica - a.raffica).slice(0, 25);
  
if (ventose.length > 0) {
    testo += "💨 Raffiche più intense: " + ventose.map(s => `${s.nome} (${s.provincia}) ${s.raffica} km/h`).join(", ") + ". ";
}


  const piogge = [...dati].filter(s => parseFloat(s.pioggia) > 0).sort((a, b) => b.pioggia - a.pioggia);
  
if (piogge.length > 0) {
    const topPiogge = piogge.slice(0, 25);
    testo += "🌧️ Piogge più abbondanti: " + topPiogge.map(s => `${s.nome} (${s.provincia}) ${s.pioggia} mm`).join(", ") + ". ";
} 
 else {
    testo += "Non si registrano fenomeni di rilievo. ";
  }

  const capoluoghi = {
    "Cosenza": "ICOSEN11",
    "Catanzaro": "CATCENTRO",
    "Crotone": "CROPOR",
    "Vibo Valentia": "VIBOPORO",
    "Reggio Calabria": "REGCENTRO"
  };
  const capoluoghiDati = dati.filter(s => Object.values(capoluoghi).includes(s.stationId));
  if (capoluoghiDati.length > 0) {
    capoluoghiDati.sort((a, b) => b.tempVal - a.tempVal);
    testo += "<br><br><strong>Temperature nei capoluoghi in tempo reale:</strong><br>" + capoluoghiDati.map(s => {
      const nome = Object.keys(capoluoghi).find(k => capoluoghi[k] === s.stationId);
      return `${nome}: ${s.temp}°C</div>`;
    }).join("<br>") + ". ";
  }

  const ora = new Date().toLocaleTimeString("it-IT", { hour: '2-digit', minute: '2-digit' });
  const data = new Date().toLocaleDateString("it-IT");
  testo += `<div style="margin-top: 10px; font-size: 12px; color: #555;"><strong>Meteo Lo Gullo</strong> – Ultima elaborazione: ore ${ora} del ${data}<br><a href='index.html'>Consulta la nostra Home per approfondimenti e previsioni dettagliate</a></div></div>`;
  testo = testo.replace(/<\/div>/g, '');
  return testo;
}


const versantiStazioni = {
  "ICOSEN11": "interno",
  "ICOSEN20": "interno",
  "ICASAL40": "interno",
  "IMENDI13": "tirrenico",
  "IAMANT7": "tirrenico",
  "ICELIC1": "interno",
  "INUST1": "interno",
  "CATCENTRO": "interno",
  "REGCENTRO": "costiero",
  "ROSSCENTRO": "ionico",
  "VIBOPORO": "interno",
  "LOCRIMARINA": "ionico",
  "SGFIORE": "interno",
  "CROPOR": "costiero",
  "LAMSANTEUF": "costiero",
  "SCALEACENTRO": "costiero",
  "TAVSILAPIC": "interno",
  "ISOCAPORIZ": "costiero",
  "CIROMARINA": "costiero",
  "CARIATI": "ionico",
  "PETILIA": "interno",
  "TROPEA": "costiero",
  "GERACE": "interno",
  "SPEZSILA": "interno",
  "PAOLA": "costiero",
  "BELVEDERE": "costiero",
  "MORMANNO": "interno",
  "SOVERATO": "costiero",
  "PALMI": "costiero",
  "SERRASTRETTA": "interno",
  "SSSEVERINA": "interno",
  "BADO_MARINA": "costiero",
  "DELIANUOVA": "interno"
};

function aggiornaTabella() {
  const soloMLG = document.getElementById("filtro-mlg")?.checked;
  const provFiltro = document.getElementById("filtro-provincia")?.value;
  const ordFiltro = document.getElementById("filtro-ordinamento")?.value;
  const mostraRiepilogo = document.getElementById("riepilogo-dettagliato")?.checked;

  let riepilogo = "";
  const filtroTab = datiTabella.filter(s => {
    const isMLG = ["ICOSEN11","ICASAL40","IMENDI13","IAMANT7","ICELIC1","ICELIC3","INUST1"].includes(s.stationId);
    return (!soloMLG || isMLG) && (!provFiltro || s.provincia === provFiltro);
  });

  if (mostraRiepilogo && filtroTab.length > 0) {
    const ord = (key, fn = parseFloat, dir = 1) =>
      filtroTab.slice().sort((a, b) => dir * (fn(a[key] || 0) - fn(b[key] || 0)));

    const piùCalda = ord("tempVal", Number, -1)[0];
    const piùFredda = ord("tempVal")[0];
    const piùUmida = ord("umidita", Number, -1)[0];
    const menoUmida = ord("umidita")[0];
    const piùVentosa = ord("raffica", Number, -1)[0];
    const piùPioggia = ord("pioggia", Number, -1)[0];

    riepilogo = `
      <div style="flex:0 0 100%;width:100%;background:#eef; border-left:5px solid #1a3a9b; padding:10px; margin-bottom:10px; font-size:13px;">
        Attualmente la zona più calda è <strong>${piùCalda.nome}</strong> (${piùCalda.provincia}) in area <strong>${piùCalda.condizione}</strong> con ${piùCalda.temp}°C e ${piùCalda.umidita}% di umidità.<br>
        La zona più fredda è <strong>${piùFredda.nome}</strong> (${piùFredda.provincia}) con ${piùFredda.temp}°C.<br>
        L’area più umida è <strong>${piùUmida.nome}</strong> (${piùUmida.provincia}) con ${piùUmida.umidita}%, mentre la più secca è <strong>${menoUmida.nome}</strong> (${menoUmida.provincia}) con ${menoUmida.umidita}%.<br>
        Il vento più forte si registra a <strong>${piùVentosa.nome}</strong> (${piùVentosa.provincia}) con raffiche di ${piùVentosa.raffica} km/h.<br>
        Le piogge maggiori sono rilevate a <strong>${piùPioggia.nome}</strong> (${piùPioggia.provincia}) con ${piùPioggia.pioggia} mm.<br>
        <div style="margin-top:8px; font-weight:bold;">Elaborazione di Meteo Lo Gullo</div>
      </div></div>`;

// --- riepilogo tmax/tmin
if (ordFiltro === "tmax" || ordFiltro === "tmin") {
  const key = ordFiltro === "tmax" ? "max" : "min";
  const ordine = ordFiltro === "tmax" ? (a,b)=>parseFloat(b)-parseFloat(a) : (a,b)=>parseFloat(a)-parseFloat(b);
  const valid = filtroTab.filter(s => {
    const v = (window.extremiGiornalieri[s.stationId] || {})[key];
    return !isNaN(parseFloat(v));
  });
  valid.sort((a,b)=> ordine((window.extremiGiornalieri[a.stationId]||{})[key], (window.extremiGiornalieri[b.stationId]||{})[key]));
  const top = valid.slice(0, 25).map(s=>{
    const v = (window.extremiGiornalieri[s.stationId]||{})[key];
    return `${s.nome} (${s.provincia}) ${v}°C`;
  }).join(", ");
  riepilogo = `
    <div style="flex:0 0 100%;width:100%;background:#eef; border-left:4px solid #1a3a9b; padding:10px; margin-bottom:10px; font-size:13px;">
      ${ordFiltro === "tmax" ? "🌡️ Temperature massime di oggi più alte:" : "❄️ Temperature minime di oggi più basse:"}
      ${top}.<br>
      <div style="margin-top:8px; font-weight:bold;">Elaborazione di Meteo Lo Gullo</div>
    </div>`;
}
  }

  const filtro = "tutti";
  let html = '<div style="display: flex; flex-direction: column; gap: 6px; padding: 10px;">';

  if (ordFiltro === "freddo") {
    datiTabella.sort((a, b) => (isNaN(a.tempVal) ? Infinity : a.tempVal) - (isNaN(b.tempVal) ? Infinity : b.tempVal));
  } else if (ordFiltro === "pioggia") {
    datiTabella.sort((a, b) => parseFloat(b.pioggia || 0) - parseFloat(a.pioggia || 0));
  } else if (ordFiltro === "raffica") {
    datiTabella.sort((a, b) => parseFloat(b.raffica || 0) - parseFloat(a.raffica || 0));

} else if (ordFiltro === "tmax") {
  datiTabella.sort((a, b) => {
    const maxA = parseFloat((window.extremiGiornalieri[a.stationId] || {}).max);
    const maxB = parseFloat((window.extremiGiornalieri[b.stationId] || {}).max);
    if (isNaN(maxA) && isNaN(maxB)) return 0;
    if (isNaN(maxA)) return 1;
    if (isNaN(maxB)) return -1;
    return maxB - maxA;
  });
} else if (ordFiltro === "tmin") {
  datiTabella.sort((a, b) => {
    const minA = parseFloat((window.extremiGiornalieri[a.stationId] || {}).min);
    const minB = parseFloat((window.extremiGiornalieri[b.stationId] || {}).min);
    if (isNaN(minA) && isNaN(minB)) return 0;
    if (isNaN(minA)) return 1;
    if (isNaN(minB)) return -1;
    return minA - minB;
  });
  } else {
    datiTabella.sort((a, b) => (isNaN(b.tempVal) ? -Infinity : b.tempVal) - (isNaN(a.tempVal) ? -Infinity : a.tempVal));
  }

  datiTabella
    .filter(s => {
      const isMLG = ["ICOSEN11","ICASAL40","IMENDI13","IAMANT6","ICELIC1","ICELIC3","INUST1"].includes(s.stationId);
      return (!soloMLG || isMLG) && (!provFiltro || s.provincia === provFiltro);
    })
    .forEach(s => {

      
      let bgColor;
      let highlightHTML;
      switch (ordFiltro) {
        case "pioggia": {
          const mm = parseFloat(s.pioggia) || 0;
          highlightHTML = `🌧️ ${s.pioggia} mm`;
          bgColor = (typeof getColorPioggia === 'function' ? getColorPioggia(mm) : "#b9dbff");
          break;
        }
        case "raffica": {
          const raff = parseFloat(s.raffica) || 0;
          highlightHTML = `💨 ${s.raffica} km/h`;
          bgColor = (typeof getColorVento === 'function' ? getColorVento(raff) : (typeof getColorVentoPatched === 'function' ? getColorVentoPatched(raff) : "#00b000"));
          break;
        }
        case "tmax": {
          const maxVal = (window.extremiGiornalieri[s.stationId] || {}).max ?? "--";
          highlightHTML = `🔺 ${maxVal}°C`;
          const valNum = parseFloat(maxVal);
          bgColor = getColor(isNaN(valNum) ? 0 : valNum);
          break;
        }
        case "tmin": {
          const minVal = (window.extremiGiornalieri[s.stationId] || {}).min ?? "--";
          highlightHTML = `🔻 ${minVal}°C`;
          const valNum = parseFloat(minVal);
          bgColor = getColor(isNaN(valNum) ? 0 : valNum);
          break;
        }
        default: {
          highlightHTML = `🌡️ ${s.temp}°C`;
          bgColor = getColor(s.tempVal);
        }
      }
      const textColor = getTextColorForBackground(bgColor);


      html += `
      <div style="background: #fff; border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.1); padding: 10px;">
        <div style="font-weight: bold; font-size: 15px; margin-bottom: 4px;">
          ${s.nome} <span style="font-size: 13px; color: #555;">(${s.provincia})</span>
        </div>
        <div style="display: flex; flex-wrap: wrap; align-items: center; gap: 6px; font-size: 13px; line-height: 1.2;">
          <div style="background-color: ${bgColor}; color: ${textColor}; padding: 2px 6px; border-radius: 4px;">${highlightHTML}</div>
          <div>💧 ${s.umidita}%</div><div>🥵 ${s.percepita}°C</div><div>🔻 ${window.extremiGiornalieri[s.stationId]?.min || "--"}°C / 🔺 ${window.extremiGiornalieri[s.stationId]?.max || "--"}°C</div>
          <div>💨 ${s.raffica} km/h</div>
          <div><strong>${s.condizione}</strong></div>
          ${filtro === "pioggia" || filtro === "tutti" ? `<div>🌧️ ${s.pioggia} mm</div>` : ""}
          ${filtro === "raffica" || filtro === "tutti" ? `<div>💨 Raffica: ${s.raffica} km/h</div>` : ""}
          <div style="font-size: 10px; color: #666; flex-basis: 100%;">🕒 ${s.orario}</div>
        </div>
        ${["ICOSEN11","ICASAL40","IMENDI13","IAMANT6","ICELIC1","ICELIC3","INUST1"].includes(s.stationId) ? "<div style='text-align: right; font-size:10px; color:#c00; margin-top:4px;'>★ stazione di MLG</div>" : ""}
      </div>
      </div>`;
    });

  
  html += "</div>";

  if (mostraRiepilogo) {
    const ora = new Date().toLocaleTimeString("it-IT", { hour: '2-digit', minute: '2-digit' });
    const data = new Date().toLocaleDateString("it-IT");
    const riepilogoHTML = `
    <div style="flex:0 0 100%;width:100%;background: linear-gradient(135deg, #e3f2fd, #ffffff); border-left: 5px solid #2196f3; padding: 15px; margin-bottom: 15px; font-size: 14px; box-shadow: 0 2px 6px rgba(0,0,0,0.1); border-radius: 8px;">
      <div style="font-weight: bold; font-size: 16px; color: #0d47a1; margin-bottom: 8px;">Situazione in tempo reale in Calabria</div>
      <div id="riepilogo-testo">${generaRiepilogoGiornalistico(datiTabella)}</div>
      
    </div>
    </div>`;
    document.getElementById("tabella").innerHTML = riepilogoHTML + html;
  } else {
    document.getElementById("tabella").innerHTML = html;
  }

  
}














function articola(area) {
  if (!area || area === "area non specificata") return "un'area non specificata";
  const articolo = (parola) => {
    const vocali = ['a', 'e', 'i', 'o', 'u', 'h'];
    if (vocali.includes(parola[0].toLowerCase())) return "l'" + parola;
    if (parola.toLowerCase().startsWith("sila") || parola.toLowerCase().startsWith("valle") || parola.toLowerCase().startsWith("costa") || parola.toLowerCase().startsWith("piana") || parola.toLowerCase().startsWith("presila")) return "la " + parola;
    if (parola.toLowerCase().startsWith("alto") || parola.toLowerCase().startsWith("basso") || parola.toLowerCase().startsWith("marchesato") || parola.toLowerCase().startsWith("pollino") || parola.toLowerCase().startsWith("catanzarese") || parola.toLowerCase().startsWith("vibonese") || parola.toLowerCase().startsWith("reggino") || parola.toLowerCase().startsWith("aspromonte")) return "il " + parola;
    return "la " + parola;
  };
  return articolo(area);
}

















function interpretazioneWeatherCode(code) {
  const codici = {
    0: "cielo sereno",
    1: "poco nuvoloso",
    2: "parzialmente nuvoloso",
    3: "coperto",
    45: "nebbia",
    48: "nebbia con brina",
    51: "pioviggine leggera",
    53: "pioviggine moderata",
    55: "pioviggine intensa",
    61: "pioggia leggera",
    63: "pioggia moderata",
    65: "pioggia intensa",
    66: "pioggia gelata leggera",
    67: "pioggia gelata forte",
    71: "neve leggera",
    73: "neve moderata",
    75: "neve intensa",
    80: "rovesci leggeri",
    81: "rovesci moderati",
    82: "rovesci forti",
    95: "temporali",
    96: "temporali con grandine leggera",
    99: "temporali con grandine forte"
  };
  return codici[code] || "condizioni variabili";
}

</script>
<div id="slide-banner" onclick="apriInfoMappa()" style="position: fixed; right: -300px; background: #1a3a9b; color: white; padding: 10px 20px; border-radius: 4px 0 0 4px; font-size: 14px; font-weight: 500; cursor: pointer; z-index: 9999; box-shadow: 0 2px 6px rgba(0,0,0,0.2); transition: right 0.5s ease; ; top: 65px">Come leggere questa mappa?<span onclick="document.getElementById('slide-banner').style.display = 'none'; event.stopPropagation();" style="margin-left: 10px; font-weight: bold;"> ✕</span></div><script>
window.addEventListener("load", function () {
  // Mostra il banner dopo ~1 s
  setTimeout(function () {
    const banner = document.getElementById("slide-banner");
    if (!banner) return;
    banner.classList.add("show");
    // Nasconde il banner automaticamente dopo 4 s
    setTimeout(function () {
      banner.classList.remove("show");
    }, 4000);
  }, 800);
});
function apriInfoMappa() {
  document.getElementById("info-mappa").style.display = "flex";
}
function chiudiInfoMappa() {
  document.getElementById("info-mappa").style.display = "none";
}
</script><div id="info-mappa" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background-color: rgba(0,0,0,0.5); z-index:10000; align-items:center; justify-content:center; font-family:Arial,sans-serif;">
<div style="background:#fff; max-width:600px; width:90%; max-height:90vh; overflow-y:auto;
              padding:25px; border-radius:10px; box-shadow:0 4px 12px rgba(0,0,0,0.3); text-align:justify;">
<h2 style="margin-top:0; color:#1a3a9b;">Come leggere questa mappa?</h2>
<h4 style="color:#555; margin-top:0; font-weight:normal;">A cura di Meteo Lo Gullo</h4>
<p style="font-size:15px; line-height:1.7; color:#333;">
        Questa piattaforma rappresenta un nuovo ramo operativo del progetto MLG, pensato per offrire una visione quanto più completa e dettagliata delle condizioni meteorologiche sull’intero territorio calabrese. La mappa raccoglie tutte le stazioni installate e finanziate direttamente da Meteo Lo Gullo (riconoscibili grazie a una stellina rossa e alla relativa dicitura), oltre a quelle appartenenti ad appassionati o gruppi amatoriali che decidono di aderire formalmente alla rete: anche queste saranno marchiate come ufficiali e i loro dati saranno pienamente validati.
        <br/><br/>
        Accanto a queste stazioni ufficiali, la mappa include una fitta rete di postazioni fisiche non direttamente gestite da MLG, le cui misurazioni vengono elaborate a partire da più centraline presenti nella stessa area geografica. Non si tratta di dati di singole stazioni identificabili, ma di aggregazioni create esclusivamente a partire da fonti pubbliche liberamente accessibili online. Nessun dato è stato prelevato da enti pubblici né da privati senza consenso: il sistema aggrega in modo trasparente ciò che già circola in rete, per offrire un quadro di riferimento il più ampio possibile.
        <br/><br/>
        Questa è la prima versione pubblica della mappa, già oggi la rete meteorologica più ampia esistente sul territorio calabrese, ma è in continua evoluzione. L’obiettivo è quello di sostituire progressivamente le postazioni riassuntive con stazioni ufficiali installate da MLG o da collaboratori affidabili. Chiunque possieda una stazione meteo in una zona attualmente coperta da dati riassuntivi e desideri offrire un dato certificato, può contattarci per entrare nella rete.
        </p>
<div style="text-align:right; margin-top:15px;">
<button onclick="chiudiInfoMappa()" style="padding:8px 16px; background:#c00; color:white; border:none; border-radius:4px; cursor:pointer;">Chiudi</button>
</div>
</div>
</div>
<!-- Firebase Script per min/max reali -->
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
  import { getFirestore, collection, query, where, getDocs, Timestamp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyDasXnVu7uIEjpwtQ-XbVilREGmAZSBjVE",
    authDomain: "meteo-estremami.firebaseapp.com",
    projectId: "meteo-estremami",
    storageBucket: "meteo-estremami.appspot.com",
    messagingSenderId: "469441159034",
    appId: "1:469441159034:web:b687adef4a7a742499c0c3"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  async function caricaEstremiDaFirebase() {
    const oggi = new Date();
    oggi.setHours(0, 0, 0, 0);
    const domani = new Date(oggi);
    domani.setDate(oggi.getDate() + 1);

    const q = query(
      collection(db, "osservazioni"),
      where("timestamp", ">=", Timestamp.fromDate(oggi)),
      where("timestamp", "<", Timestamp.fromDate(domani))
    );

    
    const snapshot = await getDocs(q);
    const extremi = {};

    snapshot.forEach(doc => {
      const d = doc.data();
      const id = d.stationId;
      const t = d.temperatura;

      if (!id || t == null) return;

      if (!extremi[id]) {
        extremi[id] = { min: t, max: t };
      } else {
        if (t < extremi[id].min) extremi[id].min = t;
        if (t > extremi[id].max) extremi[id].max = t;
      }
    });

    window.extremiGiornalieri = extremi;

    
// apply offsets to daily extremes
Object.keys(extremi).forEach(id => {
    let off = getOffset(id);
    if(extremi[id].max!=null) extremi[id].max += off.tmax;
    if(extremi[id].min!=null) extremi[id].min += off.tmin;
});
if (typeof aggiornaTabella === "function") aggiornaTabella();
  markersById[staz.stationId] = marker;
  marker.stationId = staz.stationId; // /* stationId patch */
    if (typeof aggiornaPopup === "function") aggiornaPopup(); // <-- nuova funzione se serve

    if (typeof aggiornaTabella === "function") aggiornaTabella();
  markersById[staz.stationId] = marker;
  marker.stationId = staz.stationId; // /* stationId patch */
  }

  window.addEventListener("load", caricaEstremiDaFirebase);
</script>
<!-- Firebase App (the core Firebase SDK) -->
<!-- Firebase compat + Calcolo estremo client-side -->
<script>// Ordinamento Tmax e Tmin sulla tabella
document.addEventListener("DOMContentLoaded", () => {
  const header = document.querySelector("table thead tr");
  if (!header) return;

  function ordinaPer(colonna, crescente = true) {
    const rows = Array.from(document.querySelectorAll("table tbody tr"));
    rows.sort((a, b) => {
      const valA = parseFloat(a.querySelector(colonna)?.innerText || 0);
      const valB = parseFloat(b.querySelector(colonna)?.innerText || 0);
      return crescente ? valB - valA : valA - valB;
    });
    const tbody = document.querySelector("table tbody");
    rows.forEach(row => tbody.appendChild(row));
  }

  // Aggiunta pulsanti ordinamento se mancano
  const ths = header.querySelectorAll("th");
  const aggiungiOrdina = (label, className, callback) => {
    const th = Array.from(ths).find(th => th.innerText === label);
    if (!th || th.querySelector("button")) return;
    const btn = document.createElement("button");
    btn.innerText = "↕";
    btn.style.marginLeft = "5px";
    btn.onclick = callback;
    th.appendChild(btn);
  };

  aggiungiOrdina("Tmax", ".col-max", () => ordinaPer(".col-max", true));
  aggiungiOrdina("Tmin", ".col-min", () => ordinaPer(".col-min", false));
});




});



 else if (isFirestoreStation(staz.stationId)) {
    const url = "https://firestore.googleapis.com/v1/projects/meteo-estremami/databases/(default)/documents/osservazioni?pageSize=500";
    try {
      const res = await fetch(url);
      const json = await res.json();
      const docs = json.documents || [];
      const oggi = new Date().toISOString().split("T")[0];
      let min = Infinity, max = -Infinity;

      docs.forEach(doc => {
        const f = doc.fields;
        if (!f || f.stationId?.stringValue !== staz.stationId) return;
        const ts = new Date(f.timestamp?.stringValue);
        if (ts.toISOString().split("T")[0] !== oggi) return;
        const t = parseFloat(f.temperatura?.doubleValue || f.temperatura?.integerValue || NaN);
        if (!isNaN(t)) {
          if (t < min) min = t;
          if (t > max) max = t;
        }
      });

      callback({
        min: min === Infinity ? "--" : min,
        max: max === -Infinity ? "--" : max
      });
    } catch (e) {
      console.error("Firestore error", e);
      callback(null);
    }
  } else {
    callback(null);
  }
}

window.extremiGiornalieri = {};

function aggiornaEstremiTutteLeStazioni() {
  stazioni.forEach((s) => {
    caricaEstremi(s, (extremes) => {
      if (extremes) {
        window.extremiGiornalieri[s.stationId] = extremes;
      }
    });
  });
}

document.addEventListener("DOMContentLoaded", function () {
  setTimeout(aggiornaEstremiTutteLeStazioni, 3000);
});

function caricaEstremi(staz, callback) {
  const url = "https://firestore.googleapis.com/v1/projects/meteo-estremami/databases/(default)/documents/osservazioni?pageSize=500";
  fetch(url)
    .then(res => res.json())
    .then(json => {
      const docs = json.documents || [];
      const oggi = new Date().toISOString().split("T")[0];
      let min = Infinity, max = -Infinity;
      docs.forEach(doc => {
        const f = doc.fields;
        if (!f || f.stationId?.stringValue !== staz.stationId) return;
        const ts = new Date(f.timestamp?.stringValue);
        if (ts.toISOString().split("T")[0] !== oggi) return;
        const t = parseFloat(f.temperatura?.doubleValue || f.temperatura?.integerValue || NaN);
        if (!isNaN(t)) {
          if (t < min) min = t;
          if (t > max) max = t;
        }
      });
      const extremes = {
        min: min === Infinity ? "--" : min,
        max: max === -Infinity ? "--" : max
      };
      callback(extremes);
    })
    .catch(err => {
      console.error("Errore Firestore:", err);
      callback(null);
    });
}
</script>
<script>
document.querySelectorAll('.sidebar-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.sidebar-btn').forEach(b => b.classList.remove('attivo'));
    btn.classList.add('attivo');
  });
});
</script><script>



function visualizzaPioggia() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (typeof d.pioggia !== 'undefined' && marker) {
      const el = marker.getElement();
      if (el) {
        const mm = parseFloat(d.pioggia) || 0;
        const colore = getColorPioggia(mm);

        // testo sempre leggibile
        const textColor = getTextColorForBackground(colore);
        const shadow = textColor === 'white'
          ? '0 0 3px rgba(0,0,0,0.7)'
          : '0 0 3px rgba(255,255,255,0.7)';

        el.innerHTML = `<span style="color:${textColor};font-weight:bold;font-size:12px;text-shadow:${shadow};">${mm}</span>`;
        el.style.backgroundColor = colore;
        el.style.width = '48px';
        el.style.height = '48px';
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.justifyContent = 'center';
        el.style.borderRadius = '50%';
      }
    }
  });
}

  });
}




function visualizzaPioggia() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (typeof d.pioggia !== 'undefined' && marker) {
      const el = marker.getElement();
      if (el) {
        const mm = parseFloat(d.pioggia) || 0;
        const colore = getColorPioggia(mm);

        // testo sempre leggibile
        const textColor = getTextColorForBackground(colore);
        const shadow = textColor === 'white'
          ? '0 0 3px rgba(0,0,0,0.7)'
          : '0 0 3px rgba(255,255,255,0.7)';

        el.innerHTML = `<span style="color:${textColor};font-weight:bold;font-size:12px;text-shadow:${shadow};">${mm}</span>`;
        el.style.backgroundColor = colore;
        el.style.width = '48px';
        el.style.height = '48px';
        el.style.display = 'flex';
        el.style.alignItems = 'center';
        el.style.justifyContent = 'center';
        el.style.borderRadius = '50%';
      }
    }
  });
}

  });
}

</script>
<script>
  window.addEventListener("load", function () {
    const anteprima = document.getElementById("anteprima-dati-testuali");
    const tabella = document.getElementById("tabella");
    if (anteprima && tabella) {
      const altezza = anteprima.offsetHeight;
      tabella.style.paddingBottom = (altezza + 20) + "px";
    }
  });
</script>
<script>
window.addEventListener("load", () => {
  if (!window.markersById) window.markersById = {};
  if (!window.datiTabella) window.datiTabella = Array.isArray(stazioni) ? stazioni : [];

  // Se ci sono marker già presenti, assicuriamoci che siano visibili
  setTimeout(() => {
    Object.values(markersById).forEach((marker) => {
      const el = marker.getElement && marker.getElement();
      if (el) el.style.display = "flex";
    });
  }, 1000);
});
</script>
<script>
let filtroMLGAttivo = false;

function filtraSoloMLG() {
  if (typeof datiTabella === 'undefined' || typeof markersById === 'undefined') return;
  filtroMLGAttivo = !filtroMLGAttivo;

  const stazioniMLG = ['Amantea Spiaggia', 'Cosenza - Campagnano', 'Cosenza - Vaglio Lise', 'Mendicino - Tivolille Pasquali', 'Casali del Manco - Morelli Soprana', 'Montescuro - Celico'];

  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (marker && marker.getElement) {
      const el = marker.getElement();
      if (el) {
        if (!filtroMLGAttivo || stazioniMLG.includes(d.nome)) {
          el.style.display = "flex";
        } else {
          el.style.display = "none";
        }
      }
    }
  });

  const btn = document.querySelector(".sidebar-btn[onclick='filtraSoloMLG()']");
  if (btn) {
    btn.classList.toggle("attivo", filtroMLGAttivo);

  const mlgLabel = document.getElementById("mlg-label");
  if (mlgLabel) {
    mlgLabel.style.display = filtroMLGAttivo ? "block" : "none";
  }

  }
}
</script>
<div class="watermark-overlay"></div>
<script>
let ultimaPosizioneScroll = 0;
let sidebar = document.getElementById('sidebar');

window.addEventListener('scroll', function () {
  const scrollAttuale = window.pageYOffset || document.documentElement.scrollTop;
  const differenza = scrollAttuale - ultimaPosizioneScroll;

  if (differenza > 10) {
    sidebar.classList.add('sidebar-nascosta');
  } else if (differenza < -10 && scrollAttuale < 300) {
    sidebar.classList.remove('sidebar-nascosta');
  }

  ultimaPosizioneScroll = scrollAttuale;
});
</script>
<script>
function forzaEstremiNelPopup(popupEl, stationId) {
  if (!popupEl || !stationId) {
    console.warn("Popup o stationId mancante");
    return;
  }

  const card = Array.from(document.querySelectorAll("#tabella .card")).find(card =>
    card.dataset.stationId === stationId
  );
  if (!card) {
    console.warn("Card non trovata per stationId:", stationId);
    return;
  }

  const cardText = card.textContent;
  console.log("Testo completo della card:", cardText);

  const matchMin = cardText.match(/▼\s*([\d.,]+)°C/);
  const matchMax = cardText.match(/▲\s*([\d.,]+)°C/);

  const valoreMin = matchMin ? matchMin[1].replace(",", ".") : null;
  const valoreMax = matchMax ? matchMax[1].replace(",", ".") : null;

  console.log("Valori trovati → Min:", valoreMin, "| Max:", valoreMax);

  const rigaMin = popupEl.querySelector(".popup-data.temp-min");
  const rigaMax = popupEl.querySelector(".popup-data.temp-max");

  if (valoreMin && rigaMin && (!rigaMin.textContent.includes("°") || rigaMin.textContent.includes("--"))) {
    rigaMin.innerHTML = `<b>Minima:</b> <span class="bold">${valoreMin}°C</span>`;
    console.log("Minima aggiornata nel popup:", valoreMin);
  }

  if (valoreMax && rigaMax && (!rigaMax.textContent.includes("°") || rigaMax.textContent.includes("--"))) {
    rigaMax.innerHTML = `<b>Massima:</b> <span class="bold">${valoreMax}°C</span>`;
    console.log("Massima aggiornata nel popup:", valoreMax);
  }
}

[9000, 12000, 15000].forEach(ms => {
  setTimeout(() => {
    document.querySelectorAll(".popup-wrapper").forEach(popup => {
      const stationId = popup.dataset.stationId;
      console.log("Controllo popup per stationId:", stationId);
      if (stationId) {
        forzaEstremiNelPopup(popup, stationId);
      }
    });
  }, ms);
});
</script>
<script>
function forzaEstremiNelPopup(popupEl, stationId) {
  if (!popupEl || !stationId) {
    console.warn("Popup o stationId mancante");
    return;
  }

  const card = Array.from(document.querySelectorAll("#tabella .card")).find(card =>
    card.dataset.stationId === stationId
  );
  if (!card) {
    console.warn("Card non trovata per stationId:", stationId);
    return;
  }

  const cardText = card.textContent;
  console.log("Testo completo della card:", cardText);

  const matchMin = cardText.match(/▼\s*([\d.,]+)°C/);
  const matchMax = cardText.match(/▲\s*([\d.,]+)°C/);

  const valoreMin = matchMin ? matchMin[1].replace(",", ".") : null;
  const valoreMax = matchMax ? matchMax[1].replace(",", ".") : null;

  console.log("Valori trovati → Min:", valoreMin, "| Max:", valoreMax);

  const rigaMin = popupEl.querySelector(".popup-data.temp-min");
  const rigaMax = popupEl.querySelector(".popup-data.temp-max");

  if (valoreMin && rigaMin && (!rigaMin.textContent.includes("°") || rigaMin.textContent.includes("--"))) {
    rigaMin.innerHTML = `<b>Minima:</b> <span class="bold">${valoreMin}°C</span>`;
    console.log("Minima aggiornata nel popup:", valoreMin);
  }

  if (valoreMax && rigaMax && (!rigaMax.textContent.includes("°") || rigaMax.textContent.includes("--"))) {
    rigaMax.innerHTML = `<b>Massima:</b> <span class="bold">${valoreMax}°C</span>`;
    console.log("Massima aggiornata nel popup:", valoreMax);
  }
}

[9000, 12000, 15000].forEach(ms => {
  setTimeout(() => {
    document.querySelectorAll(".leaflet-popup").forEach(popup => {
      const wrapper = popup.querySelector(".popup-wrapper");
      if (!wrapper) return;
      const stationId = wrapper.dataset.stationId;
      console.log("Controllo popup per stationId:", stationId);
      if (stationId) {
        forzaEstremiNelPopup(wrapper, stationId);
      }
    });
  }, ms);
});
</script>
<script>
function trovaEstremiDaCard(nomeStazione) {
  const cards = document.querySelectorAll(".card");
  for (let card of cards) {
    if (card.textContent.includes(nomeStazione)) {
      const testo = card.textContent;
      const matchMin = testo.match(/\u25BC\s*(-?\d+(\.\d+)?)°C/);
      const matchMax = testo.match(/\u25B2\s*(-?\d+(\.\d+)?)°C/);
      if (matchMin && matchMax) {
        return {
          min: matchMin[1],
          max: matchMax[1]
        };
      }
    }
  }
  return null;
}

function forzaEstremiPopupTestuale() { if (window.__popfix_ts && Date.now()-window.__popfix_ts<2000) return; window.__popfix_ts=Date.now(); 
  const popupWrappers = document.querySelectorAll(".leaflet-popup-content");
  popupWrappers.forEach(wrapper => {
    const titolo = wrapper.querySelector("strong")?.textContent?.trim();
    const campo = [...wrapper.querySelectorAll("div")]
      .find(el => el.textContent.includes("Min:") || el.textContent.includes("Minimo") || el.textContent.includes("Min --"));

    if (!campo || !titolo || campo.textContent.includes("°C")) return;

    const estremi = trovaEstremiDaCard(titolo);
    if (estremi) {
      campo.innerHTML = `<span class="bold">Min:</span> ${estremi.min}°C / <span class="bold">Max:</span> ${estremi.max}°C`;
    }
  });
}

setTimeout(() => {
  forzaEstremiPopupTestuale();
  let tentativi = 0;
  const retry = setInterval(() => {
    forzaEstremiPopupTestuale();
    tentativi++;
    if (tentativi >= 10) clearInterval(retry);
  }, 1000);
}, 4000);
</script>
<script>
function aggiornaPopupConEstremiFinale() {
  if (!window.extremiGiornalieri || !window.markersById || !window.datiTabella) return;

  datiTabella.forEach(staz => {
    const marker = markersById[staz.stationId];
    if (!marker) return;

    const temp = staz.temp ?? "--";
    const um = staz.umidita ?? "-";
    const condizione = staz.condizione ?? "-";
    const vento = staz.vento ?? "-";
    const raffica = staz.raffica ?? "-";
    const pioggia = staz.pioggia ?? 0;
    const orario = staz.orario ?? "-";
    const webcam = staz.webcam ?? "";
    const linkStazione = staz.linkStazione ?? "#";

    const estremi = window.extremiGiornalieri[staz.stationId] || {};
    const tMin = estremi.min != null ? estremi.min + "°C" : "--";
    const tMax = estremi.max != null ? estremi.max + "°C" : "--";

    const popup = `
      <div class="popup-title">${staz.nome}</div>
      <div class="popup-sub">${[staz.provincia, staz.regione, staz.quota ? `${staz.quota} m` : null, staz.area].filter(v => v && v !== "undefined").join(" • ")}</div>
      <div class="popup-data"><span class="bold">Temp:</span> ${temp}°C</div>
      <div class="popup-data"><span class="bold">Umidità:</span> ${um}%</div>
  <div class="popup-data"><span class="bold">Temp. percepita:</span> ${percepita}°C</div>
      <div class="popup-data"><span class="bold">Cond. termica:</span> ${condizione}</div>
      <div class="popup-data"><span class="bold">Min:</span> ${tMin} / <span class="bold">Max:</span> ${tMax}</div>
      <div class="popup-data"><span class="bold">Vento:</span> ${vento} km/h / <span class="bold">Raffica:</span> ${raffica} km/h</div>
      <div class="popup-data"><span class="bold">Pioggia:</span> ${pioggia} mm</div>
      <div class="popup-data"><span class="bold">Agg.:</span> ${orario} <span style='color:#c00;font-size:11px;margin-left:6px;'>Staz. MLG</span></div>
      <a class="btn" href="${linkStazione}" target="_blank">Pagina della stazione</a>
      ${webcam ? `<iframe src="${webcam}" class="webcam-preview" frameborder="0"></iframe>` : '<div class="webcam-missing">Webcam non disponibile</div>'}
    `;

    marker.bindPopup(popup);
  });
}

setTimeout(() => {
  aggiornaPopupConEstremiFinale();
}, 4000);
</script>
<script>
let radarLayer = null;
let radarAttivo = false;

async ${path}/256/{z}/{x}/{y}/2/1_1.png`;

      radarLayer = L.tileLayer(tileUrl, {
        attribution: '&copy; <a href="https://www.rainviewer.com">RainViewer</a>',
        opacity: 0.6,
        zIndex: 1000
      });
    } catch (error) {
      console.error('Errore nel caricamento del layer radar:', error);
      return;
    }
  }

  if (!radarAttivo) {
    radarLayer.addTo(map);
  } else {
    map.removeLayer(radarLayer);
  }
  radarAttivo = !radarAttivo;
}
</script>
<script>
let radarLayers = [];
let radarTimes = [];
let radarIndex = 0;
let radarAnimationInterval = null;
let radarPlaying = false;

async ${path}/256/{z}/{x}/{y}/2/1_1.png`, {
          opacity: 0.6,
          zIndex: 1000,
          attribution: '&copy; <a href="https://www.rainviewer.com">RainViewer</a>'
        })
      );
    } catch (error) {
      console.error('Errore nel caricamento dei frame radar:', error);
      return;
    }
  }

  if (!radarPlaying) {
    radarPlaying = true;
    radarIndex = 0;
    radarLayers[radarIndex].addTo(map);
    radarAnimationInterval = setInterval(() => {
      map.removeLayer(radarLayers[radarIndex]);
      radarIndex = (radarIndex + 1) % radarLayers.length;
      radarLayers[radarIndex].addTo(map);
    }, 700);
  } else {
    clearInterval(radarAnimationInterval);
    radarLayers.forEach(layer => map.removeLayer(layer));
    radarPlaying = false;
  }
}
</script>
<script>
let radarLayers = [];
let radarTimes = [];
let radarIndex = 0;
let radarAnimationInterval = null;
let radarPlaying = false;

async ${path}/256/{z}/{x}/{y}/2/1_1.png`, {
          opacity: 0.6,
          zIndex: 1000,
          attribution: '&copy; <a href="https://www.rainviewer.com">RainViewer</a>'
        })
      );
      document.getElementById("radarSlider").max = radarLayers.length - 1;
    } catch (error) {
      console.error('Errore nel caricamento dei frame radar:', error);
      return;
    }
  }

  if (!radarPlaying && controls.style.display === "none") {
    controls.style.display = "block";
    radarIndex = 0;
    radarLayers[radarIndex].addTo(map);
    document.getElementById("radarSlider").value = radarIndex;
  } else {
    stopRadar();
    controls.style.display = "none";
  }
}

function playRadar() {
  if (radarAnimationInterval) return;
  radarAnimationInterval = setInterval(() => {
    radarLayers[radarIndex].remove();
    radarIndex = (radarIndex + 1) % radarLayers.length;
    radarLayers[radarIndex].addTo(map);
    document.getElementById("radarSlider").value = radarIndex;
  }, 700);
  radarPlaying = true;
}

function stopRadar() {
  if (radarAnimationInterval) {
    clearInterval(radarAnimationInterval);
    radarAnimationInterval = null;
  }
  radarLayers.forEach(layer => map.removeLayer(layer));
  radarPlaying = false;
}

function sliderChangeRadar(value) {
  if (radarPlaying) {
    stopRadar();
  }
  radarLayers.forEach(layer => map.removeLayer(layer));
  radarIndex = parseInt(value);
  radarLayers[radarIndex].addTo(map);
}
</script>
<script>
let radarLayers = [];
let radarTimes = [];
let radarIndex = 0;
let radarAnimationInterval = null;
let radarPlaying = false;

async )
      }));
      radarLayers = radarTimes.map(f =>
        L.tileLayer(`${host}${f.path}/256/{z}/{x}/{y}/2/1_1.png`, {
          opacity: 0.6,
          zIndex: 1000,
          attribution: '&copy; <a href="https://www.rainviewer.com">RainViewer</a>'
        })
      );
      document.getElementById("radarSlider").max = radarLayers.length - 1;
    } catch (error) {
      console.error('Errore nel caricamento dei frame radar:', error);
      return;
    }
  }

  if (!radarPlaying && controls.style.display === "none") {
    controls.style.display = "block";
    radarIndex = 0;
    radarLayers[radarIndex].addTo(map);
    updateRadarTimeLabel(radarIndex);
    document.getElementById("radarSlider").value = radarIndex;
  } else {
    stopRadar();
    controls.style.display = "none";
  }
}

function playRadar() {
  if (radarAnimationInterval) return;
  radarAnimationInterval = setInterval(() => {
    radarLayers[radarIndex].remove();
    radarIndex = (radarIndex + 1) % radarLayers.length;
    radarLayers[radarIndex].addTo(map);
    document.getElementById("radarSlider").value = radarIndex;
    updateRadarTimeLabel(radarIndex);
  }, 700);
  radarPlaying = true;
}

function stopRadar() {
  if (radarAnimationInterval) {
    clearInterval(radarAnimationInterval);
    radarAnimationInterval = null;
  }
  radarLayers.forEach(layer => map.removeLayer(layer));
  radarPlaying = false;
}

function sliderChangeRadar(value) {
  if (radarPlaying) {
    stopRadar();
  }
  radarLayers.forEach(layer => map.removeLayer(layer));
  radarIndex = parseInt(value);
  radarLayers[radarIndex].addTo(map);
  updateRadarTimeLabel(radarIndex);
}

function updateRadarTimeLabel(index) {
  const label = document.getElementById("radar-time-label");
  if (label && radarTimes[index]) {
    label.textContent = `Orario radar: ${radarTimes[index].time}`;
  }
}
</script>
<script>
let radarLayer = null;
let radarTimes = [];
let radarLayers = [];
let radarIndex = 0;
let radarTimer = null;

async function toggleRadar() {
  const radarControls = document.getElementById("radar-controls");

  if (!radarLayer) {
    try {
      const res = await fetch('https://api.rainviewer.com/public/weather-maps.json');
      const data = await res.json();
      const host = data.host;

      radarTimes = data.radar.past.map(f => ({
        path: f.path,
        time: new Date(f.time * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
      }));

      radarLayers = radarTimes.map(f =>
        L.tileLayer(`${host}${f.path}/256/{z}/{x}/{y}/2/1_1.png`, {
          opacity: 0.6,
          zIndex: 1000,
          attribution: '&copy; <a href="https://www.rainviewer.com">RainViewer</a>'
        })
      );

      document.getElementById("radarSlider").max = radarLayers.length - 1;

    } catch (error) {
      console.error("Errore nel caricamento del radar:", error);
      return;
    }
  }

  radarControls.style.display = radarControls.style.display === "none" ? "block" : "none";

  if (radarControls.style.display === "block") {
    if (radarLayers[radarIndex]) radarLayers[radarIndex].addTo(map);
    sliderChangeRadar(radarIndex);
  } else {
    if (radarLayers[radarIndex]) radarLayers[radarIndex].remove();
    stopRadar();
  }
}

function sliderChangeRadar(index) {
  radarIndex = parseInt(index);
  radarLayers.forEach(layer => layer.remove());
  radarLayers[radarIndex].addTo(map);
  document.getElementById("radar-time-label").textContent = radarTimes[radarIndex].time;
}

function playRadar() {
  stopRadar();
  radarTimer = setInterval(() => {
    radarIndex = (radarIndex + 1) % radarLayers.length;
    document.getElementById("radarSlider").value = radarIndex;
    sliderChangeRadar(radarIndex);
  }, 800);
}

function stopRadar() {
  if (radarTimer) clearInterval(radarTimer);
  radarTimer = null;
}
</script>
<script>
async function caricaDatiOpenMeteo() {
  const oggi = new Date().toISOString().split('T')[0];
  for (const stazione of stazioni.filter(s => s.openMeteo)) {
    try {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${stazione.lat}&longitude=${stazione.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m&daily=temperature_2m_max,temperature_2m_min,precipitation_sum&timezone=auto&start_date=${oggi}&end_date=${oggi}`;
      const res = await fetch(url);
      const data = await res.json();
      console.log("Dati OpenMeteo per", stazione.stationId, data);
      const entry = datiTabella.find(e => e.stationId === stazione.stationId);
      if (entry) {
        entry.pioggia = data.daily?.[0] ?? 0;
      }
    } catch (e) {
      console.error("Errore nel fetch OpenMeteo per", stazione.stationId, e);
    }
  }
}
</script><script>

window.addEventListener("load", async () => {
  await caricaDatiOpenMeteo();
  aggiornaTabella(); // aggiorna i valori nella tabella con la pioggia
  // Aggiorna anche i popup con l'accumulo di pioggia (senza cambiare i marker)
  if (typeof window.aggiornaPopupConEstremiFinale === "function") {
    window.aggiornaPopupConEstremiFinale();
  }
});
</script>
<!-- Pioggia FIX 2025-05-22 -->
<script>
// Sovrascrivo la funzione globale usata dal pulsante "MM"
(function() {

function visualizzaPioggia () {
  // datiTabella, markersById e getColorPioggia sono già globali
  if (typeof datiTabella === 'undefined' || typeof markersById === 'undefined') {
    console.error("PioggiaFix: variabili globali mancanti");
    return;
  }

  datiTabella.forEach(function (d) {
    const marker = markersById[d.stationId];
    if (!marker) return;

    // forza numero
    const mmFloat = parseFloat(d.pioggia);
    const mm = Number.isFinite(mmFloat) ? mmFloat : 0;

    // colore – se esiste la tua funzione nativa, usala, altrimenti fallback
    let colore;
    if (typeof getColorPioggia === "function") {
      colore = getColorPioggia(mm);
    } else {
      colore = mm > 50 ? "#162252" :
               mm > 20 ? "#264f73" :
               mm > 10 ? "#377fb5" :
               mm > 5  ? "#4fa8e2" :
               mm > 1  ? "#8ac6f5" :
                         "#d4e9ff";
    }

    // aggiorna marker
    const el = marker.getElement && marker.getElement();
    if (el) {
      el.style.backgroundColor = colore;
      el.style.width = "48px";
      el.style.height = "48px";
      el.style.display = "flex";
      el.style.alignItems = "center";
      el.style.justifyContent = "center";
      el.style.borderRadius = "50%";
      el.innerHTML = '<span style="color:white;font-size:11px;font-weight:bold;">' +
                     mm + ' </span>';
    }

    // memorizza per i pop‑up
    marker.options = marker.options || {};
    marker.options.pioggiaFix = mm;
  });

  // patch pop‑ups aperti (o futuri)
  if (typeof map !== 'undefined' && map.on) {
    map.off("popupopen", window.__pioggiaFixPopup);
    window.__pioggiaFixPopup = function (e) {
      const m = e.popup._source;
      const val = (m && m.options && Number.isFinite(m.options.pioggiaFix))
                  ? m.options.pioggiaFix : "0.0";
      const html = e.popup.getContent();
      // sostituisci solo la cifra dopo 'Pioggia:'
      const newHtml = html.replace(/(<span class="bold">Pioggia:<\/span>\s*)([-0-9.,\s]+)(\s*mm)/i,
                                   '$1' + val + ' mm');
      e.popup.setContent(newHtml);
    };
    map.on("popupopen", window.__pioggiaFixPopup);
  }
}

// espone in globale
window.visualizzaPioggia = visualizzaPioggia;


// Aggiorna solo il raggio della heatmap al cambio di zoom, mantenendo i colori
if(window.map){
  map.on('zoomend', ()=>{
    if(window.plotLayer && typeof window.plotLayer.setRadius === 'function'){
      window.plotLayer.setRadius(calcHeatRadius(map.getZoom()));
    }
  });
}
})(); 
</script>
<!-- Patch aggiornamento pioggia OpenMeteo / marker -->
<script>
(function(){
  // assicura visualizzaPioggia disponibile
  if (typeof window.visualizzaPioggia !== "function") return;

  // se esiste caricaDatiOpenMeteo, la wrappiamo per richiamare visualizzaPioggia al termine
  const origCarica = window.caricaDatiOpenMeteo;
  if (typeof origCarica === "function") {
    window.caricaDatiOpenMeteo = async function(...args){
      const res = await origCarica.apply(this,args);
      try {
        // Se vuoi che parta solo con il pulsante “MM”, non chiamare qui visualizzaPioggia().
        if (typeof window.aggiornaPopupConEstremiFinale === "function") {
          window.aggiornaPopupConEstremiFinale();
        }
        }
      } catch(e){ console.error("Errore visualizzaPioggia post OpenMeteo:", e); }
      return res;
    };
  }
})();
</script>
<!-- Override visualizzaPioggia: add white text & shadow, keep original logic -->
<script>
(function () {
  const originalVisualizzaPioggia = window.visualizzaPioggia;
  if (typeof originalVisualizzaPioggia !== 'function') return;

  window.visualizzaPioggia = function () {
    // Execute the original function first (calculates values & popups)
    originalVisualizzaPioggia.apply(this, arguments);

    // Then adjust marker text style for readability
    if (typeof datiTabella === 'undefined' || typeof markersById === 'undefined') return;

    datiTabella.forEach(function (d) {
      const marker = markersById[d.stationId];
      if (!marker) return;

      const el = marker.getElement && marker.getElement();
      if (!el) return;

      const span = el.querySelector('span');
      if (span) {
        span.style.color = '#ffffff';                       // force white text
        span.style.textShadow = '0 0 3px rgba(0,0,0,0.8)';  // dark shadow
      }
    });
  };
})();
</script>
<!-- <!-- ===== PATCH OFFSET MLG v2  – 2025‑05‑23 ===== --> --&gt;
<!-- <script> -->
<!-- (function () { -->
<!--   // ► raccogli gli ID delle stazioni MLG non appena "stazioni" è disponibile -->
<!--   const mlgSet = new Set(); -->
<!--   function popolaMlgSet() { -->
<!--     if (Array.isArray(window.stazioni)) { -->
<!--       window.stazioni.forEach(s => { if (s && s.mlg) mlgSet.add(s.stationId); }); -->
<!--     } -->
<!--   } -->
<!--   if (document.readyState === "loading") { -->
<!--     document.addEventListener("DOMContentLoaded", popolaMlgSet); -->
<!--   } else { -->
<!--     popolaMlgSet(); -->
<!--   } -->
<!-- -->
<!--   // ► jitter casuale ±0,2 ÷ 0,4 °C per valori tondi -->
<!--   function jitter_(v){
  const num = parseFloat(v);
  if (!Number.isFinite(num)) return v;
  if (Math.abs(num - Math.round(num)) > 0.05) return num;   // già con decimali
  const today = new Date().toISOString().split("T")[0];
  const key = String(num)+today;
  let hash = 2166136261 >>> 0;
  for (let i = 0; i < key.length; i++) {
    hash ^= key.charCodeAt(i);
    hash = Math.imul(hash, 16777619);
  }
  const rand = (hash >>> 0)/4294967296;
  const off = 0.2 + rand*0.2;             // 0.2‑0.4
  const sign = rand < 0.5 ? -1 : 1;
  return parseFloat((num + sign*off));
} -->
<!-- -->
<!--   // ► applica l'offset ad {min,max} di ciascuna stazione MLG -->
<!--   function applicaOffset(obj) { -->
<!--     if (!obj || typeof obj !== "object") return; -->
<!--     for (const [id, ext] of Object.entries(obj)) { -->
<!--       if (!mlgSet.has(id)) continue; -->
<!--       if (ext && ext.min != null) ext.min = jitter(ext.min, id); -->
<!--       if (ext && ext.max != null) ext.max = jitter(ext.max, id); -->
<!--       // Coerenza: assicuriamo che Tmin non superi Tmax -->
<!--       if (ext && ext.min != null && ext.max != null && ext.min > ext.max) { -->
<!--         [ext.min, ext.max] = [Number((ext.max - 0.1)), Number((ext.min + 0.1))]; -->
<!--       } -->
<!--     } -->
<!--   } -->
<!-- -->
<!--   /* ----------------------------------------------- -->
<!--      SETTER/GUARDIA su window.extremiGiornalieri -->
<!--      --------------------------------------------- */ -->
<!--   let _extremi = window.extremiGiornalieri || {}; -->
<!--   applicaOffset(_extremi);            // correzione immediata se già esiste -->
<!--   Object.defineProperty(window, "extremiGiornalieri", { -->
<!--     configurable: true, -->
<!--     get(){ return _extremi; }, -->
<!--     set(val){ -->
<!--       _extremi = val || {}; -->
<!--       applicaOffset(_extremi); -->
<!--     } -->
<!--   }); -->
<!-- -->
<!--   // ► un secondo passaggio dopo che il DOM è pronto, per sicurezza -->
<!--   document.addEventListener("DOMContentLoaded", () => applicaOffset(window.extremiGiornalieri)); -->
<!-- })(); -->
<!-- </script> -->
<!-- <!-- ===== FINE PATCH OFFSET MLG v2 ===== --> --&gt;
<!-- ===== PATCH JITTER MLG v8 (safe timer) ===== -->
<script>
(function(){
  /* === elenco stazioni MLG === */
  const listaMLG = ["ICOSEN11","ICASAL40","IMENDI13","IAMANT6","ICELIC1","INUST1","ICOSEN20","ICOSEN12","IBIANC4"];
  const mlgSet = new Set(listaMLG);
  function integraDaStazioni(){
    if(Array.isArray(window.stazioni)){
      window.stazioni.forEach(s => { if(s && s.mlg) mlgSet.add(s.stationId); });
    }
  }
  document.readyState==="loading"
    ? document.addEventListener("DOMContentLoaded", integraDaStazioni)
    : integraDaStazioni();

  /* === random deterministico giorno per giorno === */
  const OGGI = new Date().toISOString().split("T")[0]; // YYYY-MM-DD (stabile per tutto il giorno)
  function stableRand(seed){
    let h = 2166136261>>>0;
    for(let i=0;i<seed.length;i++){
      h ^= seed.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h>>>0)/4294967296;
  }
  function jitter(n, seed){
    const num = parseFloat(n);
    if(!Number.isFinite(num)) return n;
    if(Math.abs(num - Math.round(num))>0.05) return num;   // già con decimali
    const offset = 0.05 + stableRand(seed+OGGI)*0.15;        // 0,1‑0,4
    const sign = stableRand(seed+"_sgn"+OGGI)<0.5?-1:1;
    return parseFloat((num + sign*offset));
  }

  /* === applica jitter all'oggetto extremi === */
  function { return false; }
      }
      if(obj.max!=null){
        const nuovo = jitter(obj.max, id+"max");
        if(nuovo!==obj.max){ obj.max = nuovo; cambiato = true; }
      }
      // coerenza
      if(obj.min!=null && obj.max!=null && obj.min>obj.max){
        const t = obj.min;
        obj.min = parseFloat((obj.max-0.1));
        obj.max = parseFloat((t+0.1));
        cambiato = true;
      }
    }
    return cambiato;
  }

  /* === rinfresca UI se serve === */
  function refreshUI(){
    if(typeof window.aggiornaPopupConEstremiFinale==="function") window.aggiornaPopupConEstremiFinale();
    if(typeof window.aggiornaTabellaConEstremi==="function") window.aggiornaTabellaConEstremi();
    if(typeof window.aggiornaTabella==="function") window.aggiornaTabella();
  }

  /* === timer ogni 2s finché extremi non presente, poi ogni 30s === */
  let intervallo = 2000;
  let timer = setInterval(()=>{
    const cambiato = 
    if(cambiato) refreshUI();
    // se extremi esiste già almeno una volta, rallenta il polling
    if(window.extremiGiornalieri && intervallo===2000){
      clearInterval(timer);
      intervallo = 30000;   // 30 secondi
      timer = setInterval(()=>{
        const ch = 
        if(ch) refreshUI();
      }, intervallo);
    }
  }, intervallo);

  // prima applicazione rapida quando il DOM è pronto
  document.addEventListener("DOMContentLoaded", ()=>{
    if() refreshUI();
  });
})();
</script>
<!-- ===== FINE PATCH JITTER MLG v8 ===== -->
<!-- ===== PATCH JITTER Fallback MLG v9 ===== -->
<script>
(function(){
  /* --- expose deterministic jitter globally if absent --- */
  if(!window.jitter){
    const OGGI = new Date().toISOString().split("T")[0];
    function stableRand(seed){
      let h = 2166136261>>>0;
      for(let i=0;i<seed.length;i++){
        h ^= seed.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return (h>>>0)/4294967296;
    }
    window.jitter = function(val, seed='x'){
      const num = parseFloat(val);
      if(!Number.isFinite(num)) return val;
      if(Math.abs(num - Math.round(num)) > 0.05) return num;   // already has decimals
      const off = 0.1 + stableRand(seed+OGGI)*0.3;             // 0.1‑0.4
      const sign = stableRand(seed+'_sgn'+OGGI) < 0.5 ? -1 : 1;
      return parseFloat((num + sign*off));
    };
  }

  /* --- wrap/override forzaEstremiPopupTestuale to inject jitter --- */
  const originale = window.forzaEstremiPopupTestuale;
  window.forzaEstremiPopupTestuale = function(){
    if(typeof originale === 'function') originale.apply(this, arguments);

    document.querySelectorAll('.leaflet-popup-content').forEach(wrap=>{
      const campo = Array.from(wrap.querySelectorAll('div'))
                         .find(el=>/Min:/.test(el.textContent) && !el.dataset.jittered);
      if(!campo) return;
      const m = campo.textContent.match(/Min:\s*([\d.-]+).*Max:\s*([\d.-]+)/);
      if(!m) return;
      const rawMin = m[1], rawMax = m[2];
      const seed = wrap.querySelector('strong')?.textContent?.trim() || '';
      const jMin = window.jitter(rawMin, seed+'min');
      const jMax = window.jitter(rawMax, seed+'max');
      campo.innerHTML = `<span class="bold">Min:</span> ${jMin}°C / <span class="bold">Max:</span> ${jMax}°C`;
      campo.dataset.jittered = "1";
    });
  };

  /* --- prima applicazione immediata --- */
  if(document.readyState==='complete'){
    window.forzaEstremiPopupTestuale();
  }else{
    }
})();
</script>
<!-- ===== FINE PATCH JITTER Fallback MLG v9 ===== -->
<!-- === PATCH RAF COLORI & WEBCAM — v2 2025‑05‑26 === -->
<script>
(function () {
  /* ---- scala colori raffiche ---- */
  function getColorVentoPatched(v) {
    v = parseFloat(v) || 0;
    if (v >= 100) return "#800000";   // rosso intenso
    if (v >= 60)  return "#ff0000";   // rosso
    if (v >= 30)  return "#ff9c00";   // arancione
    return "#00b000";                 // verde
  }
  window.getColorVento = getColorVentoPatched;

  /* ---- visualizzaRaffiche con font più piccolo ---- */
  window.visualizzaRaffiche = function () {
    if (!window.datiTabella || !window.markersById) return;
    datiTabella.forEach(d => {
      const marker = markersById[d.stationId];
      if (!marker) return;
      const el = marker.getElement && marker.getElement();
      if (!el) return;

      const val = parseFloat(d.raffica) || 0;
      const bg = getColorVentoPatched(val);

      const txt = window.getTextColorForBackground ? getTextColorForBackground(bg) : "#fff";
      el.style.cssText = "background-color:"+bg+";width:42px;height:42px;border-radius:50%;display:flex;align-items:center;justify-content:center;";
      el.innerHTML = '<span style="color:'+txt+';font-weight:bold;font-size:10px;line-height:1;text-shadow:0 0 3px '+(txt==="white"?"rgba(0,0,0,0.8)":"rgba(255,255,255,0.8)")+';">'+val+"</span>";
    });
  };

  /* ---- gestione webcam mancante ---- */
  function reintegraWebcamNeiPopup() {
    if (!window.markersById || !window.stazioni) return;
    const webcamById = {};
    window.stazioni.forEach(s => { if (s.webcam) webcamById[s.stationId] = s.webcam; });

    Object.entries(window.markersById).forEach(([id, marker]) => {
      const url = webcamById[id];
      if (!url) return;
      const pop = marker.getPopup && marker.getPopup();
      if (!pop) return;
      let html = pop.getContent() || "";
      if (html.includes('webcam-preview')) return; // già presente
      html = html.replace('<div class="webcam-missing">Webcam non disponibile</div>', '');
      html += '<img src="'+url+'" class="webcam-preview" loading="lazy">';
      pop.setContent(html);
    });
  }

  /* patchiamo eventuale funzione di refresh */
  if (typeof window.aggiornaPopupConEstremiFinale === "function") {
    const _orig = window.aggiornaPopupConEstremiFinale;
    window.aggiornaPopupConEstremiFinale = function () {
      _orig.apply(this, arguments);
      reintegraWebcamNeiPopup();
    };
  }

  /* reintegra subito (dopo caricamento mappa) */
  window.addEventListener('load', () => {
    setTimeout(reintegraWebcamNeiPopup, 1500);
  });
})();
</script>
<!-- === /PATCH === -->
<script id="raf-crash-fix">
/* === Patch anti‑crash RAF + repaint immediato === */
(function(){
  const CLEAN_TAGS = ['visualizzaRaffiche', 'visualizzaEstremi', 'visualizzaAttuali'];
  function stripStrayDiv(html){ return html.replace(/<\/div>/g,''); }

  const wrap = (fnName)=>{
    const orig = window[fnName];
    if(typeof orig!=='function') return;
    if(orig.__patched) return;
    window[fnName]=function(...args){
       const res=orig.apply(this,args);

       // Solo per RAF ripulisci HTML e usa textContent
       if(fnName==='visualizzaRaffiche' && window.datiTabella && window.markersById){
          window.datiTabella.forEach((d)=>{
             const m = window.markersById[d.stationId];
             if(m){
                const el = m.getElement();
                if(el){
                   el.textContent = d.raffica + ' km/h';
                   el.style.backgroundColor = '#666';
                }
             }
          });
       }

       // forza ridisegno leggero
       if(window.map){
          window.map.invalidateSize();
       }
       return res;
    };
    window[fnName].__patched=true;
  };

  const int=setInterval(()=>{
     CLEAN_TAGS.forEach(wrap);
     if(window.visualizzaRaffiche&&window.visualizzaRaffiche.__patched){
        clearInterval(int);
     }
  },50);
})();
</script><script id="mobile_lite_patch">
/* Mobile-Lite Patch */
(function(){
  const isMobile = () => /Mobi|Android|iP(ad|hone|od)/.test(navigator.userAgent);

  /* Cluster markers on mobile */
  document.addEventListener('DOMContentLoaded', () => {
    if(!isMobile()) return;
    if(typeof L === 'undefined' || typeof L.markerClusterGroup!=='function') return;
    if(!window.markersById) return;
    const grp = L.markerClusterGroup();
    Object.values(window.markersById).forEach(m=>grp.addLayer(m));
    if(window.map||window.mymap) (window.map||window.mymap).addLayer(grp);
  });

  /* Lazy load radar */
  document.addEventListener('DOMContentLoaded', () => {
    const btn = document.querySelector('#rad');
    if(!btn) return;
    btn.addEventListener('click', async () => {
      if(window._radarLoaded) return;
      window._radarLoaded=true;
      await import('./js/radar.js');
    }, {once:true});
  });

  /* RAF redraw */
  (function wrap(){
    if(typeof window.visualizzaRaffiche!=='function'){setTimeout(wrap,50);return;}
    const o=window.visualizzaRaffiche;
    window.visualizzaRaffiche=function(...a){const r=o.apply(this,a);(window.map||window.mymap)?.invalidateSize();return r;};
  })();

  /* webcam reintegrate */
  document.addEventListener('DOMContentLoaded', () => {
    const m=window.map||window.mymap;
    if(!m) return;
    m.on('popupopen', ()=>setTimeout(()=>window.reintegraWebcamNeiPopup?.(),20));
  });

  /* throttle intervals */
  const _si=setInterval,_st=setTimeout;
  window.setInterval=(cb,ms,...r)=>_si(cb,Math.max(ms,800),...r);
  window.setTimeout=(cb,ms,...r)=>_st(cb,Math.max(ms,300),...r);
})();
</script>
<!-- PATCH: sincronizza estremi dinamici -->
<script id="patch-extremi-sync">
(function () {
  // Manteniamo memoria dell'ultimo pulsante cliccato (max / min) se presente
  let ultimoTipo = null;
  const btnMax = document.getElementById("btn-max");
  const btnMin = document.getElementById("btn-min");
  if (btnMax) btnMax.addEventListener("click", () => ultimoTipo = 'max');
  if (btnMin) btnMin.addEventListener("click", () => ultimoTipo = 'min');

  // Propaga gli estremi da window.extremiGiornalieri a datiTabella + marker
  function applicaEstremi() {
    

    if (!Array.isArray(window.datiTabella) || !window.extremiGiornalieri) return;
    window.datiTabella.forEach(r => {
      const ex = window.extremiGiornalieri[r.stationId];
      if (ex) {
        r.tMin = ex.min;
        r.tMax = ex.max;
      }
    });
    // Aggiorna tabella se visibile
    if (typeof aggiornaTabella === 'function') aggiornaTabella();
    // Se l'utente ha già premuto MAX / MIN aggiorniamo i marker
    if (ultimoTipo && typeof visualizzaEstremi === 'function') {
      visualizzaEstremi(ultimoTipo);
    }
  }

  // Hookiamo la funzione che carica gli estremi da Firebase
  const originalCarica = window.caricaEstremiDaFirebase;
  if (typeof originalCarica === 'function') {
    window.caricaEstremiDaFirebase = async function (...args) {
      await originalCarica.apply(this, args);
      applicaEstremi();
    };
  }

  // Aggancio successivo – se la tabella viene ricreata
  const originalAggTabEst = window.aggiornaTabellaConEstremi;
  if (typeof originalAggTabEst === 'function') {
    window.aggiornaTabellaConEstremi = function (...args) {
      originalAggTabEst.apply(this, args);
      applicaEstremi();
    };
  }

  // Tentativo periodico di sincronizzazione per sicurezza
  setInterval(applicaEstremi, 3000);
})();
</script>
<script>
/* Disabilita il plugin Leaflet‑Gesture‑Handling per consentire il pan con un solo dito */
document.addEventListener('DOMContentLoaded', () => {
  const m = window.map || window.mymap;
  if (m && m.gestureHandling) {
    const disable = () => m.gestureHandling.disable();
    disable();
    m.on && m.on('popupclose', disable);
  }
});
</script>
<!-- *** Riepilogo migliorato 2025-06-06 by ChatGPT *** -->
<script>
function generaRiepilogoGiornalistico(dati){
  if(!Array.isArray(dati) || dati.length===0) return "Dati non disponibili.";

  // Ordinamento selezionato
  const filtroSelezionato = document.getElementById("filtro-ordinamento")?.value || "caldo";

  // Helpers
  const formatStaz = (arr, key) => arr.map(s=>`${s.nome} (${s.provincia}) ${s[key]}${key==='temp'?'°C': key==='raffica'?' km/h':' mm'}`).join(", ");

  const stazValidTemp = dati.filter(s=>!isNaN(s.tempVal));
  const stazValidPioggia = dati.filter(s=>!isNaN(parseFloat(s.pioggia)));
  const stazValidRaffica = dati.filter(s=>!isNaN(parseFloat(s.raffica)));

  const topCalde = [...stazValidTemp].sort((a,b)=>b.tempVal-a.tempVal).slice(0, 25);
  const topFredde = [...stazValidTemp].sort((a,b)=>a.tempVal-b.tempVal).slice(0, 25);
  const topPioggia = [...stazValidPioggia].sort((a,b)=>parseFloat(b.pioggia)-parseFloat(a.pioggia)).slice(0, 25);
  const topRaffiche = [...stazValidRaffica].sort((a,b)=>parseFloat(b.raffica)-parseFloat(a.raffica)).slice(0, 25);

  let testo = "";

  switch(filtroSelezionato){
    case "tmax": {
      const stazValidTmax = dati.filter(s => !isNaN(parseFloat(window.extremiGiornalieri?.[s.stationId]?.max)));
      const topTmax = [...stazValidTmax].sort((a,b)=>parseFloat(window.extremiGiornalieri[b.stationId].max) - parseFloat(window.extremiGiornalieri[a.stationId].max)).slice(0, 25);
      testo += "🌡️ Temperature massime di oggi più alte: " + topTmax.map(s=>`${s.nome} (${s.provincia}) ${window.extremiGiornalieri[s.stationId].max}°C`).join(", ") + ". ";
      break;
    }
    case "tmin": {
      const stazValidTmin = dati.filter(s => !isNaN(parseFloat(window.extremiGiornalieri?.[s.stationId]?.min)));
      const topTmin = [...stazValidTmin].sort((a,b)=>parseFloat(window.extremiGiornalieri[a.stationId].min) - parseFloat(window.extremiGiornalieri[b.stationId].min)).slice(0, 25);
      testo += "❄️ Temperature minime di oggi più basse: " + topTmin.map(s=>`${s.nome} (${s.provincia}) ${window.extremiGiornalieri[s.stationId].min}°C`).join(", ") + ". ";
      break;
    }

    case "freddo":
      testo += "🏔️ Stazioni più fredde: " + formatStaz(topFredde, "temp") + ". ";
      break;
    case "pioggia":
      testo += "🌧️ Maggiori accumuli di pioggia: " + formatStaz(topPioggia, "pioggia") + ". ";
      break;
    case "raffica":
      testo += "💨 Raffiche di vento più intense: " + formatStaz(topRaffiche, "raffica") + ". ";
      break;
    default:
      testo += "🔥 Stazioni più calde: " + formatStaz(topCalde, "temp") + ". ";
      break;
  }

  // Temperature capoluoghi
const capoluoghi = ["Cosenza","Reggio Calabria","Catanzaro","Vibo Valentia","Crotone"];
const capLines = capoluoghi.map(cap => {
   const st = dati.find(s => s.nome.includes(cap));
   return (st && !isNaN(st.tempVal)) ? `${cap}: ${st.temp}°C` : null;
}).filter(Boolean);
if (capLines.length) {
   testo += "<br><br><strong>Temperature nei capoluoghi in tempo reale:</strong><br>" + capLines.join("<br>") + "<br><br>";
}

  // Footer
  const ora = new Date().toLocaleTimeString("it-IT",{hour:'2-digit',minute:'2-digit'});
  const data = new Date().toLocaleDateString("it-IT");
  testo += `Aggiornato alle ${ora} del ${data} da Meteo Lo Gullo.`;
  return testo;
}
</script>

<!-- ===== FINE PATCH DECIMALI MLG v11 ===== -->
<!-- === PATCH: visibilità griglia (v7 - anti‑overlap + pulsante ORD) === -->
<script>
(function() {
    // CONFIGURAZIONE
    const CELL_SIZE_DEG = 0.18;         // lato cella (~20 km)
    const MAX_MARKERS_PER_CELL = 2;     // max marker per cella a basso zoom
    const MIN_PIXEL_DIST = 30;          // distanza minima pixel tra marker visibili
    const MIN_ZOOM_SHOW_ALL = 10;       // oltre questo zoom o con ORD attivo mostra tutte le stazioni

    const allMarkers = new Set();
    let forceAll = false;               // stato del pulsante ORD

    function waitLeaflet() {
        return new Promise(res => {
            if (window.L && window.L.Map) return res();
            const t = setInterval(() => {
                if (window.L && window.L.Map) { clearInterval(t); res(); }
            }, 200);
        });
    }

    waitLeaflet().then(() => {
        const map2 = window.mymap || window.map;
        if (!map) { console.warn('[visibilità v7] mappa non trovata'); return; }

        // === Interfaccia: Pulsante ORD ===
        function createOrdButton() {
            const btn = document.createElement('button');
            btn.id = 'ordToggle';
            btn.textContent = 'ORD';
            btn.title = 'Mostra/Nascondi tutte le stazioni';
            btn.style.cssText = 'margin-top:4px;padding:4px 8px;background:#fff;border:1px solid #666;border-radius:4px;cursor:pointer;font-weight:bold;';
            btn.onclick = () => {
                forceAll = !forceAll;
                btn.style.background = forceAll ? '#4caf50' : '#fff';
                btn.style.color = forceAll ? '#fff' : '#000';
                updateVisibility();
            };

            // trova una barra laterale
            const sidebar = document.getElementById('sidebar') ||
                            document.querySelector('.sidebar') ||
                            document.querySelector('.leaflet-control-container .leaflet-top.leaflet-left') ||
                            document.body;

            sidebar.appendChild(btn);
        }

        // crea pulsante al ready
        map.whenReady(createOrdButton);

        // Raccogli marker già presenti
        map.whenReady(() => {
            map.eachLayer(l => { if (l instanceof L.Marker) allMarkers.add(l); });
            updateVisibility();
        });

        // Futuri marker
        map.on('layeradd', ev => {
            if (ev.layer instanceof L.Marker) {
                allMarkers.add(ev.layer);
                setTimeout(updateVisibility, 50);
            }
        });

        map.on('zoomend moveend', updateVisibility);

        function hideMarker(mk) {
    if (mk._icon)   mk._icon.style.opacity = '0';
    if (mk._shadow) mk._shadow.style.opacity = '0';
}
        function showMarker(mk) {
    if (mk._icon)   mk._icon.style.opacity = '1';
    if (mk._shadow) mk._shadow.style.opacity = '1';
}

        function updateVisibility() {
            const zoom = map.getZoom();
            const showAll = forceAll || zoom >= MIN_ZOOM_SHOW_ALL;

            const cellCounter = Object.create(null);
            const shownPoints = [];

            allMarkers.forEach(mk => {
                if (!mk.getLatLng) return;
                const ll = mk.getLatLng();

                // se dobbiamo mostrare tutto
                if (showAll) {
                    if (!map.hasLayer(mk)) mk.addTo(map);
                    showMarker(mk);
                    return;
                }

                // filtro per cella
                const cellX = Math.floor(ll.lng / CELL_SIZE_DEG);
                const cellY = Math.floor(ll.lat / CELL_SIZE_DEG);
                const key = cellX + '|' + cellY;

                cellCounter[key] = cellCounter[key] || 0;
                if (cellCounter[key] >= MAX_MARKERS_PER_CELL) {
                    if (!map.hasLayer(mk)) mk.addTo(map);
                    hideMarker(mk);
                    return;
                }

                // filtro per distanza
                const pt = map.latLngToLayerPoint(ll);
                let tooClose = false;
                for (let i = 0; i < shownPoints.length; i++) {
                    const p = shownPoints[i];
                    const dx = pt.x - p.x;
                    const dy = pt.y - p.y;
                    if (dx*dx + dy*dy < MIN_PIXEL_DIST*MIN_PIXEL_DIST) {
                        tooClose = true;
                        break;
                    }
                }

                if (tooClose) {
                    if (!map.hasLayer(mk)) mk.addTo(map);
                    hideMarker(mk);
                    return;
                }

                // altrimenti mostra
                cellCounter[key]++;
                if (!map.hasLayer(mk)) mk.addTo(map);
                showMarker(mk);
                shownPoints.push(pt);
            });
        }
    });
})();
</script>
<!-- === Patch: small link to bigger webcam image (Amantea Spiaggia) === -->
<script id="webcam_big_link_patch">
(function(){
  function addLink() {
    // find all webcam iframes inside open popups
    document.querySelectorAll('.leaflet-popup-content iframe.webcam-preview').forEach(function(ifr){
      const cont = ifr.parentElement;
      if(!cont || cont.querySelector('.webcam-big-link')) return; // already added

      // look for the existing station page button to copy its href
      const stationBtn = cont.querySelector('a.btn[href]');
      if(!stationBtn) return;

      const a = document.createElement('a');
      a.href = stationBtn.href;
      a.target = '_blank';
      a.textContent = 'Clicca qui per immagine più grande';
      a.className = 'webcam-big-link';
      a.style.cssText = 'display:block;font-size:11px;text-align:center;margin-top:3px;text-decoration:underline;color:#007bff;';
      // insert right after the iframe
      ifr.insertAdjacentElement('afterend', a);
    });
  }

  // Trigger when any popup is opened (Leaflet fires 'popupopen')
  if(window.map || window.mymap){
    (window.map || window.mymap).on('popupopen', addLink);
  } else {
    // fallback: observe clicks on marker icons
    document.addEventListener('click', function(e){
      if(e.target.classList.contains('leaflet-marker-icon') || e.target.closest('.leaflet-marker-icon')){
        setTimeout(addLink, 120);
      }
    });
  }
})();
</script>
<script id="indicator_patch">
(function(){
  function setIndicator(text){
    var el = document.getElementById('map-indicator');
    if(!el){ return; }
    el.textContent = text;
    el.style.opacity = '1';
    clearTimeout(setIndicator.__t);
    setIndicator.__t = setTimeout(function(){ el.style.opacity = '0'; }, 5000);
  }
  function fmt(){
    var now = new Date();
    return now.toLocaleDateString('it-IT') + ' ' + now.toLocaleTimeString('it-IT', {hour: '2-digit', minute: '2-digit'});
  }
  function wrap(name, getText){
    var orig = window[name];
    if(typeof orig !== 'function'){ return; }
    window[name] = function(){
      orig.apply(this, arguments);
      setIndicator(getText.apply(this, arguments));
    };
  }
  wrap('visualizzaAttuali', function(){ return 'Temperature in tempo reale'; });
  wrap('visualizzaUmidita', function(){ return 'Umidità relativa in tempo reale'; });
  wrap('visualizzaPercepita', function(){ return 'Temperatura percepita'; });
  wrap('visualizzaRaffiche', function(){ return 'Raffiche di vento (km/h) in tempo reale'; });
  wrap('visualizzaPioggia', function(){ return 'Pioggia cumulata odierna (mm)'; });
  // visualizzaEstremi('max'|'min')
  var origEstremi = window.visualizzaEstremi;
  if(typeof origEstremi === 'function'){
    window.visualizzaEstremi = function(tipo){
      origEstremi.apply(this, arguments);
      var lb = tipo==='max' ? 'Massime' : 'Minime';
      setIndicator(lb + ' registrate fino al ' + fmt());
    };
  }
})();
</script>
<script id="extremi_popup_fix">
(function(){
  function approxEqualLatLng(a, b){
    return Math.abs(a.lat - b.lat) < 0.0001 && Math.abs(a.lng - b.lng) < 0.0001;
  }
  async function ensureExtremes(popupEl, stationId){
    if(!stationId || !window.getExtremesFromFirebase) return;
    if(popupEl.dataset.extremesLoaded === stationId) return;
    try{
       const data = await window.getExtremesFromFirebase(stationId);
       if(!data) return;
       const {min, max} = data;
       // Try explicit spans
       const sMax = popupEl.querySelector('.temp-max');
       const sMin = popupEl.querySelector('.temp-min');
       if(sMax) sMax.innerHTML = '<b>Massima:</b> ' + (max!==null ? String(max)+'°C' : '--');
       if(sMin) sMin.innerHTML = '<b>Minima:</b> ' + (min!==null ? String(min)+'°C' : '--');
       // Generic div replacement
       if(!sMax && !sMin){
          popupEl.querySelectorAll('.popup-data').forEach(div=>{
             if(div.textContent.includes('Min:') || div.textContent.includes('Minima:')){
                 div.innerHTML = '<span class="bold">Min:</span> ' + (min!==null?String(min)+'°C':'--') +
                                 ' / <span class="bold">Max:</span> ' + (max!==null?String(max)+'°C':'--');
             }
          });
       }
       popupEl.dataset.extremesLoaded = stationId;
    }catch(e){ console.error('extremi_popup_fix', e);}
  }

  function init(){
    const leafletMap = window.map || window.mymap;
    if(!leafletMap){ setTimeout(init, 500); return; }

    leafletMap.on('popupopen', function(e){
        const popupEl = e.popup._container;
        if(!popupEl) return;
        let stationId = popupEl.querySelector('.popup-wrapper')?.getAttribute('data-station-id');
        if(!stationId && window.markersById){
            for(const id in window.markersById){
                const m = window.markersById[id];
                if(m.getLatLng && approxEqualLatLng(m.getLatLng(), e.popup.getLatLng())){
                    stationId = id;
                    break;
                }
            }
        }
        ensureExtremes(popupEl, stationId);
    });
  }
  document.addEventListener('DOMContentLoaded', init);
})();
</script>
<!-- === Patch WU offset & wind – ChatGPT 2025‑06‑25‑C === -->
<script id="wu_offset_wind_patch">
(function(){
  const today = new Date().toISOString().split("T")[0];

  /* --------------------------------------------------------------------
     Funzioni di utilità
     -------------------------------------------------------------------- */
  /* FNV‑1a usato dallo script originale */
  function fnvRand(key){
    let hash = 2166136261 >>> 0;
    for (let i = 0; i < key.length; i++){
      hash ^= key.charCodeAt(i);
      hash = Math.imul(hash, 16777619);
    }
    return (hash >>> 0) / 4294967296;
  }
  /* Offset deterministico 0,1‑0,4 °C */
  function offset(stationId){
    const rand = fnvRand(String(stationId||'') + today);
    return 0.1 + rand * 0.3;
  }
  /* Valuta se la stazione è WU */
  function isWU(staz){
    return staz && (staz.apiKey || String(staz.stationId||'').startsWith("I") || staz.mlg);
  }

  /* --------------------------------------------------------------------
     1) Integrazione VENTO/RAFFICA da Open‑Meteo nell’aggiornamento marker
     -------------------------------------------------------------------- */
  const cachedWind = Object.create(null);

  function patchAggiungiMarker(){
    const orig = window.aggiungiMarker;
    if(typeof orig !== "function" || orig.__patchedWU) return;

    window.aggiungiMarker = function patched(staz, obs){
      const wu = isWU(staz);

      /* --- Calcolo offset se manca (rand ≥0.7 nel codice originale) --- */
      if(wu && obs && obs.metric && typeof obs.metric.temp === "number"){
        const rand = fnvRand(String(staz.stationId||'') + today);
        if(rand >= 0.7){       // l'originale non lo applicherà
          obs.metric.temp += parseFloat(offset(staz.stationId));
        }
      }

      /* --- Vento / raffica Open‑Meteo -------------------------------- */
      function callOrig(){
        return orig.call(this, staz, obs);
      }

      if(!wu || cachedWind[staz.stationId]){
        return callOrig();
      }

      cachedWind[staz.stationId] = true;
      fetch(`https://api.open-meteo.com/v1/forecast?latitude=${staz.lat}&longitude=${staz.lon}&current=wind_speed_10m,wind_gusts_10m&timezone=UTC`)
        .then(r => r.json())
        .then(d => {
          if(d.current){
            if(d.current.wind_speed_10m != null) obs.windSpeed = d.current.wind_speed_10m;
            if(d.current.wind_gusts_10m != null) obs.windGust = d.current.wind_gusts_10m;
          }
        })
        .catch(console.error)
        .finally(callOrig);

      /* Non chiamiamo subito l'originale: lo faremo nel finally */
      return;
    };
    window.aggiungiMarker.__patchedWU = true;
  }

  /* --------------------------------------------------------------------
     2) Patch su datiTabella per qualunque stazione (presente/futura)
     -------------------------------------------------------------------- */
  function patchDatiTabella(){
    if(!Array.isArray(window.datiTabella) || window.datiTabella.__patchedWU) return;

    const tab = window.datiTabella;

    /* Applica/controlla offset su oggetto singolo */
    function ensure(obj){
      if(!obj || !isWU(obj)) return;

      const stid = obj.stationId;
      const rand = fnvRand(String(stid||'') + today);
      /* Se rand >=0.7 l'originale non ha messo offset: aggiungiamolo ora */
      if(rand >= 0.7){
        const off = parseFloat(offset(stid));
        if(typeof obj.tempVal === "number"){
          obj.tempVal = parseFloat((obj.tempVal + off));
        }
        if(typeof obj.temp === "number"){
          obj.temp = parseFloat((obj.temp + off));
        }
      }
    }

    /* Patch push per gestire futuri inserimenti */
    const origPush = tab.push;
    tab.push = function(...args){
      args.forEach(ensure);
      return origPush.apply(this, args);
    };
    tab.__patchedWU = true;

    /* Corregge già le righe esistenti */
    tab.forEach(ensure);

    /* Rinfresca subito la tabella/marker se funzione esiste */
    if(typeof window.aggiornaTabella === "function"){
      setTimeout(window.aggiornaTabella, 0);
    }
  }

  /* --------------------------------------------------------------------
     3) Timer di autosicurezza: ogni 3 s assicura patch presente
     -------------------------------------------------------------------- */
  function watchdog(){
     patchAggiungiMarker();
     patchDatiTabella();
  }
  document.addEventListener("DOMContentLoaded", watchdog);
  setInterval(watchdog, 3000);   // resta resiliente a re‑inizializzazioni
})();
</script>
<!-- === /Patch WU offset & wind === -->

<!-- ===== END PATCH DECIMALI WU v12 ===== -->
<!-- Snapshot & QR libraries -->
<script defer="" src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script defer="" src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
<!-- === Custom per‑stazione label patch 2025‑06‑26 === -->
<script id="custom_station_label">
(function(){
  /* --- helpers ------------------------------------------------------- */
  function isWU(id){ return typeof id==="string" && /^I[A-Z0-9]/i.test(id); }
  function labelFor(id){ return isWU(id) ? "*" : ""; }

  /* Aggiorna la mappa customStationLabels, se presente */
  function patchMapping(){
    if(window.customStationLabels){
      Object.keys(window.customStationLabels).forEach(function(k){
        window.customStationLabels[k] = labelFor(k);
      });
    }
  }

  /* Rimuove/aggiorna etichette dentro un elemento HTML */
  function scrubNode(node){
    if(!node) return;
    /* elimina "Staz. ..." e spazi finali */
    node.innerHTML = node.innerHTML.replace(/Staz\.[^<]*/g, function(match){
      /* se era "Staz. MLG" o "Staz. di ..." toglilo pure */
      return "";
    });
  }

  /* ------------------------------------------------------------------ */
  /* 1.  Intercetta bindPopup PRIMA della creazione dei popup --------- */
  const origBind = L.Marker && L.Marker.prototype.bindPopup;
  if(origBind && !origBind.__patchedForAsterisk){
    L.Marker.prototype.bindPopup = function(content, opts){
      try{
        const sid = this.stationId || (this.options && this.options.stationId);
        const lbl = labelFor(sid);
        if(typeof content === "string"){
          /* Se il contenuto include "Staz." sostituisci */
          content = content.replace(/Staz\.[^<]*/g, lbl);
        }
      }catch(e){ console.warn("asterisk patch bindPopup", e); }
      return origBind.call(this, content, opts);
    };
    L.Marker.prototype.bindPopup.__patchedForAsterisk = true;
  }

  /* 2.  Per popup già preparati/creati, pulizia su evento ---------- */
  function attachPopupScrub(){
    if(window.map && typeof map.on==="function"){
      map.on("popupopen", function(ev){
        scrubNode(ev.popup.getElement());
      });
    }
  }

  /* 3.  Patch aggiornaTabella per la tabella ------------------------ */
  function patchAggiorna(){
    const orig = window.aggiornaTabella;
    if(typeof orig!=="function" || orig.__patchedForAsterisk) return;

    window.aggiornaTabella = function(){
      orig.apply(this, arguments);
      /* pulizia su tutta la tabella */
      document.querySelectorAll('#tabella, #listaStazioni').forEach(scrubNode);
    };
    window.aggiornaTabella.__patchedForAsterisk = true;
  }

  /* 4.  Pulizia periodica di sicurezza ------------------------------ */
  function periodicScrub(){
    setInterval(function(){
      document.querySelectorAll('#tabella, #listaStazioni').forEach(scrubNode);
    }, 1500);
  }

  /* 5.  Inizializzazione ------------------------------------------- */
  function init(){
    patchMapping();
    patchAggiorna();
    attachPopupScrub();
    periodicScrub();
  }

  if(document.readyState==="loading"){
    document.addEventListener("DOMContentLoaded", init);
  }else{
    init();
  }
})();
</script>
<!-- PATCH PERFORMANCE v3 (2025‑06‑27): caching, dynamic concurrency, timeout, preconnect, lazy CSS -->
<link href="https://api.open-meteo.com" rel="preconnect"/>
<script defer="" id="perf-patch-v3">
(() => {
  /* ---------- CONFIG ---------- */
  const HARDWARE_CORES = navigator.hardwareConcurrency || 8;
  const MAX_CONCURRENT = Math.min(24, Math.max(8, HARDWARE_CORES * 2)); // 2× cores, capped 24
  const FETCH_TIMEOUT_MS = 2500;              // abort after 2.5 s
  const MAX_CACHE_AGE_MS = 5 * 60 * 1000;     // 5 min cache validity
  const CACHE_PREFIX = 'om_';

  /* ---------- AUX: Lazy‑CSS dedupe ---------- */
  document.addEventListener('DOMContentLoaded', () => {
    const seen = new Set();
    document.querySelectorAll('link[rel="stylesheet"]').forEach(l => {
      const href = l.getAttribute('href');
      if(seen.has(href)){
        l.setAttribute('rel', 'preload');
        l.setAttribute('as', 'style');
        l.onload = () => { l.rel = 'stylesheet'; };
      }
      seen.add(href);
    });
  });

  /* ---------- GUARDBOX ---------- */
  if (typeof window.caricaDatiOpenMeteo !== 'function' || !Array.isArray(window.stazioni)) return;

  const stazioniOM = window.stazioni.filter(s => s.openMeteo);

  const buildEntry = (stazione, data) => ({
    stationId     : stazione.stationId,
    temp          : data.current.temperature_2m,
    tempVal       : data.current.temperature_2m,
    pioggia       : data.current.precipitation,
    umidita       : data.current.relativehumidity_2m,
    raffica       : data.current.wind_gusts_10m,
    percepitaVal  : (typeof calcolaPercepita === 'function') ? calcolaPercepita(data.current.temperature_2m,data.current.relativehumidity_2m,data.current.wind_speed_10m) : null
  });

  /* ---------- CACHE HELPERS ---------- */
  function cacheKey(stazione){ return CACHE_PREFIX + stazione.stationId; }
  function loadCache(stazione){
    try{
      const raw = localStorage.getItem(cacheKey(stazione));
      if(!raw) return null;
      const obj = JSON.parse(raw);
      if(Date.now() - obj.ts > MAX_CACHE_AGE_MS) return null;
      return obj.data;
    }catch(_){ return null; }
  }
  function saveCache(stazione, data){
    try{
      localStorage.setItem(cacheKey(stazione), JSON.stringify({ts: Date.now(), data}));
    }catch(_){}
  }

  /* ---------- SINGLE STATION FETCH ---------- */
  async function fetchStazione (stazione){
    // 1) Check cache
    const cached = loadCache(stazione);
    if(cached){
      window.datiTabella.push(buildEntry(stazione, cached));
      return;
    }

    // 2) Otherwise fetch with timeout
    const base = 'https://api.open-meteo.com/v1/forecast';
    const query = `latitude=${stazione.lat}&longitude=${stazione.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m,wind_speed_10m&timezone=auto`;
    const url = base + '?' + query;
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), FETCH_TIMEOUT_MS);
    try{
      const resp = await fetch(url, { signal: controller.signal });
      if(!resp.ok) throw new Error(resp.status);
      const data = await resp.json();
      window.datiTabella.push(buildEntry(stazione, data));
      saveCache(stazione, data);
    }catch(err){
      console.warn('OpenMeteo v3 patch: skipping', stazione.stationId, err?.message || err);
    }finally{
      clearTimeout(timeoutId);
    }
  }

  /* ---------- OVERRIDE MAIN FUNCTION ---------- */
  window.caricaDatiOpenMeteo = async function patchedCaricaDatiOpenMeteo(){
    const queue = stazioniOM.slice(); // shallow copy
    const workers = Array.from({ length: Math.min(MAX_CONCURRENT, queue.length) }, async () => {
      while(queue.length){
        await fetchStazione(queue.shift());
      }
    });
    await Promise.all(workers);
  };
})();
</script>
<script>
function calcolaWindChill_C_safe(t, v){
  if(t==null||v==null||isNaN(t)||isNaN(v)||v<2) return null;
  const wci = 13.12 + 0.6215*t - 11.37*Math.pow(v,0.16) + 0.3965*t*Math.pow(v,0.16);
  return Math.round(wci*10)/10;
}
</script>
<!-- Snapshot share-friendly modern skin -->
<style id="snapshot_mobile_modern">
@media (max-width:700px){
  #snapshot-badge{
    position:absolute !important;
    top:12px !important;
    left:50% !important;
    transform:translateX(-50%) !important;
    width:90vw !important;
    max-height:40vh !important;
    overflow-y:auto !important;
    padding:10px 14px !important;
    font-size:13px !important;
    line-height:1.35 !important;
    color:#fff !important;
    background:rgba(0,0,0,0.35) !important;
    backdrop-filter:blur(8px) !important;
    border:1px solid rgba(255,255,255,0.1) !important;
    border-radius:14px !important;
    box-shadow:0 4px 12px rgba(0,0,0,0.4) !important;
  }
  #snap-riepilogo{
    position:absolute !important;
    bottom:82px !important;
    left:50% !important;
    transform:translateX(-50%);
    width:90vw !important;
    font-size:12px !important;
    line-height:1.35 !important;
    padding:10px 12px !important;
    color:#fff !important;
    background:rgba(0,0,0,0.3) !important;
    backdrop-filter:blur(8px) !important;
    border:1px solid rgba(255,255,255,0.1) !important;
    border-radius:12px !important;
    box-shadow:0 4px 12px rgba(0,0,0,0.4) !important;
  }
  #snap-legend{
    position:absolute !important;
    bottom:14px !important;
    left:50% !important;
    transform:translateX(-50%) !important;
    width:150px !important;
    height:10px !important;
    border-radius:8px !important;
    box-shadow:0 2px 6px rgba(0,0,0,0.4) !important;
  }
  .label-snap{
    font-size:10px !important;
    max-width:70px;
    text-align:center;
    white-space:pre-line;
    color:#fff !important;
    text-shadow:0 0 3px #000;
  }
  #snap-qr{
    width:72px !important;
    height:72px !important;
    border-radius:10px !important;
    box-shadow:0 2px 6px rgba(0,0,0,0.4);
  }
}
</style>
<script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>
<script>
/* ========= Interpolazione regionale (PLOT) ========= */
(function(){
  // Raggio dinamico in base allo zoom (heatmap)
  function calcHeatRadius(z){
     const base=35, baseZ=9;           // raggio base a zoom 9
     return Math.max(8, Math.round(base*Math.pow(2, z-baseZ)));
  }

  let plotLayer=null, plotActive=false, currentParam='temp';

  // patch funzioni per intercettare parametro
  const wrap=(fn,set)=>function(...a){currentParam=set(...a);return fn(...a)};
  if(window.visualizzaAttuali)  visualizzaAttuali=wrap(visualizzaAttuali,()=> 'temp');
  if(window.visualizzaPercepita) visualizzaPercepita=wrap(visualizzaPercepita,()=> 'percepita');
  if(window.visualizzaUmidita)   visualizzaUmidita=wrap(visualizzaUmidita,()=> 'umidita');
  if(window.visualizzaPioggia)   visualizzaPioggia=wrap(visualizzaPioggia, ()=> 'pioggia');
  if(window.visualizzaRaffiche)  visualizzaRaffiche=wrap(visualizzaRaffiche,()=> 'raffica');
  if(window.visualizzaEstremi){
    const _old=visualizzaEstremi;
    window.visualizzaEstremi=function(tipo){currentParam=(tipo==='max')?'tmax':'tmin';return _old(tipo);};
  }

  function getVal(d){
    switch(currentParam){
      case 'temp': return d.tempVal;
      case 'percepita': return d.percepitaVal;
      case 'umidita': return d.umidita;
      case 'pioggia': return parseFloat(d.pioggia)||0;
      case 'raffica': return d.raffica;
      case 'tmax': return getEstremoGiornaliero(d.stationId,'max');
      case 'tmin': return getEstremoGiornaliero(d.stationId,'min');
    }
    return null;
  }

  function gradientFor(p){
    if(p==='umidita') return {0:'#ff5500',0.5:'#66ccff',1:'#0055ff'};
    if(p==='pioggia') return {0:'#ffffff',0.4:'#99ccff',0.7:'#3399ff',1:'#003388'};
    if(p==='raffica') return {0:'#ffffcc',0.5:'#ff9933',1:'#ff0000'};
    return {0:'#0000ff',0.25:'#00ffff',0.5:'#00ff00',0.75:'#ffff00',1:'#ff0000'};
  }

  function buildHeat(){
    if(!window.datiTabella||!window.markersById) return [];
    return datiTabella.map(d=>{
       const m=markersById[d.stationId]; if(!m) return null;
       const v=getVal(d); if(!Number.isFinite(v)) return null;
       const {lat,lng}=m.getLatLng();
       return [lat,lng,v];
    }).filter(Boolean);
  }

  function hideMarkers(on){
    for(const id in markersById){
       const el=markersById[id].getElement(); if(el) el.style.opacity=on?0:1;
    }
  }

  window.togglePlot=function(){
      if(!plotActive){
          const pts=buildHeat();
          if(pts.length<3){alert('Dati in caricamento o insufficienti');return;}
          const vs=pts.map(p=>p[2]); const mn=Math.min(...vs), mx=Math.max(...vs);
          const norm=mx===mn?()=>1:v=>(v-mn)/(mx-mn);
          const heat=L.heatLayer(pts.map(p=>[p[0],p[1],norm(p[2])]),{
             radius: calcHeatRadius(map.getZoom()), blur:25, maxZoom:8, gradient: gradientFor(currentParam)
          }).addTo(map);
          plotLayer=heat; plotActive=true; hideMarkers(true);
          document.getElementById('btnPlot').classList.add('attivo');
      }else{
          if(plotLayer) map.removeLayer(plotLayer);
          plotLayer=null; plotActive=false; hideMarkers(false);
          document.getElementById('btnPlot').classList.remove('attivo');
      }
  };

  // Aggiorna dinamicamente il raggio della heatmap al cambio di zoom
  if(window.map){
    map.on('zoomend', ()=>{
      if(window.plotLayer && window.plotLayer.setOptions){
        window.plotLayer.setOptions({radius: calcHeatRadius(map.getZoom()), gradient: gradientFor(currentParam)});
      }
    });
  }
})();
</script>
<!-- Infocard v10 JS -->
<script id="infocard-upgrade-js">
(function(){
  const KEY_DETECT = {
    caldo:   txt => txt.includes('🌡️'),
    freddo:  txt => txt.includes('🌡️'),
    tmax:    txt => txt.includes('🔺') || txt.toLowerCase().includes('max'),
    tmin:    txt => txt.includes('🔻') || txt.toLowerCase().includes('min'),
    raffica: txt => txt.includes('💨') || txt.toLowerCase().includes('raffica'),
    pioggia: txt => txt.includes('🌧️') || txt.toLowerCase().includes('mm')
  };

  function upgradeCards(){
    const order = document.getElementById('filtro-ordinamento')?.value || 'caldo';
    const detector = KEY_DETECT[order] || (()=>false);

    document.querySelectorAll('#tabella > div:not(:has(#riepilogo-testo))').forEach(card=>{
      // remove previous central metric injections
      card.querySelectorAll('.main-metric.injected').forEach(el=>el.remove());
      card.querySelectorAll('.main-metric').forEach(el=>el.classList.remove('main-metric'));

      const metrics = Array.from(card.querySelectorAll(':scope > div:nth-child(n+2) > div'));

      // reset hidden flags
      metrics.forEach(m=>m.classList.remove('metric-hidden'));

      // choose matching metric
      let chosen = metrics.find(m=>detector(m.textContent));
      if(!chosen) chosen = metrics[0];

      // put chosen in big spot
      const big = chosen.cloneNode(true);
      big.classList.add('main-metric','injected');
      card.insertBefore(big, card.children[1]);

      // hide original chosen
      chosen.classList.add('metric-hidden');
    });
  }

  // run when changes happen
  const table = document.getElementById('tabella');
  if(table){
    new MutationObserver(()=>setTimeout(upgradeCards,0)).observe(table,{childList:true,subtree:true});
  }
  document.getElementById('filtro-ordinamento')?.addEventListener('change',()=>setTimeout(upgradeCards,0));
  window.addEventListener('load',()=>setTimeout(upgradeCards,0));
})();
</script>
<!-- ChatGPT patch: color square metric according to selected filter -->
<script id="chatgpt-metric-color">
(function(){
  const COLOR_MAP = {
    caldo:  "#d0006f",
    freddo: "#0066d0",
    tmax:   "#d0006f",
    tmin:   "#0066d0",
    raffica:"#ff8c00",
    pioggia:"#007bff"
  };
  function recolor(){
     const order = document.getElementById('filtro-ordinamento')?.value || 'caldo';
     const color = COLOR_MAP[order] || "#007bff";
     document.querySelectorAll('#tabella .main-metric').forEach(el=>{
        el.style.backgroundColor = color;
        el.style.color = '#fff';
        el.style.borderRadius = '6px';
        el.style.padding = '2px 6px';
        el.style.display = 'inline-block';
     });
  }
  document.getElementById('filtro-ordinamento')?.addEventListener('change', ()=>setTimeout(recolor,0));
  window.addEventListener('load', ()=>setTimeout(recolor,0));
})();
</script>
<!-- Mobile card compact patch v4 by ChatGPT 2025‑06‑27 -->
<script id="chatgpt-mobile-compact-20250627-v4">
/* Inseriamo il CSS alla fine del caricamento per sovrascrivere qualsiasi regola successiva */
document.addEventListener('DOMContentLoaded', function () {
  const css = `
  @media (max-width:640px){
    /* Container principale: flex wrap */
    #tabella{
      display:flex !important;
      flex-wrap:wrap !important;
      gap:8px !important;
      padding:6px !important;
    }
    /* Tutte le card meteo tranne riepilogo */
    #tabella > div:not(:has(#riepilogo-testo)){
      flex:0 0 calc(50% - 8px) !important; /* due colonne */
      max-width:calc(50% - 8px) !important;
      width:calc(50% - 8px) !important;
      margin:0 !important;
      padding:8px 6px !important;
      box-sizing:border-box !important;
      border-radius:12px !important;
    }
    /* Rimuovo eventuale altezza/min-height fissa */
    #tabella > div:not(:has(#riepilogo-testo)){height:auto !important;min-height:unset !important;}
    /* Titoli compatti */
    #tabella > div:not(:has(#riepilogo-testo)) > div:first-child,
    #tabella > div:not(:has(#riepilogo-testo)) h3{
      font-size:15px !important;
      line-height:1.2 !important;
      margin:0 0 4px 0 !important;
      text-align:left !important;
    }
  }
  @media (max-width:360px){
    #tabella > div:not(:has(#riepilogo-testo)){
      flex:0 0 100% !important;
      max-width:100% !important;
      width:100% !important;
    }
  }`;
  const style = document.createElement('style');
  style.textContent = css;
  document.head.appendChild(style);
});
</script>
<!-- === PATCH WIND JITTER v1 – 2025‑06‑29 === -->
<script>
(function(){
  const TODAY = new Date().toISOString().split("T")[0];
  if(typeof window.stableRand!=="function"){
    window.stableRand=function(seed){
      let h=2166136261>>>0;
      for(let i=0;i<seed.length;i++){
        h ^= seed.charCodeAt(i);
        h = Math.imul(h,16777619);
      }
      return (h>>>0)/4294967296;
    };
  }
  function windJitter(val, seed){
    const num=parseFloat(val);
    if(!Number.isFinite(num)) return val;
    const r=window.stableRand(seed+TODAY);
    const sign=r<0.5?-1:1;
    // ±5 % o almeno ±0,2 km/h
    const REL=0.12, MIN=0.5;
    const amp=Math.max(MIN, num*REL);
    const off=(0.3 + (r*0.8))*amp; // 0.2‑1.0 della ampiezza
    return parseFloat((num + sign*off));
  }
  // Patch funzione globale aggiungiMarker se presente
  const retry=()=>{
    if(typeof window.aggiungiMarker!=='function'){setTimeout(retry,500);return;}
    if(window.aggiungiMarker.__patchedWindJitter) return;
    const orig=window.aggiungiMarker;
    window.aggiungiMarker=function(staz, obs){
       if(obs){
          if(obs.windSpeed!=null) obs.windSpeed=windJitter(obs.windSpeed, (staz.stationId||'')+'_ws');
          if(obs.windGust!=null)  obs.windGust=windJitter(obs.windGust, (staz.stationId||'')+'_wg');
       }
       return orig.apply(this, arguments);
    };
    window.aggiungiMarker.__patchedWindJitter=true;
  };
  retry();
})();
</script>
<!-- === /PATCH WIND JITTER === -->
<!-- === FAST-LOAD PATCH 2025-07-02 === -->
<script id="fastload_20250702">
(() => {
  /* ───────────────────────────────────────────────────────────── *
   *  Parametri regolabili
   * ───────────────────────────────────────────────────────────── */
  const MAX_CONCURRENT   = 24;                 // fetch paralleli
  const MAX_CACHE_AGE_MS = 10 * 60 * 1e3;      // 10 min cache
  const FETCH_TIMEOUT_MS = 8000;               // 8 s timeout
  const CACHE_PREFIX     = "OMcache_v2_";

  /* fade‑in delicato dei marker quando TUTTO è pronto */
  const revealMarkers = () => {
    const hider = document.getElementById("hideMarkerOpacity");
    if (hider) hider.remove();                 // toglie opacity:0
    if (!document.getElementById("smoothMarkerOpacity")) {
      const css = document.createElement("style");
      css.id = "smoothMarkerOpacity";
      css.textContent = ".leaflet-marker-icon{transition:opacity .35s ease;}";
      document.head.appendChild(css);
    }
  };

  /* ───────────────────────────────────────────────────────────── *
   *  1) Open‑Meteo: override con fetch concorrente + cache
   * ───────────────────────────────────────────────────────────── */
  if (typeof window.caricaDatiOpenMeteo === "function") {
    /* helpers ---------------------------------------------------- */
    const key = s => \`\${CACHE_PREFIX}\${s.stationId}\`;
    const loadCache = s => {
      try {
        const raw = localStorage.getItem(key(s));
        if (!raw) return null;
        const { ts, data } = JSON.parse(raw);
        return (Date.now() - ts < MAX_CACHE_AGE_MS) ? data : null;
      } catch { return null; }
    };
    const saveCache = (s, data) => {
      try {
        localStorage.setItem(key(s), JSON.stringify({ ts: Date.now(), data }));
      } catch { /* quota piena: ignora */ }
    };
    const buildEntry = (s, d) => ({
      stationId    : s.stationId,
      temp         : d.current.temperature_2m,
      tempVal      : d.current.temperature_2m,
      pioggia      : d.current.precipitation,
      umidita      : d.current.relativehumidity_2m,
      raffica      : d.current.wind_gusts_10m,
      percepitaVal : (typeof calcolaPercepita === "function")
                       ? calcolaPercepita(d.current.temperature_2m,
                                          d.current.relativehumidity_2m,
                                          d.current.wind_speed_10m)
                       : null
    });

    /* fetch singolo con timeout + cache ------------------------- */
    async function fetchStazione(s) {
      const cached = loadCache(s);
      if (cached) return buildEntry(s, cached);

      const ctrl = new AbortController();
      const tId  = setTimeout(() => ctrl.abort(), FETCH_TIMEOUT_MS);
      try {
        const q = \`latitude=\${s.lat}&longitude=\${s.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m,wind_speed_10m&timezone=auto\`;
        const url = \`https://api.open-meteo.com/v1/forecast?\${q}\`;
        const r   = await fetch(url, { signal: ctrl.signal });
        if (!r.ok) throw new Error(r.status);
        const data = await r.json();
        saveCache(s, data);
        return buildEntry(s, data);
      } finally { clearTimeout(tId); }
    }

    /* override --------------------------------------------------- */
    window.caricaDatiOpenMeteo = async () => {
      const lista = (window.stazioni || []).filter(x => x.openMeteo);
      const queue = [...lista];
      window.datiTabella = window.datiTabella || [];

      /* worker pool concorrente ---------------------------------- */
      const workers = Array.from(
        { length: Math.min(MAX_CONCURRENT, queue.length) },
        async () => {
          while (queue.length) {
            const staz = queue.shift();
            try {
              const entry = await fetchStazione(staz);
              window.datiTabella.push(entry);
              /* marker aggiunto ma resta invisibile finché non riveliamo */
              if (typeof window.aggiungiMarker === "function") {
                window.aggiungiMarker(staz, { metric: { temp: entry.tempVal }});
              }
            } catch (e) {
              console.warn("Open-Meteo timeout/skipped:", staz.stationId, e);
            }
          }
        }
      );

      /* aspetta tutti i worker poi rivela in un colpo solo ------- */
      await Promise.allSettled(workers);
      revealMarkers();

      /* refresh tabella se presente ----------------------------- */
      if (typeof window.aggiornaTabella === "function") window.aggiornaTabella();
    };
  }

  /* ───────────────────────────────────────────────────────────── *
   *  2)  Weather Underground: chiamate in idle
   * ───────────────────────────────────────────────────────────── */
  if (typeof window.fetch === "function" && window.requestIdleCallback) {
    const _origWU = window.fetch;
    window.fetch = function(url, opts) {
      if (typeof url === "string" && url.includes("/v2/pws/observations/current")) {
        return new Promise((resolve, reject) => {
          requestIdleCallback(() =>
            _origWU(url, opts).then(resolve).catch(reject)
          , { timeout: 10000 });
        });
      }
      return _origWU(url, opts);
    };
  }
})();
</script>
<!-- === /FAST-LOAD PATCH 2025-07-02 === -->
<!-- FAST-LOAD VIEWPORT PATCH 2025-07-04 -->
<script id="fastload_viewport_20250704">
(() => {
  if (!window.map || !Array.isArray(window.stazioni)) return;

  /* ===== Configurazione ===== */
  const CACHE_PREFIX     = 'OMvp_';
  const CACHE_MS         = 10 * 60 * 1e3;               // 10 minuti
  const TIMEOUT_MS       = 8000;                        // 8 s timeout
  const MAX_CONCURRENT   = Math.min(16, (navigator.hardwareConcurrency || 8) * 2);
  const PAD_FACTOR       = 0.20;                        // bbox padding 20 %

  /* ===== Helpers cache ===== */
  const key   = s => CACHE_PREFIX + s.stationId;
  const load  = s => { try {
      const raw = localStorage.getItem(key(s));
      if(!raw) return null;
      const obj = JSON.parse(raw);
      return (Date.now() - obj.ts < CACHE_MS) ? obj.data : null;
  } catch { return null; } };
  const save  = (s,d) => { try {
      localStorage.setItem(key(s), JSON.stringify({ts: Date.now(), data:d}));
  } catch(_){} };

  /* ===== Build entry compatibile con datiTabella ===== */
  const build = (s,d)=>({
     stationId : s.stationId,
     temp      : d.current.temperature_2m,
     tempVal   : d.current.temperature_2m,
     pioggia   : d.current.precipitation,
     umidita   : d.current.relativehumidity_2m,
     raffica   : d.current.wind_gusts_10m,
     percepitaVal : (typeof calcolaPercepita==='function')
                    ? calcolaPercepita(d.current.temperature_2m,
                                       d.current.relativehumidity_2m,
                                       d.current.wind_speed_10m)
                    : null
  });

  /* ===== Coda concorrente ===== */
  const queue = [];
  let running = 0;
  const scheduled = new Set();

  async function fetchStazione(s){
     const cached = load(s);
     if(cached){ window.datiTabella.push(build(s,cached)); return; }

     const ctrl = new AbortController();
     const toId = setTimeout(()=>ctrl.abort(), TIMEOUT_MS);
     try{
        const q = `latitude=${s.lat}&longitude=${s.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m,wind_speed_10m&timezone=auto`;
        const r = await fetch(`https://api.open-meteo.com/v1/forecast?${q}`, {signal: ctrl.signal});
        if(!r.ok) throw new Error(r.status);
        const data = await r.json();
        save(s,data);
        window.datiTabella.push(build(s,data));
     }catch(e){ console.warn('viewport patch skip', s.stationId, e?.message||e); }
     finally{ clearTimeout(toId); }
  }

  function worker(){
     if(running>=MAX_CONCURRENT || queue.length===0) return;
     running++;
     fetchStazione(queue.shift()).finally(()=>{ running--; worker(); });
  }

  function enqueue(list){
     list.forEach(s=>{
         if(!s.openMeteo || scheduled.has(s.stationId)) return;
         scheduled.add(s.stationId);
         queue.push(s);
     });
     while(running < MAX_CONCURRENT && queue.length) worker();
  }

  /* ===== Selezione stazioni nel viewport + padding ===== */
  function visibili(){
     const b = map.getBounds();
     const padLat = (b.getNorth() - b.getSouth()) * PAD_FACTOR;
     const padLng = (b.getEast() - b.getWest()) * PAD_FACTOR;
     const south = b.getSouth() - padLat;
     const north = b.getNorth() + padLat;
     const west  = b.getWest()  - padLng;
     const east  = b.getEast()  + padLng;
     return window.stazioni.filter(s => s.lat>=south && s.lat<=north && s.lon>=west && s.lon<=east);
  }

  map.whenReady(()=>{
     enqueue(visibili());                    // batch iniziale
     map.on('moveend zoomend', () => enqueue(visibili()));
  });

})();
</script>
<!-- /FAST-LOAD VIEWPORT PATCH 2025-07-04 -->

<!-- *** Patch ChatGPT 2025-07-04: ripristino Tmin/Tmax nei popup *** -->

<script id="patch-estremi-giornalieri-0704">
(function(){
  /* Ritorna estremo min/max per stationId */
  function getEstremoGiornaliero(stationId, tipo){
     const ext = window.extremiGiornalieri && window.extremiGiornalieri[stationId];
     if(!ext) return NaN;
     const v = (tipo==='max' ? ext.max : ext.min);
     const n = parseFloat(v);
     return Number.isFinite(n) ? n : NaN;
  }
  window.getEstremoGiornaliero = getEstremoGiornaliero;

  /* Sincronizza r.tMin / r.tMax dentro datiTabella */
  function syncDati(){
     if(!Array.isArray(window.datiTabella) || !window.extremiGiornalieri) return;
     window.datiTabella.forEach(r=>{
        const ext = window.extremiGiornalieri[r.stationId];
        if(ext){
          r.tMin = ext.min;
          r.tMax = ext.max;
        }
     });
  }
  document.addEventListener('DOMContentLoaded', syncDati);
  setInterval(syncDati, 60000); // ogni minuto

  /* Aggiorna i popup quando vengono aperti */
  function patchPopup(){
      const m = window.map || window.mymap;
      if(!m){ setTimeout(patchPopup,500); return; }
      m.on('popupopen', e=>{
         const popupEl = e.popup && e.popup.getElement && e.popup.getElement();
         if(!popupEl) return;
         const contentEl = popupEl.querySelector('.leaflet-popup-content') || popupEl;
         const stationId = e.popup._source && e.popup._source.stationId;
         if(!stationId) return;
         const ext = window.extremiGiornalieri && window.extremiGiornalieri[stationId];
         if(!ext) return;
         const minTxt = (ext.min!=null && ext.min!=='--') ? ext.min + '°C' : '--';
         const maxTxt = (ext.max!=null && ext.max!=='--') ? ext.max + '°C' : '--';

         /* Rimuovi eventuali righe duplicate collocate fuori dal content wrapper */
         popupEl.querySelectorAll('.popup-data.temp-minmax').forEach(el=>{
            if(!contentEl.contains(el)) el.remove();
         });

         /* Trova riga esistente all'interno del contenuto */
         let row = contentEl.querySelector('.popup-data.temp-minmax');
         if(!row){
           /* Se presente una riga con Min: / Max: la aggiorniamo */
           row = Array.from(contentEl.querySelectorAll('.popup-data'))
                      .find(el=>/Min:/i.test(el.textContent) && /Max:/i.test(el.textContent));
         }
         if(!row){
           row = document.createElement('div');
           row.className = 'popup-data temp-minmax';
           contentEl.appendChild(row);
         }
         row.innerHTML = '<span class="bold">Min:</span> ' + minTxt + ' / <span class="bold">Max:</span> ' + maxTxt;
      });
  }
  patchPopup();
})();
</script>



<!-- *** Patch ChatGPT 2025-07-04: recupero Tmin/Tmax via Open‑Meteo per stazioni con valori mancanti *** -->
<script id="patch-estremi-openmeteo-0704">
(function(){
  const MISSING = v => v==null || v==="--" || (typeof v==="number" && !isFinite(v));

  async function fetchDailyMinMax(lat, lon){
      try{
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&daily=temperature_2m_max,temperature_2m_min&timezone=auto`;
        const res = await fetch(url);
        const data = await res.json();
        const min = data.daily?.temperature_2m_min?.[0] ?? null;
        const max = data.daily?.temperature_2m_max?.[0] ?? null;
        return {min, max};
      }catch(e){
        console.warn("Open‑Meteo extremi error", e);
        return {min:null,max:null};
      }
  }

  const stazioniById = (window.stazioni || []).reduce((acc,s)=>{acc[s.stationId]=s;return acc;}, {});

  async function fillMissing(){
     if(!Array.isArray(window.datiTabella)) return;
     // gather promises per station
     const promises = [];
     window.datiTabella.forEach(r=>{
        if(MISSING(r.tMin) || MISSING(r.tMax)){
           promises.push((async()=>{
             const staz = stazioniById[r.stationId];
             if(!staz) return;
             const {min,max} = await fetchDailyMinMax(staz.lat, staz.lon);
             if(!MISSING(min) && !MISSING(max)){
                // aggiorna strutture
                r.tMin = min;
                r.tMax = max;
                window.extremiGiornalieri = window.extremiGiornalieri || {};
                window.extremiGiornalieri[r.stationId] = {min,max};
             }
           })());
        }
     });
     await Promise.all(promises);
  }

  // esegui subito, poi ripeti ogni 10 minuti per sicurezza
  document.addEventListener('DOMContentLoaded', fillMissing);
  setInterval(fillMissing, 600000);
})();
</script>


<!-- *** Patch ChatGPT 2025-07-04b: mostra Tmin/Tmax nella riga originale del popup *** -->
<script id="patch-estremi-popup-0704b">
(function(){
  function formatVal(v){ return (v!=null && v!=="--") ? v + "°C" : "--"; }

  function updatePopup(popup){
     const popupEl = popup && popup.getElement && popup.getElement();
     if(!popupEl) return;
     const stationId = popup._source && popup._source.stationId;
     if(!stationId) return;
     const ext = window.extremiGiornalieri && window.extremiGiornalieri[stationId];
     if(!ext) return;
     // trova la riga già esistente "Min:"
     const rows = popupEl.querySelectorAll('.popup-data');
     rows.forEach(row=>{
        if(/Min:/i.test(row.textContent)){
            row.innerHTML = '<span class="bold">Min:</span> ' + formatVal(ext.min) +
                            ' / <span class="bold">Max:</span> ' + formatVal(ext.max);
        }
     });
  }

  function attach(){
     const m = window.map || window.mymap || window.leafletMap;
     if(!m){ setTimeout(attach,500); return; }
     m.on('popupopen', e=> updatePopup(e.popup));
     // esposizione pubblica cosí caricaEstremiDaFirebase può richiamarlo
     window.aggiornaPopup = function(){
        if(!m._popup) return;
        updatePopup(m._popup);
     };
  }
  attach();
})();
</script>


<script>
/* ===== Screenshot & Share Feature added by ChatGPT ===== */
let ultimoModo = 'attuali';

/* Preserve originals, extend to track display mode */
if (typeof visualizzaAttuali === 'function'){
  const _visualizzaAttuali = visualizzaAttuali;
  visualizzaAttuali = function(){ _visualizzaAttuali(); ultimoModo='attuali'; };
}
if (typeof visualizzaUmidita === 'function'){
  const _visualizzaUmidita = visualizzaUmidita;
  visualizzaUmidita = function(){ _visualizzaUmidita(); ultimoModo='umidita'; };
}
if (typeof visualizzaPercepita === 'function'){
  const _visualizzaPercepita = visualizzaPercepita;
  visualizzaPercepita = function(){ _visualizzaPercepita(); ultimoModo='percepita'; };
}
if (typeof visualizzaRaffiche === 'function'){
  const _visualizzaRaffiche = visualizzaRaffiche;
  visualizzaRaffiche = function(){ _visualizzaRaffiche(); ultimoModo='raffica'; };
}
if (typeof visualizzaEstremi === 'function'){
  const _visualizzaEstremi = visualizzaEstremi;
  visualizzaEstremi = function(tipo){ _visualizzaEstremi(tipo); ultimoModo = (tipo === 'max' ? 'max' : 'min'); };
}

// Main generator
function generaScreenshot(){
  const mapEl = document.getElementById('map');
  if(!mapEl){ alert('Mappa non trovata'); return; }

  // Build overlay card
  const overlay = document.createElement('div');
  overlay.id = 'screenshotOverlay';
  overlay.style.position = 'absolute';
  overlay.style.top = '10px';
  overlay.style.left = '10px';
  overlay.style.zIndex = '9999';
  overlay.style.background = 'rgba(255,255,255,0.94)';
  overlay.style.border = '2px solid #1a3a9b';
  overlay.style.borderRadius = '10px';
  overlay.style.padding = '12px 16px';
  overlay.style.fontFamily = 'Arial, sans-serif';
  overlay.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
  overlay.innerHTML = buildOverlayHTML();
  mapEl.appendChild(overlay);

  html2canvas(mapEl, {useCORS:true, backgroundColor:null}).then(canvas=>{
      overlay.remove();
      // Trigger download
      const link = document.createElement('a');
      link.download = 'CalabriaWeather_'+ new Date().toISOString().slice(0,10)+'.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
  }).catch(e=>{
      console.error('html2canvas error', e);
      overlay.remove();
      alert('Errore nella generazione dello screenshot');
  });
}

// Build overlay inner HTML
function buildOverlayHTML(){
  const titles = {
    'attuali':'Temperature Attuali',
    'max':'Temperature Massime',
    'min':'Temperature Minime',
    'umidita':'Umidità Relativa',
    'raffica':'Raffiche di Vento',
    'percepita':'Temperatura Percepita'
  };
  const header = titles[ultimoModo] || 'Dati Meteo';
  const now = new Date();
  let html = '<div style="font-size:17px;font-weight:bold;text-align:center;margin-bottom:8px;">'+header+'</div>';
  html += '<div style="font-size:13px;text-align:center;margin-bottom:8px;">'+ now.toLocaleDateString('it-IT', { weekday:'long', day:'numeric', month:'long' }) +'</div>';
  const top = calcolaTop10();
  top.forEach((r,i)=>{
     html += '<div style="display:flex;justify-content:space-between;font-size:14px;margin:2px 0;">'
          + '<span>'+ (i+1) +'. '+ r.nome +'</span>'
          + '<span style="font-weight:bold;">'+ r.valore +'</span></div>';
  });
  return html;
}

// Compute top 10 for current display mode
function calcolaTop10(){
   const list = [];
   if(!window.datiTabella) return list;
   datiTabella.forEach(d=>{
        let val;
        if(ultimoModo === 'attuali'){ val = d.tempVal; }
        else if(ultimoModo === 'max'){ val = getEstremoGiornaliero(d.stationId,'max'); }
        else if(ultimoModo === 'min'){ val = getEstremoGiornaliero(d.stationId,'min'); }
        else if(ultimoModo === 'umidita'){ val = d.umidita; }
        else if(ultimoModo === 'raffica'){ val = d.raffica; }
        else if(ultimoModo === 'percepita'){ val = d.percepitaVal; }
        if(val !== undefined && !isNaN(val)){
            list.push({ nome: d.stationId, valore: val });
        }
   });
   // Sort based on mode
   if(ultimoModo === 'min'){ list.sort((a,b)=> a.valore - b.valore); }
   else{ list.sort((a,b)=> b.valore - a.valore); }

   // Format values with unit
   const unit = (ultimoModo === 'umidita') ? '%' : (ultimoModo === 'raffica' ? ' km/h' : '°C');
   return list.slice(0,10).map(o=>({ nome:o.nome, valore: o.valore + unit }));
}
</script>


<!-- ChatGPT quick‑fix patch 2025‑07‑07 -->
<style id="top10-overlay-css">
.top10-overlay{
  position:absolute;
  top:10px;
  right:10px;
  z-index:9999;
  background:rgba(255,255,255,0.95);
  border:2px solid #1a3a9b;
  border-radius:10px;
  padding:12px 16px;
  font-family:Arial,sans-serif;
  box-shadow:0 4px 12px rgba(0,0,0,0.2);
  max-height:80vh;
  overflow-y:auto;
}
@media(max-width:600px){
 .top10-overlay{
   top:auto;
   bottom:10px;
   left:50%%;
   right:auto;
   transform:translateX(-50%%);
   width:90vw;
   max-height:60vh;
 }
}
</style>
<script id="top10-overlay-patch">
(function(){
  if(window._overlayPatched) return;
  window._overlayPatched = true;

  // patch calcolaTop10 to use station name where available
  const origCalc = window.calcolaTop10;
  
  // mapping stationId -> nome dai metadati globali (se esistono)
  const idNameMap = (() => {
    const m = {};
    if (window.stazioni && Array.isArray(window.stazioni)) {
      window.stazioni.forEach(s => {
        if (s && s.stationId && s.nome) m[s.stationId] = s.nome;
      });
    }
    return m;
  })();

  // funzione per ricavare un nome leggibile in ogni caso
  function getDisplayName(d){
    if(d.nome && d.nome.trim()!=='') return d.nome;
    if(idNameMap[d.stationId]) return idNameMap[d.stationId];
    return d.stationId;
  }

window.calcolaTop10 = function(){
     const res = origCalc?origCalc():[];
     return res.map(r=>{
        const st = (window.stazioni||[]).find(s=>s.stationId===r.nome);
        return { nome: (st && st.nome) ? st.nome : r.nome, valore:r.valore };
     });
  };

  // patch buildOverlayHTML to add info line
  const origBuild = window.buildOverlayHTML;
  window.buildOverlayHTML = function(){
     let html = origBuild?origBuild():'<div>Top 10</div>';
     html += '<div style="font-size:11px;text-align:center;margin-top:8px;"><em>Top 10 valori più importanti per questa condizione.<br>Per i dati completi consulta la MLG Map su meteologullo.com</em></div>';
     return html;
  };

  // after screenshot created, adjust overlay style class
  const observer = new MutationObserver(muts=>{
       muts.forEach(m=>{
          m.addedNodes.forEach(node=>{
             if(node.id==='screenshotOverlay' && node.style){
                node.classList.add('top10-overlay');
                node.style.position='absolute';
                node.style.left='auto';
             }
          });
       });
  });
  observer.observe(document.body,{childList:true,subtree:true});
})();
</script>


<!-- ChatGPT name-fix v9 -->
<script id="namefix-v9">
(function(){
  if(window.__namefix_v9) return;
  window.__namefix_v9 = true;
  const originalCalc = window.calcolaTop10;
  if(typeof originalCalc !== 'function') return;

  window.calcolaTop10 = function(){
     const res = originalCalc();
     let meta;
     try{ meta = stazioni; }catch(e){ meta = undefined; }
     return res.map(r=>{
        let nice = r.nome;
        if(meta && Array.isArray(meta)){
          const match = meta.find(s=>s && s.stationId===r.nome && s.nome);
          if(match && match.nome) nice = match.nome;
        }
        return { nome: nice, valore: r.valore };
     });
  };
})();
</script>


<!-- === WU FASTLOAD VIEWPORT PATCH 2025-07-07 === -->
<script id="wu_fastload_viewport_20250707">
(() => {
  if (!window.map || !Array.isArray(window.stazioni)) return;
  if (window.__wuFastViewportPatch) return;
  window.__wuFastViewportPatch = true;

  /* === Config === */
  const CACHE_PREFIX   = 'WUvp_';
  const CACHE_MS       = 5 * 60 * 1e3;        // 5 minuti
  const MAX_CONCURRENT = 6;                   // richieste simultanee
  const TIMEOUT_MS     = 8000;                // timeout fetch 8 s
  const PAD_FACTOR     = 0.15;                // 15 % padding bbox

  const key = s => CACHE_PREFIX + s.stationId;
  const now = () => Date.now();
  const load = s => {
    try {
      const raw = localStorage.getItem(key(s));
      if (!raw) return null;
      const obj = JSON.parse(raw);
      return (now() - obj.t < CACHE_MS) ? obj.v : null;
    } catch (_) { return null; }
  };
  const save = (s, v) => {
    try { localStorage.setItem(key(s), JSON.stringify({ t: now(), v })); } catch (_) {}
  };

  /* === Native fetch via XHR, bypassa altre patch === */
  function nativeFetch(url, opts = {}) {
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      xhr.open(opts.method || 'GET', url, true);
      xhr.responseType = 'json';
      if (opts.headers) Object.entries(opts.headers).forEach(([k, v]) => xhr.setRequestHeader(k, v));
      const timer = setTimeout(() => { xhr.abort(); reject(new Error('timeout')); }, TIMEOUT_MS);
      xhr.onload  = () => { clearTimeout(timer);
        resolve(new Response(JSON.stringify(xhr.response), { status: xhr.status, headers: {'Content-Type':'application/json'} }));
      };
      xhr.onerror = () => { clearTimeout(timer); reject(new Error('network')); };
      xhr.send(opts.body || null);
    });
  }

  /* === Coda concorrente === */
  const queue = [];
  const scheduled = new Set();
  let running = 0;

  function worker() {
    if (running >= MAX_CONCURRENT || queue.length === 0) return;
    running++;
    const s = queue.shift();
    fetchStazione(s)
      .catch(err => console.error('WU', s.stationId, err))
      .finally(() => { running--; worker(); });
  }

  function enqueue(list) {
    list.forEach(s => {
      if (!s.apiKey || scheduled.has(s.stationId)) return;
      scheduled.add(s.stationId);
      queue.unshift(s);   // priorità alle visibili
    });
    while (running < MAX_CONCURRENT && queue.length) worker();
  }

  function fetchStazione(s) {
    const cached = load(s);
    if (cached) return Promise.resolve(cached);
    const url = `https://api.weather.com/v2/pws/observations/current?stationId=${s.stationId}&format=json&units=m&apiKey=${s.apiKey}`;
    return nativeFetch(url).then(r => r.json()).then(data => { save(s, data); return data; });
  }

  /* === Stazioni dentro bbox (con padding) === */
  function visibili() {
     const b = map.getBounds();
     const padLat = (b.getNorth() - b.getSouth()) * PAD_FACTOR;
     const padLon = (b.getEast() - b.getWest()) * PAD_FACTOR;
     const south = b.getSouth() - padLat,
           north = b.getNorth() + padLat,
           west  = b.getWest()  - padLon,
           east  = b.getEast()  + padLon;
     return window.stazioni.filter(s => s.lat>=south && s.lat<=north && s.lon>=west && s.lon<=east);
  }

  /* === Hook mappa === */
  map.whenReady(() => enqueue(visibili()));
  map.on('moveend zoomend', () => enqueue(visibili()));

  /* === Override fetch SOLO per endpoint WU, con cache/queue === */
  const origFetch = window.fetch;
  window.fetch = function(url, opts) {
    if (typeof url === 'string' && url.includes('/v2/pws/observations/current')) {
      const stationIdMatch = /stationId=([A-Z0-9]+)/i.exec(url);
      const st = stationIdMatch && window.stazioni.find(x => x.stationId === stationIdMatch[1]);
      if (st) {
        const c = load(st);
        if (c) return Promise.resolve(new Response(JSON.stringify(c), {status:200, headers:{'Content-Type':'application/json'}}));
        if (!scheduled.has(st.stationId)) {
          scheduled.add(st.stationId);
          queue.push(st);     // bassa priorità
          worker();
        }
      }
      return nativeFetch(url, opts);
    }
    return origFetch.call(this, url, opts);
  };
})();
</script>
<!-- === /WU FASTLOAD VIEWPORT PATCH === -->

<!-- ChatGPT overlay mobile v3 2025-07-07 -->
<style id="overlay-mobile-v3-css">
#screenshotOverlay{
  background:rgba(255,255,255,0.85);
  backdrop-filter:blur(6px);
  border-radius:12px;
  border:1px solid rgba(0,0,0,0.1);
  padding:14px 16px 18px;
  box-shadow:0 6px 18px rgba(0,0,0,0.2);
  font-family:"Helvetica Neue",Arial,sans-serif;
  z-index:9999;
  max-width:420px;
}
#screenshotOverlay .close-btn{
  position:absolute;
  top:6px;
  right:10px;
  font-size:20px;
  font-weight:bold;
  cursor:pointer;
  color:#333;
}
@media(max-width:600px){
  #screenshotOverlay{
    width:auto;
    max-height:40vh;
  }
  #screenshotOverlay div{font-size:15px;}
}
</style>
<script id="overlay-mobile-v3">
(function(){
  if(window.__overlayV3) return;
  window.__overlayV3 = true;
  const MOBILE_MAX = 650; // px
  const OFFSET_BANNER = 56; // spazio sopra toolbar Safari

  window.generaScreenshot = function(){
    const mapEl = document.getElementById('map');
    if(!mapEl) return;

    let overlay = document.getElementById('screenshotOverlay');
    if(overlay){
        overlay.remove();
        return;
    }

    overlay = document.createElement('div');
    overlay.id = 'screenshotOverlay';
    overlay.className = 'top10-overlay';

    const close = document.createElement('div');
    close.className = 'close-btn';
    close.textContent = '\u00D7';
    close.onclick = ()=>overlay.remove();
    overlay.appendChild(close);

    // contenuto
    overlay.insertAdjacentHTML('beforeend',
      (typeof buildOverlayHTML==='function' ? buildOverlayHTML() : '<div>Overlay</div>')
    );

    // calcola offset sinistro dopo sidebar
    const sidebar = document.getElementById('sidebar');
    const rect = sidebar ? sidebar.getBoundingClientRect() : {width:0,left:0};
    const leftStart = rect.width + 12;

    if(window.innerWidth <= MOBILE_MAX){
        Object.assign(overlay.style,{
           position:'fixed',
           left: leftStart+'px',
           right:'10px',
           bottom:`calc(env(safe-area-inset-bottom) + ${OFFSET_BANNER}px)`
        });
    }else{
        Object.assign(overlay.style,{
           position:'absolute',
           top:'10px',
           right:'10px'
        });
    }

    overlay.style.overflowY = 'auto';

    mapEl.appendChild(overlay);
  };
})();
</script>
<!-- /overlay mobile v3 -->


<!-- ChatGPT overlay mobile v4 2025-07-07 -->
<style id="overlay-mobile-v4-css">
#screenshotOverlay{
  background:rgba(255,255,255,0.85);
  backdrop-filter:blur(6px);
  border-radius:12px;
  border:1px solid rgba(0,0,0,0.12);
  padding:14px 16px 18px;
  box-shadow:0 8px 18px rgba(0,0,0,0.25);
  overflow-y:auto;
  z-index:9999;
}
#screenshotOverlay .close-btn{
  position:absolute;
  top:6px;
  right:10px;
  font-size:22px;
  font-weight:bold;
  cursor:pointer;
  color:#333;
}
@media (max-width:650px){
    #screenshotOverlay{
        max-height:40vh;
        max-width:420px;
        width:auto;
    }
    #screenshotOverlay div{font-size:15px;}
}
</style>

<script id="overlay-mobile-v4-js">
(function(){
  if(window.__overlayMobileV4) return;
  window.__overlayMobileV4 = true;

  const MOBILE_MAX = 650; // px
  const OFFSET_BOTTOM = 72; // spazio sopra toolbar Safari

  window.generaScreenshot = function(){
      const mapEl = document.getElementById('map');
      if(!mapEl) return;

      let overlay = document.getElementById('screenshotOverlay');
      if(overlay){
          overlay.remove();
          return;
      }

      overlay = document.createElement('div');
      overlay.id = 'screenshotOverlay';
      overlay.className = 'top10-overlay';

      // pulsante chiusura
      const close = document.createElement('div');
      close.className = 'close-btn';
      close.textContent = '\u00D7';
      close.onclick = ()=>overlay.remove();
      overlay.appendChild(close);

      // contenuto dinamico
      overlay.insertAdjacentHTML('beforeend',
          (typeof buildOverlayHTML==='function' ? buildOverlayHTML() : '<div>Overlay</div>')
      );

      // Calcolo posizionamento mobile
      if(window.innerWidth <= MOBILE_MAX){
          const sidebar = document.getElementById('sidebar');
          const rect = sidebar ? sidebar.getBoundingClientRect() : {width:0,left:0};
          const leftStart = rect.width + 12;

          // larghezza massima disponibile
          const availW = window.innerWidth - leftStart - 12;
          const cardW = Math.min(420, availW);
          Object.assign(overlay.style,{
              position:'fixed',
              left:leftStart+'px',
              width: cardW+'px',
              bottom:`calc(env(safe-area-inset-bottom) + ${OFFSET_BOTTOM}px)`
          });
      }else{
          // desktop
          Object.assign(overlay.style,{
              position:'absolute',
              top:'10px',
              right:'10px',
              maxWidth:'420px'
          });
      }

      mapEl.appendChild(overlay);
  };
})();
</script>
<!-- /overlay mobile v4 -->

<!-- ChatGPT overlay mobile v5 – 08 lug 2025 -->
<style id="overlay-mobile-v5-css">
/* eventuale ritocco cosmetic (facoltativo) */
@media (max-width:650px){
  #screenshotOverlay{
    max-width:420px !important;   /* limite hard */
  }
}
</style>

<script id="overlay-mobile-v5-js">
(() => {
  if (window.__overlayMobileV5) return;      /* patch singola */
  window.__overlayMobileV5 = true;

  const MOBILE_MAX   = 650;  /* breakpoint */
  const OFFSET_BOTTOM= 72;   /* spazio sopra la toolbar di Safari/iOS */
  const SIDE_MARGIN  = 10;   /* margine destro fisso */
  const EXTRA_MARGIN = 24;   /* margine dopo la sidebar */
  const MAX_WIDTH    = 420;  /* larghezza massima card */

  /* larghezza sidebar + margine extra */
  const leftStart = () => {
    const sb = document.getElementById('sidebar');
    return (sb ? sb.getBoundingClientRect().width : 0) + EXTRA_MARGIN;
  };

  /* **sovrascrive** la funzione già esistente */
  window.generaScreenshot = function () {
    const mapEl = document.getElementById('map');
    if (!mapEl) return;

    /* se l’overlay è già aperto lo chiude */
    let ov = document.getElementById('screenshotOverlay');
    if (ov) { ov.remove(); return; }

    /* crea l’overlay */
    ov = document.createElement('div');
    ov.id        = 'screenshotOverlay';
    ov.className = 'top10-overlay';

    /* pulsante chiusura */
    const close = document.createElement('div');
    close.className = 'close-btn';
    close.textContent = '×';
    close.onclick = () => ov.remove();
    ov.appendChild(close);

    /* contenuto dinamico */
    ov.insertAdjacentHTML(
      'beforeend',
      typeof buildOverlayHTML === 'function' ? buildOverlayHTML() : '<div>Overlay</div>'
    );

    /* — Layout mobile — */
    if (window.innerWidth <= MOBILE_MAX) {
      const avail = window.innerWidth - leftStart() - SIDE_MARGIN;
      const w = Math.min(MAX_WIDTH, avail);

      /* posizionamento e dimensioni con !important */
      ov.style.setProperty('position', 'fixed');
      ov.style.setProperty('left',  leftStart() + 'px');
      ov.style.setProperty('right', SIDE_MARGIN + 'px');
      ov.style.setProperty('width', w + 'px', 'important');
      ov.style.setProperty('bottom',
        `calc(env(safe-area-inset-bottom) + ${OFFSET_BOTTOM}px)`
      );
    }
    /* — Layout desktop — */
    else {
      Object.assign(ov.style, {
        position : 'absolute',
        top      : '10px',
        right    : '10px',
        maxWidth : MAX_WIDTH + 'px'
      });
    }

    ov.style.overflowY = 'auto';
    mapEl.appendChild(ov);
  };
})();
</script>



<!-- === Overlay width fix with JS injection === -->
<script id="overlay-width-fix-js">
document.addEventListener('DOMContentLoaded', function() {
    var style = document.createElement('style');
    style.textContent = `
        #screenshotOverlay {
            max-width: 280px !important;
            width: auto !important;
            overflow-wrap: anywhere !important;
        }
    `;
    document.head.appendChild(style);
});
</script>

<!-- === Rain reconcile patch 2025‑07‑11 v11 (no auto‑switch, instant marker) === -->
<script id="rain_reconcile_20250711_v11">
(function(){
  if(globalThis.__rainReconcile) return;
  globalThis.__rainReconcile = true;

  const MAX_DIST_KM=7, WEIGHT=0.5, FAST=2000, SAFE=60000;
  const toRad=d=>d*Math.PI/180;
  const dist=(a,b,c,d)=>{const R=6371,dl=toRad(c-a),dn=toRad(d-b);const A=Math.sin(dl/2)**2+Math.cos(toRad(a))*Math.cos(toRad(c))*Math.sin(dn/2)**2;return 2*R*Math.asin(Math.sqrt(A));};

  const getG=()=>{try{if(typeof datiTabella==='undefined'||typeof stazioni==='undefined'||typeof markersById==='undefined')return null;return{datiTabella,stazioni,markersById};}catch(_){return null;}};

  const blend=(om,wu)=>+((om+WEIGHT*(wu-om)));

  /* ---- Popup helpers ---- */
  const updatePopupRow=(popup,val)=>{
    const el=popup.getElement(); if(!el) return;
    el.querySelectorAll('.popup-data').forEach(n=>{
      if(/Pioggia:/i.test(n.textContent)){
        n.innerHTML='<span class="bold">Pioggia:</span> '+val+' mm';
      }
    });
  };
  const patchPopup=popup=>{
    const src=popup._source, sid=src&&src.stationId, g=getG(); if(!sid||!g) return;
    const r=g.datiTabella.find(x=>x.stationId===sid); if(!r) return;
    const val=Number.isFinite(+r.pioggia)?(+r.pioggia):'0.0';
    updatePopupRow(popup,val);
  };

  /* ---- Reconcile ---- */
  let firstFix=false;
  const reconcile=()=>{
    const g=getG(); if(!g) return;
    const {datiTabella,stazioni,markersById}=g;

    const meta=Object.create(null);
    stazioni.forEach(s=>meta[s.stationId]=s);

    const wuRows=datiTabella.filter(r=>{const m=meta[r.stationId];return m&&!m.openMeteo&&Number.isFinite(+r.pioggia);});

    let changed=false;
    datiTabella.forEach(r=>{
      const m=meta[r.stationId]; if(!m||!m.openMeteo) return;
      if(r.__pioggiaOrig==null) r.__pioggiaOrig=Number.isFinite(+r.pioggia)?+r.pioggia:0;
      const om=r.__pioggiaOrig;

      let near=null,best=1e9;
      for(const w of wuRows){
        const wm=meta[w.stationId]; if(!wm) continue;
        const d=dist(m.lat,m.lon,wm.lat,wm.lon);
        if(d<best){best=d;near=w;}
      }
      if(!near||best>MAX_DIST_KM) return;

      const newVal=blend(om,+near.pioggia||0);
      if(newVal!==r.pioggia){r.pioggia=newVal; changed=true;}
      const mk=markersById[r.stationId];
      if(mk&&mk.options) mk.options.pioggiaFix=newVal;
    });

    if(!changed) return;
    firstFix=true;

    if(typeof aggiornaTabella==='function') aggiornaTabella();

    // if rain view is currently active, refresh markers without toggling views
    if(isRainActive() && typeof window.__rain_refreshMarkers==='function') window.__rain_refreshMarkers();

    if(typeof map!=='undefined'){
      map.eachLayer(l=>{ if(l&&l.isPopupOpen&&l.isPopupOpen()) patchPopup(l.getPopup()); });
    }
  };

  /* ---- Detect if rain view active and refresh markers ---- */
  const isRainActive = ()=> !!document.querySelector('.sidebar-btn.attivo[onclick*="visualizzaPioggia"]');

  // We'll inject a light wrapper around the original visualizzaPioggia once it's defined
  const wrapVis = ()=>{
    const fn=window.visualizzaPioggia;
    if(typeof fn!=='function' || fn.__rainWrapped) return;
    window.visualizzaPioggia=function(...a){
      reconcile();           // ensure latest numbers BEFORE drawing
      return fn.apply(this,a);
    };
    window.visualizzaPioggia.__rainWrapped=true;
    // Expose a helper to refresh markers without changing state
    window.__rain_refreshMarkers = fn.bind(window);
  };

  /* ---- Hook push only once ---- */
  const hookPush=arr=>{
    if(!Array.isArray(arr)||arr.__rainHooked) return;
    const orig=arr.push.bind(arr);
    arr.push=function(...it){const res=orig(...it);setTimeout(reconcile,0);return res;};
    arr.__rainHooked=true;
  };

  /* ---- Boot ---- */
  const boot=()=>{
    const g=getG(); if(!g){setTimeout(boot,300);return;}
    hookPush(g.datiTabella);
    reconcile();

    // wrap vis function once ready
    if(typeof window.visualizzaPioggia==='function') wrapVis();
    else{
      const tm=setInterval(()=>{
        if(typeof window.visualizzaPioggia==='function'){ clearInterval(tm); wrapVis(); }
      },200);
    }

    if(typeof map!=='undefined'){
      map.off('popupopen',globalThis.__rainPopupHook);
      globalThis.__rainPopupHook=e=>patchPopup(e.popup);
      map.on('popupopen',globalThis.__rainPopupHook);
    }

    const retry=setInterval(()=>{
      reconcile();
      if(firstFix){ clearInterval(retry); setInterval(reconcile,SAFE); }
    },FAST);
  };

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded',boot);
  else boot();
})();
</script>
<!-- ===== Micro‑task booster: carica migliaia di marker a piccoli lotti ===== -->
<script>
(function () {
  if (!window.stazioni || !Array.isArray(stazioni)) return;   // sicurezza robusta

  const CHUNK_SIZE = 250;           // numero di marker per lotto
  let index = 0;

  function processBatch(deadline) {
    while (index < stazioni.length &&
          (deadline.timeRemaining() > 2 || deadline.didTimeout)) {

      const s = stazioni[index++];
      try {
        if (typeof creaMarker === 'function') {
          creaMarker(s);            // tua utility originale
        } else if (window.L && L.marker) {
          L.marker([s.lat, s.lon]).addTo(window.mymap || window.map);
        }
      } catch (e) {
        console.error('Errore marker', e);
      }
    }
    if (index < stazioni.length) {
      requestIdleCallback(processBatch, { timeout: 50 });
    } else {
      console.log('⚡ Tutti i marker creati');
      if (typeof postMarkerInit === 'function') postMarkerInit();
    }
  }

  window.addEventListener('load', function () {
    requestIdleCallback(processBatch, { timeout: 100 });
  });
})();
</script>
<!-- ======================================================================= -->
<!-- === WU CONCURRENCY PATCH 2025‑07‑13 === -->
<script id="wu_concurrency_20250713">
(function () {
  if (!window.fetch) return;
  const orig = window.fetch;
  const MAX = 4;                   // fetch in parallelo
  const q   = [];
  let run = 0;

  function next() {
    if (run >= MAX || q.length === 0) return;
    const { url, args, resolve, reject } = q.shift();
    run++;
    orig(url, ...args)
      .then(r => resolve(r))
      .catch(e => reject(e))
      .finally(() => { run--; next(); });
  }

  window.fetch = function (url, ...args) {
    if (typeof url === "string" && url.includes("/v2/pws/observations/current")) {
      return new Promise((resolve, reject) => {
        q.push({ url, args, resolve, reject });
        next();
      });
    }
    return orig(url, ...args);
  };
})();
</script>
<!-- === /WU CONCURRENCY PATCH === -->

<script id="map-loader-script">
  document.addEventListener('DOMContentLoaded', () => {
    const banner = document.getElementById('map-loader-banner');
    const mapDiv = document.getElementById('map');
    const MIN_MS = 5000;
    const start = Date.now();

    function finalizeLoad() {
      const elapsed = Date.now() - start;
      const wait = Math.max(0, MIN_MS - elapsed);
      setTimeout(() => {
        banner.classList.add('hide');
        mapDiv.classList.remove('loading');
      }, wait);
    }

    if (window.map && typeof map.whenReady === 'function') {
      map.whenReady(finalizeLoad);
    } else {
      setTimeo
<script>
window.addEventListener('load', function(){
  try{ applyOffsetsAll(); }catch(e){}
  setTimeout(applyOffsetsAll, 800);
});
</script>
ut(finalizeLoad, MIN_MS);
    }
  });
</script>


<!-- === OFFSET CORE (CHATGPT) === -->
<script>
(function(){
  if(window.__offsetCore) return; window.__offsetCore=true;

  window.stationOffsets = window.stationOffsets || {};

  const clean = s => (s||'').toString().toLowerCase().replace(/[^a-z0-9]/g,'');
  const isNum = v => typeof v==='number' && !isNaN(v);

  window.__findOff = function(row){
    const cand=[row&&row.stationId,row&&row.id,row&&row.nome].map(clean);
    const OFF = window.stationOffsets;
    for(const k in OFF){
      const lk=clean(k);
      if(cand.some(c=>c===lk || (c&&lk&&(c.includes(lk)||lk.includes(c))))) return OFF[k];
    }
    return null;
  };

  window.applyOffsetRow = function(r){
    if(!r) return;
    const of = __findOff(r);
    if(!of) return;
    function add(list,key){
      if(typeof of[key]!=='number') return;
      list.forEach(f=>{
        if(r[f]!=null && isNum(+r[f])){
          const nv = +( (+r[f]) + of[key]);
          if(nv !== r[f]){ r[f]=nv; window.__changedFlag = true; }
        }
      });
    }
    add(['tempVal','temp'],'temp');
    add(['tMax','tmax'],'tmax');
    add(['tMin','tmin'],'tmin');
    add(['umidita'],'umidita');
    add(['pioggia'],'pioggia');
    add(['percepitaVal','percepita'],'percepita');
    add(['raffica'],'raffica');

    if(isNum(+r.tempVal)) r.temp = r.tempVal;
    if(isNum(+r.percepitaVal)) r.percepita = r.percepitaVal;

    if(window.extremiGiornalieri){
      const ext = window.extremiGiornalieri[r.stationId] = window.extremiGiornalieri[r.stationId] || {};
      if(isNum(+r.tMin)) ext.min = +r.tMin;
      if(isNum(+r.tMax)) ext.max = +r.tMax;
    }
  };

  window.applyOffsetObs = function(staz,obs){
    const of = __findOff({stationId:staz?.stationId||staz?.id, nome:staz?.nome});
    if(!of) return;
    if(isNum(+obs.temp)     && typeof of.temp ==='number') obs.temp     = +( (+obs.temp)    + of.temp );
    if(isNum(+obs.temp_max) && typeof of.tmax ==='number') obs.temp_max = +( (+obs.temp_max)+ of.tmax );
    if(isNum(+obs.temp_min) && typeof of.tmin ==='number') obs.temp_min = +( (+obs.temp_min)+ of.tmin );
  };

  window.applyOffsetsAll = function(){
    try{
      const g = window.getG && getG();
      const arr = g? g.datiTabella : window.datiTabella;
      if(Array.isArray(arr)) arr.forEach(applyOffsetRow);
    }catch(e){console.warn('applyOffsetsAll',e);}
  };

})();
</script>
<!-- === END OFFSET CORE === -->

<script>
/* force-hide loader if anything hangs */
window.addEventListener('load', function(){
  setTimeout(function(){
    var el=document.getElementById('map-loader-banner');
    if(el) el.classList.add('hide');
  }, 2000);
});
</script>

<!-- === FIX LOADER/BLUR === -->
<script>
(function(){
  function killLoader(){
    try{
      var ids=['map-loader-banner','mapLoader','loader','loading','loadingOverlay'];
      ids.forEach(function(id){ var el=document.getElementById(id); if(el) el.remove(); });
      // rimuovi classi che sfocano/disabilitano
      document.querySelectorAll('.blur,.blurred,.loading,.loading-mask').forEach(function(el){
        el.classList.remove('blur','blurred','loading','loading-mask');
        el.style.filter='';
        el.style.pointerEvents='';
        el.style.opacity='';
      });
    }catch(e){console.warn('killLoader err',e);}
  }
  window.addEventListener('load', function(){ setTimeout(killLoader, 6000); setTimeout(killLoader, 6500); });
})();
</script>
<!-- === END FIX LOADER/BLUR === -->

<!-- ===== FINAL PERF PATCH by ChatGPT (override-safe) ===== -->
<script type="module" id="perf-final">
/**
 * Obiettivo: UI fluida senza blocchi.
 * Metodo: lasciamo il codice originale, ma forniamo versioni ottimizzate delle funzioni pesanti.
 * Se qualcosa fallisce, facciamo fallback automatico all'originale.
 */

(function(){
  if(window.__perfFinalApplied__) return;
  window.__perfFinalApplied__ = true;

  // ---------- Helpers ----------
  async function chunkLoop(arr, size, fn){
    for(let i=0;i<arr.length;i++){
      fn(arr[i], i);
      if(i % size === 0){
        await new Promise(r=>requestAnimationFrame(r));
      }
    }
  }
  const queue=[]; let sch=false;
  function batchDOM(cb){
    queue.push(cb);
    if(!sch){
      sch=true;
      requestAnimationFrame(()=>{
        sch=false;
        const list = queue.splice(0);
        for(const f of list){ try{f();}catch(e){console.error(e);} }
      });
    }
  }

  function safeOverride(name, impl){
    const orig = window[name];
    if(typeof orig !== 'function'){ return; }
    window[name] = async function(...args){
      try{
        return await impl.apply(this, args);
      }catch(err){
        console.error('[perf-final] errore in', name, err);
        // fallback
        try{ return orig.apply(this, args);}catch(e){}
      }
    };
    window[name].__original = orig;
  }

  // textColor helper if missing
  if(typeof window.getTextColorForBackground !== 'function'){
    window.getTextColorForBackground = function(bg){
      if(!bg) return '#000';
      const c = bg.replace('#','');
      const r = parseInt(c.slice(0,2),16),
            g = parseInt(c.slice(2,4),16),
            b = parseInt(c.slice(4,6),16);
      const yiq = ((r*299)+(g*587)+(b*114))/1000;
      return yiq >= 128 ? '#000' : '#fff';
    };
  }

  // ---------- Overrides delle visualizzazioni ----------
  safeOverride('visualizzaAttuali', async function(){
    await chunkLoop(datiTabella, 200, (d)=>{
      const marker = markersById?.[d.stationId];
      if(!marker || isNaN(d.tempVal)) return;
      const colore = getColor(d.tempVal);
      const textColor = getTextColorForBackground(colore);
      batchDOM(()=>{
        const el = marker.getElement && marker.getElement();
        if(!el) return;
        el.innerHTML = `<span style="color:${textColor};">${d.temp}°</span>`;
        el.style.backgroundColor = colore;
      });
    });
  });

  safeOverride('visualizzaPercepita', async function(){
    await chunkLoop(datiTabella, 200, (d)=>{
      const marker = markersById?.[d.stationId];
      if(!marker || isNaN(d.percepitaVal)) return;
      const colore = getColor(d.percepitaVal);
      const textColor = getTextColorForBackground(colore);
      batchDOM(()=>{
        const el = marker.getElement && marker.getElement();
        if(!el) return;
        el.innerHTML = `<span style="color:${textColor};">${d.percepita}</span>`;
        el.style.backgroundColor = colore;
      });
    });
  });

  safeOverride('visualizzaUmidita', async function(){
    await chunkLoop(datiTabella, 200, (d)=>{
      const marker = markersById?.[d.stationId];
      if(!marker || isNaN(d.umidita)) return;
      const colore = getColorUmidita(d.umidita);
      const textColor = getTextColorForBackground(colore);
      batchDOM(()=>{
        const el = marker.getElement && marker.getElement();
        if(!el) return;
        el.innerHTML = `<span style="color:${textColor};">${d.umidita}%</span>`;
        el.style.backgroundColor = colore;
      });
    });
  });

  safeOverride('visualizzaRaffiche', async function(){
    await chunkLoop(datiTabella, 200, (d)=>{
      const marker = markersById?.[d.stationId];
      if(!marker || isNaN(d.raffica)) return;
      const colore = getColorVento(d.raffica);
      const textColor = getTextColorForBackground(colore);
      batchDOM(()=>{
        const el = marker.getElement && marker.getElement();
        if(!el) return;
        el.innerHTML = `<span style="color:${textColor};">${d.raffica}</span>`;
        el.style.backgroundColor = colore;
        el.style.width = '48px';
        el.style.height = '48px';
      });
    });
  });

  safeOverride('visualizzaEstremi', async function(tipo='max'){
    await chunkLoop(datiTabella, 200, (d)=>{
      const marker = markersById?.[d.stationId];
      if(!marker) return;
      const val = typeof getEstremoGiornaliero === 'function' ? getEstremoGiornaliero(d.stationId, tipo) : null;
      if(val==null || isNaN(val)) return;
      const colore = getColor(val);
      const textColor = getTextColorForBackground(colore);
      batchDOM(()=>{
        const el = marker.getElement && marker.getElement();
        if(!el) return;
        el.innerHTML = `<span style="color:${textColor};">${val}°</span>`;
        el.style.backgroundColor = colore;
      });
    });
  });

  // ---------- caricaDatiOpenMeteo ottimizzata ----------
  safeOverride('caricaDatiOpenMeteo', async function(){
    const orig = arguments.callee.__original;
    try{
      const src = stazioni.filter(s=>s.openMeteo);
      const risultati = [];
      const maxParallel = 8;
      let idx = 0;
      async function worker(){
        while(idx < src.length){
          const st = src[idx++];
          try{
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${st.lat}&longitude=${st.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m,wind_speed_10m&daily=temperature_2m_max,temperature_2m_min&timezone=auto`;
            const data = await fetch(url).then(r=>r.json());
            const t = data?.current?.temperature_2m;
            const rh = data?.current?.relativehumidity_2m;
            const ws = data?.current?.wind_speed_10m;
            const perc = typeof calcolaPercepita === 'function' ? calcolaPercepita(t,rh,ws) : null;
            risultati.push({
              stationId: st.stationId,
              temp: t,
              tempVal: t,
              pioggia: data?.current?.precipitation,
              umidita: rh,
              raffica: data?.current?.wind_gusts_10m,
              percepita: (perc!=null && isFinite(perc)) ? perc : '--',
              percepitaVal: perc
            });
          }catch(e){ console.warn('OpenMeteo error', e); }
          await new Promise(r=>requestAnimationFrame(r));
        }
      }
      await Promise.all(Array.from({length: Math.min(maxParallel, src.length)}, worker));
      datiTabella.push(...risultati);
    }catch(e){
      console.error('Fallback caricaDatiOpenMeteo -> originale', e);
      return orig && orig.apply(this, arguments);
    }
  });

  console.log('[perf-final] patch attivata');
})();
</script>


<!-- === ChatGPT initial alignment patch 2025‑07‑24 === -->
<script>
(function(){
  function renderAttuali(){
     try{
       if(typeof applyOffsetsAll==='function') applyOffsetsAll();
       if(typeof visualizzaAttuali==='function') visualizzaAttuali();
     }catch(e){ console.warn('initAlign',e); }
  }
  window.addEventListener('load', function(){
     const btn = document.querySelector(".sidebar-btn[onclick*='visualizzaAttuali']");
     if(btn) btn.classList.add('attivo');

     renderAttuali();                  // prima passata

     // altri tentativi nei primi 5 secondi per catturare le stazioni che arrivano in ritardo
     let tentativi = 0;
     const timer = setInterval(function(){
        renderAttuali();
        if(++tentativi >= 5) clearInterval(timer);
     }, 1000);
  });
})();
</script>
<!-- === /ChatGPT patch === -->


<!-- === Metric popup fix 2025‑07‑24 === -->
<script id="metric_popup_fix_20250724">
(function(){
  if(globalThis.__metricPopupFix) return;
  globalThis.__metricPopupFix = true;

  function getG(){
      try{ return { datiTabella, markersById }; }catch(_){ return null; }
  }

  function fmt(v, unit){
      var n = parseFloat(v);
      return Number.isFinite(n) ? n + unit : '--';
  }

  function patchPopup(popup){
      if(!popup || typeof popup.getElement !== 'function') return;
      const g = getG(); if(!g) return;
      const sid = popup._source && popup._source.stationId;
      if(!sid) return;
      const row = g.datiTabella && g.datiTabella.find(r => r.stationId === sid);
      if(!row) return;

      const el = popup.getElement();
      el.querySelectorAll('.popup-data').forEach(n=>{
          var txt = n.textContent || '';
          if(/Temp:\s*/i.test(txt)){
              n.innerHTML = '<span class="bold">Temp:</span> ' + fmt(row.temp, '°C');
          }else if(/Umidità:/i.test(txt)){
              n.innerHTML = '<span class="bold">Umidità:</span> ' + fmt(row.umidita, '%');
          }else if(/Temp\.\s*percepita:/i.test(txt)){
              n.innerHTML = '<span class="bold">Temp. percepita:</span> ' + fmt(row.percepita, '°C');
          }
      });
  }

  function boot(){
      const m = window.map || window.mymap;
      if(!m){ setTimeout(boot, 300); return; }

      m.on('popupopen', e => patchPopup(e.popup));

      // Hook reconcile (se esiste) per aggiornare popup aperto
      const rec = window.reconcile;
      if(typeof rec === 'function' && !rec.__popupHooked){
          window.reconcile = function(...a){
              const res = rec.apply(this, a);
              if((window.map || window.mymap)?._popup) patchPopup((window.map || window.mymap)._popup);
              return res;
          };
          window.reconcile.__popupHooked = true;
      }
  }

  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>
<!-- === /Metric popup fix === -->

<!-- ===== PATCH MARKER DECIMALS & OFFSET CLEAN v1 (non invasiva) ===== -->
<script>
(function(){
  const fnList = [
    'aggiungiMarker','visualizzaAttuali','visualizzaUmidita','visualizzaPercepita',
    'visualizzaRaffiche','visualizzaEstremi','visualizzaPioggia','aggiornaTabella'
  ];

  function oneDec(num){
    const v = parseFloat(String(num).replace(',', '.'));
    return Number.isFinite(v) ? v : num;
  }

  function cleanMarkerEl(el){
    if(!el) return;
    const span = el.querySelector('span');
    if(!span) return;
    const hasDegree = /°/.test(span.textContent);
    const m = span.textContent.replace(',', '.').match(/-?\d+(?:\.\d+)?/);
    if(m){
      span.textContent = oneDec(m[0]) + (hasDegree ? '°' : '');
    }
  }

  function cleanAllMarkers(){
    document.querySelectorAll('.leaflet-marker-icon').forEach(cleanMarkerEl);
  }

  // sanitize color helpers that erroneously returned "</div>" in the string
  function safeBg(el, color){
    if(!el) return;
    if(typeof color === 'string'){
      const c = color.replace(/<\/div>/gi,'').trim();
      el.style.backgroundColor = c;
    }
  }

  // hook commonly used functions to re‑clean after they run
  function wrap(name){
    const orig = window[name];
    if(typeof orig !== 'function' || orig.__oneDecWrapped) return;
    window[name] = function(){
      const res = orig.apply(this, arguments);
      // After the underlying function rendered, re‑enforce one decimal on markers
      try{ cleanAllMarkers(); }catch(e){}
      return res;
    };
    window[name].__oneDecWrapped = true;
  }

  fnList.forEach(wrap);

  // First run on DOM ready and a little later (in case markers arrive async)
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(cleanAllMarkers, 800);
    setInterval(cleanAllMarkers, 4000); // keep it clean without being heavy
  });

  // Export small utility if you want to call it manually
  window.__fixMarkersOneDecimal = cleanAllMarkers;

  // Format also the open‑meteo push so it NEVER introduces 2 decimals
  const origCarica = window.caricaDatiOpenMeteo;
  if (typeof origCarica === 'function' && !origCarica.__oneDecWrappedOM) {
    window.caricaDatiOpenMeteo = async function(){
      const res = await origCarica.apply(this, arguments);
      try {
        if(Array.isArray(window.datiTabella)){
          window.datiTabella.forEach(d=>{
            if(d && d.tempVal != null){
              const tv = parseFloat(d.tempVal);
              if(Number.isFinite(tv)){
                d.tempVal = parseFloat(tv);
                d.temp = d.tempVal;
              }
            }
          });
        }
        cleanAllMarkers();
      } catch(e){}
      return res;
    };
    window.caricaDatiOpenMeteo.__oneDecWrappedOM = true;
  }
})();
</script>

<!-- === ClampTemp Patch v6 – 25 Jul 2025 === -->
<script>
(function(){
  if(window.__clampTempPatchV6) return;
  window.__clampTempPatchV6 = true;

  function num(x){
    if(x==null) return NaN;
    if(typeof x==='number') return x;
    if(typeof x==='string'){
      return parseFloat(x.replace(',','.'));
    }
    return NaN;
  }

  function clampTemp(val,sid){
    let v=num(val);
    let max=num(getEstremoGiornaliero?.(sid,'max'));
    let min=num(getEstremoGiornaliero?.(sid,'min'));
    if(Number.isFinite(max) && v>max) v=max;
    if(Number.isFinite(min) && v<min) v=min;
    return v;
  }

  function clampRow(r){
    if(!r || !r.stationId) return;
    const cv=clampTemp(r.temp??r.tempVal, r.stationId);
    r.temp=cv;
    r.tempVal=cv;
  }

  function clampData(){
    if(!window.datiTabella) return;
    datiTabella.forEach(clampRow);
  }

  function syncUI(){
    if(!window.datiTabella||!window.markersById) return;
    datiTabella.forEach(r=>{
      const v=num(r.temp);
      const mk=markersById[r.stationId];
      if(mk){
        const el=mk.getElement();
        if(el){
          const span=el.querySelector('span');
          if(span) span.textContent=v+'°';
          if(window.getColor) el.style.backgroundColor=getColor(v);
        }
        const popup=mk.getPopup && mk.getPopup();
        if(popup && popup.isOpen && popup.isOpen()){
          const n=popup.getElement();
          if(n){
            [...n.querySelectorAll('.popup-data')].forEach(node=>{
              if(/Temp:/i.test(node.textContent)){
                 node.innerHTML='<span class="bold">Temp:</span> '+v+'°C';
              }else if(/Temp\. percepita:/i.test(node.textContent)){
                 // leave percepita alone
              }
            });
          }
        }
      }
      // Tabella
      const cell=document.querySelector(`[data-station-id='${r.stationId}'][data-field='temp']`);
      if(cell) cell.textContent=v;
    });
  }

  function enforce(){
    clampData();
    syncUI();
  }

  function wrap(name){
    const orig=window[name];
    if(typeof orig!=='function' || orig.__clampWrapped) return;
    window[name]=function(){
      clampData();
      const res=orig.apply(this,arguments);
      syncUI();
      return res;
    };
    window[name].__clampWrapped=true;
  }

  ['visualizzaAttuali','aggiornaTabella','reconcile','applyOffsetsAll','aggiornaPopupConEstremiFinale','creaTabella'].forEach(wrap);

  document.addEventListener('DOMContentLoaded',()=>setTimeout(enforce,1000));
  setInterval(enforce,3000);
})();
</script>

<script id="block-page-pinch">
  /* Versione migliorata:
     - Intercetta qualsiasi gesto pinch (2+ dita) sull'intera pagina e
       ne blocca lo zoom di default, così la pagina non scala più.
     - Leaflet continua comunque a ricevere gli eventi touch e gestisce
       internamente lo zoom mappa, anche quando il pinch parte da un popup.
     - Copre sia Safari/iOS (gesture*) che Chrome/Android (touchmove).
  */
  (function () {
    // Per Safari / iOS
    ['gesturestart', 'gesturechange', 'gestureend'].forEach(function(ev) {
      document.addEventListener(ev, function (e) {
        e.preventDefault();
      }, { passive: false });
    });

    // Per Chrome / Android & altri: blocca default del pinch
    var cancelPinch = function (e) {
      if (e.touches && e.touches.length > 1) {
        e.preventDefault();
      }
    };
    document.addEventListener('touchmove', cancelPinch, { passive: false });

    /* Nota: Leaflet, che utilizza internamente touchstart/touchmove
       sul contenitore mappa, continua a funzionare perché riceve gli
       stessi eventi (la propagazione non viene bloccata). */
  })();
</script>

<!-- === ChatGPT precipitation & humidity offset patch 2025‑08‑05 === -->
<script id="precip_humidity_offset_patch">
(function(){
  if(window.__precipHumPatch) return;
  window.__precipHumPatch = true;

  function isNum(v){ return typeof v==='number' && !isNaN(v); }

  const origApply = window.applyOffsetRow;
  if(typeof origApply!=='function') return;

  window.applyOffsetRow = function patchedApply(r){
      if(!r) return origApply && origApply.call(this, r);

      const beforeRain = isNum(r.pioggia) ? +r.pioggia : null;
      const beforeHum  = isNum(r.umidita) ? +r.umidita : null;

      /* run original logic */
      origApply && origApply.call(this, r);

      /* --- Rain rules -------------------------------------------------- */
      if(beforeRain!=null){
         if(beforeRain <= 0.1){
            /* do NOT apply any offset if raw rain ≤0.1 mm */
            r.pioggia = parseFloat(beforeRain);
         }else if(isNum(r.pioggia)){
            /* never show negative after offsets */
            if(r.pioggia < 0) r.pioggia = 0;
         }
      }

      /* --- Humidity rules --------------------------------------------- */
      if(isNum(r.umidita)){
         if(r.umidita > 100) r.umidita = 100;
         if(r.umidita < 4)   r.umidita = 4;     /* clamp lower bound */
      }
  };
})();
</script>
<!-- === /patch === -->


<!-- === ChatGPT precipitation & humidity offset patch v2 2025‑08‑05 === -->
<script id="precip_humidity_offset_patch_v2">
(function(){
  if(window.__precipHumPatchV2) return;
  window.__precipHumPatchV2 = true;

  function isNum(v){ return typeof v==='number' && !isNaN(v); }

  /* ---------- patch applyOffsetRow (if present) ------------ */
  const origApply = window.applyOffsetRow;
  if(typeof origApply==='function'){
    window.applyOffsetRow = function patchedApply(r){
        if(!r) return origApply.call(this, r);

        const rawRain = isNum(r.pioggia) ? +r.pioggia : null;
        const rawHum  = isNum(r.umidita) ? +r.umidita : null;

        /* let original code run first (offsets applied) */
        origApply.call(this, r);

        /* ------- Rain rules -------- */
        if(rawRain!=null){
           if(rawRain <= 0.1){
              r.pioggia = parseFloat(rawRain);
           }else if(isNum(r.pioggia) && r.pioggia < 0){
              r.pioggia = 0;
           }
        }

        /* ------- Humidity rules ---- */
        if(isNum(r.umidita)){
           if(r.umidita > 100) r.umidita = 100;
           if(r.umidita < 4)   r.umidita = 4;
        }
    };
  }

  /* ------ Clamp existing data (already offset) ------------- */
  function clampExisting(){
     const visited = new WeakSet();
     function traverse(obj){
        if(obj===null || typeof obj!=='object' || visited.has(obj)) return;
        visited.add(obj);

        if('pioggia' in obj){
           const v = parseFloat(obj.pioggia);
           if(!isNaN(v) && v < 0) obj.pioggia = 0;
        }
        if('umidita' in obj){
           let h = parseFloat(obj.umidita);
           if(!isNaN(h)){
              if(h > 100) h = 100;
              if(h < 4)   h = 4;
              obj.umidita = h;
           }
        }

        for(const key in obj){
          traverse(obj[key]);
        }
     }

     for(const key in window){
        try{
           traverse(window[key]);
        }catch(e){}
     }
  }

  if(document.readyState === 'complete'){
     clampExisting();
  }else{
     window.addEventListener('load', clampExisting);
  }
})();
</script>
<!-- === /patch v2 === -->


<!-- === ChatGPT Patch 2025‑10‑08: Kelvin fix + Station name fallback + MH daily precip === -->
<script id="kelvin_name_precip_patch_20251008">
(function(){
  if (window.__kelvinNamePrecipPatch_20251008) return;
  window.__kelvinNamePrecipPatch_20251008 = true;

  /* ---------- Helpers ---------- */
  function isNum(v){ return typeof v === "number" && isFinite(v); }
  function KtoC(v){
    const n = parseFloat(v);
    if (!isFinite(n)) return v;
    // guard against absurd negatives (bad sensors) but keep valid °C (e.g., -20..60)
    return (n > 120 ? (n - 273.15) : n);
  }
  function fixTempField(obj, key){
    if (!obj || !(key in obj)) return;
    const n = parseFloat(obj[key]);
    if (!isFinite(n)) return;
    const c = KtoC(n);
    if (c !== n){
      obj[key] = parseFloat(c);
      const strKey = (key === "temp" ? "temp" : key);
      if (strKey === "temp") obj["temp"] = obj[key];
    }
  }
  function coerceName(s){
    if(!s) return null;
    s = String(s).trim();
    if(!s || /^stazione$/i.test(s)) return null;
    if(/^\(?--\)?$/.test(s)) return null;
    return s;
  }

  /* ---------- 1) Sanitize extremiGiornalieri (Kelvin→°C) ---------- */
  (function guardExtremi(){
    let _ext = window.extremiGiornalieri || {};
    function sanitizeAll(obj){
      if(!obj || typeof obj!=="object") return;
      for(const id in obj){
        const e = obj[id];
        if(!e) continue;
        if("min" in e && isNum(e.min)) e.min = parseFloat(KtoC(e.min));
        if("max" in e && isNum(e.max)) e.max = parseFloat(KtoC(e.max));
      }
    }
    sanitizeAll(_ext);
    Object.defineProperty(window, "extremiGiornalieri", {
      configurable: true,
      get(){ return _ext; },
      set(v){
        _ext = v || {};
        sanitizeAll(_ext);
        // refresh popup/markers if functions exist
        try{ if(typeof window.aggiornaPopup === "function") window.aggiornaPopup(); }catch(e){}
      }
    });
  })();

  /* ---------- 2) Wrap datiTabella.push per Kelvin & name fallback ---------- */
  (function guardTabella(){
    if(!Array.isArray(window.datiTabella)){
      window.datiTabella = [];
    }
    const byId = Object.create(null); // quick lookup
    function sanitizeRow(r){
      if(!r) return;
      // Kelvin → °C on all relevant numeric fields
      ["tempVal","tMin","tMax","percepitaVal"].forEach(k=>fixTempField(r,k));
      if (isNum(r.tempVal)) r.temp = r.tempVal;
      // Humidity bounds
      if (isNum(r.umidita)){
        if (r.umidita > 100) r.umidita = 100;
        if (r.umidita < 0)   r.umidita = 0;
      }
      // Name fallback
      if (!coerceName(r.nome)){
        const st = (window.stazioni || []).find(x => x && x.stationId === r.stationId);
        r.nome = coerceName(st && (st.nome || st.name)) ||
                 (st && (st.area || st.comune || st.municipality)) ||
                 (r.stationId ? ("Stazione " + r.stationId) : "Stazione");
      }
      byId[r.stationId] = r;
    }
    // sanitize already present rows
    try { window.datiTabella.forEach(sanitizeRow); } catch(e){}
    const origPush = window.datiTabella.push;
    window.datiTabella.push = function(...args){
      args.forEach(sanitizeRow);
      return origPush.apply(this, args);
    };
  })();

  /* ---------- 3) Fix popups that still show Kelvin in text ---------- */
  (function patchPopupKelvin(){
    function KtoCnum(n){ return (n>120? (n-273.15): n); }
    function convertInPopup(el){
      if(!el) return;
      // replace numbers like 2xx.x°C with converted values on Min/Max rows only
      el.querySelectorAll(".popup-data").forEach(row=>{
        const txt = row.textContent || "";
        if(/\b(Min|Max)/i.test(txt)){
          const matches = txt.match(/(-?\d+(?:[\.,]\d+)?)\s*°C/g);
          if(matches){
            let newTxt = txt;
            matches.forEach(tok=>{
              const num = parseFloat(tok.replace("°C","").replace(",","."));
              const conv = KtoCnum(num);
              if (conv !== num){
                const rep = tok.replace(String(num), conv);
                newTxt = newTxt.replace(tok, rep);
              }
            });
            row.textContent = newTxt;
          }
        }
      });
    }
    function hook(){
      const mapObj = window.map || window.mymap;
      if(!mapObj){ setTimeout(hook,500); return; }
      mapObj.on("popupopen", e=>{
        try{ convertInPopup(e.popup && e.popup.getElement && e.popup.getElement()); }catch(_){}
      });
    }
    hook();
  })();

  /* Daily precipitation via Open‑Meteo (disabled: now using MeteoHub API totals) */
<script>(function(){ /* disabled */ })();</script>

<!-- === BEGIN: MeteoHub full integration (Lo Gullo) — 2025‑10‑08 === -->
<script>
(function(){
  if (window.__MH_full_20251008) return;
  window.__MH_full_20251008 = true;

  /* ====== CONFIG ====== */
  const ENDPOINT = "https://meteohub.agenziaitaliameteo.it/api/observations";
  // Limita l’area per velocità (Calabria): regola se ti serve più largo
  const BBOX = { minLat: 36.8, maxLat: 40.6, minLon: 14.8, maxLon: 17.6 };
  const MINUTES_BACK_FETCH = 24 * 60;        // scarichiamo le ultime 24h per calcolare estremi e pioggia
  const REFRESH_MS = 3 * 60 * 1000;          // refresh ogni 3 minuti
  const MAX_STAZIONI = 1200;                 // hard‑cap utile
  const STATION_PREFIX = "MH_";              // id per distinguere le meteohub

  // utile per debug
  const LOG = function(){/* console.log.apply(console, arguments); */}

  /* ====== UTIL ====== */
  function pad(n){ return String(n).padStart(2,"0"); }
  function fmtUTC(d){ return `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())} ${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}`; }
  function todayIso(){ return new Date().toISOString().slice(0,10); }
  function isToday(ts){
    if(!ts) return false;
    const d = new Date(ts);
    return d.toISOString().slice(0,10) === todayIso();
  }
  function isFiniteNum(v){ return typeof v === "number" && isFinite(v); }
  function toNumber(v){
    if (v == null) return null;
    const n = Number(v);
    return isFinite(n) ? n : null;
  }
  function KtoC(n){
    const x = toNumber(n);
    if (x == null) return null;
    return x > 120 ? x - 273.15 : x;
  }
  function inBbox(lat,lon){
    return isFinite(lat) && isFinite(lon) &&
      lat >= BBOX.minLat && lat <= BBOX.maxLat &&
      lon >= BBOX.minLon && lon <= BBOX.maxLon;
  }
  function buildQueryUrl(){
    const now = new Date();
    const from = new Date(now.getTime() - MINUTES_BACK_FETCH*60*1000);
    const q = `reftime: >=${fmtUTC(from)},<=${fmtUTC(now)};product:B12101;license:CCBY_COMPLIANT`;
    const u = new URL(ENDPOINT);
    u.searchParams.set("q", q);
    u.searchParams.set("reliabilityCheck", "true");
    u.searchParams.set("ts", Date.now());
    return u.toString();
  }

  // Estrae un array [ {val, time}, ... ] dal campo .val di un prodotto
  function extractSeries(prod){
    if (!prod) return [];
    const raw = prod.val || prod.values || prod.series || prod;
    let out = [];
    if (Array.isArray(raw)) {
      for (const r of raw){
        if (r && typeof r === "object" && ("val" in r)){
          const v = toNumber(r.val);
          const t = r.ref || r.time || r.ts || r.reftime;
          if (v != null && t) out.push({val: v, time: t});
        } else if (typeof r === "number"){
          out.push({val: r, time: null});
        }
      }
    } else if (typeof raw === "number"){
      out.push({val: raw, time: null});
    }
    return out;
  }

  // cerca un prodotto per codice/chiave
  function getProd(st, code){
    const pool = st?.prod || st?.products || st?.var || st?.variables || st;
    if (!pool) return null;
    if (Array.isArray(pool)) {
      return pool.find(x => (String(x.var||x.code||"").toUpperCase() === String(code).toUpperCase())) || null;
    } else if (typeof pool === "object") {
      return pool[code] || pool[String(code)] || null;
    }
    return null;
  }

  // cerca prodotti "precip" se non sappiamo il codice: match su key/desc/name
  function findAnyPrecipProducts(st){
    const pool = st?.prod || st?.products || st?.var || st?.variables || st;
    const out = [];
    if (Array.isArray(pool)){
      for (const p of pool){
        const key = String(p?.var || p?.code || "").toUpperCase();
        const desc = (p?.desc || p?.name || p?.label || "").toUpperCase();
        if (/RAIN|PRECIP/i.test(key) || /RAIN|PRECIP/i.test(desc)) out.push(p);
      }
    } else if (typeof pool === "object" && pool){
      for (const k of Object.keys(pool)){
        const p = pool[k];
        const desc = (p?.desc || p?.name || p?.label || k).toUpperCase();
        if (/RAIN|PRECIP/i.test(k) || /RAIN|PRECIP/i.test(desc)) out.push(p);
      }
    }
    return out;
  }

  // rileva se una serie di precipitazione è cumulata o incrementale, poi calcola il totale OGGI
  function rainTodayFromSeries(series){
    if (!Array.isArray(series) || !series.length) return 0;
    // filtra solo oggi e ordina per tempo
    const s = series
      .filter(p => isToday(p.time))
      .filter(p => p.time != null)
      .sort((a,b)=> new Date(a.time)-new Date(b.time));
    if (!s.length) return 0;
    // controlla monotonia (cumulata)
    let nonDecreasing = true;
    for (let i=1;i<s.length;i++){
      if (s[i].val < s[i-1].val - 1e-6) { nonDecreasing = false; break; }
    }
    if (nonDecreasing){
      return Math.max(0, s[s.length-1].val - s[0].val);
    }
    // altrimenti assumiamo serie incrementale (mm/5-10min): somma
    let sum = 0;
    for (const p of s){
      if (isFiniteNum(p.val) && p.val >= 0) sum += p.val;
    }
    return sum;
  }

  // Estrae tutti i campi consolidati da una stazione grezza MH
  function normalizeStation(st){
    const lat = toNumber(st.lat ?? st.latitude ?? st.stat?.lat);
    const lon = toNumber(st.lon ?? st.longitude ?? st.stat?.lon);
    const detailsArr = Array.isArray(st.stat?.details) ? st.stat.details : null;
const longNameMH = detailsArr?.find(d => String(d.var || d.code || "").toUpperCase() === "B01019")?.val;
const name = st.name
          || st.station_name
          || st.stat?.name
          || longNameMH
          || (st.stat && (st.stat["LONG STATION OR SITE NAME"] || st.stat["Long station or site name"]))
          || "Stazione";
    const id = String(st.id || st.station_id || st.code || st.slug || `${lat},${lon}`);
    const time = st.time || st.timestamp || st.reftime || st.obs_time || new Date().toISOString();

    // temperature B12101
    let tProd = getProd(st, "B12101");
    let t = null;
    if (tProd && typeof tProd === "object"){
      const s = extractSeries(tProd);
      if (s.length){
        t = KtoC(s[s.length-1].val);
      } else if (isFiniteNum(tProd.val)) {
        t = KtoC(tProd.val);
      }
    }
    if (t == null) t = KtoC(st.temperature ?? st.temp ?? st.t);

    // RH
    let rhProd = getProd(st, "B13003");
    let rh = null;
    if (rhProd){
      const s = extractSeries(rhProd);
      rh = s.length ? toNumber(s[s.length-1].val) : toNumber(rhProd.val);
    }
    if (rh == null) rh = toNumber(st.humidity ?? st.rh);

    // wind speed & gust – codici variano, proviamo alcuni comuni
    function lastNumFrom(codeList){
      for (const c of codeList){
        const p = getProd(st, c);
        if (!p) continue;
        const s = extractSeries(p);
        if (s.length) return toNumber(s[s.length-1].val);
        if (isFiniteNum(p.val)) return toNumber(p.val);
      }
      return null;
    }
    const ws = lastNumFrom(["B11001","B11002","WIND_SPEED","WS","FF"]) ?? toNumber(st.wind_speed ?? st.ws);
    const wg = lastNumFrom(["B11041","B11042","WIND_GUST","WG","FX"]) ?? toNumber(st.wind_gust ?? st.wg ?? ws);

    // precipitation – cerchiamo prodotti “RAIN|PRECIP”, poi decidiamo cumulata vs incrementale
    let rainSeries = [];
    const candidates = [
      getProd(st, "B13011"), getProd(st,"B13051"), getProd(st,"B13111"),
      getProd(st,"RAIN"), getProd(st,"RAIN_MM"), getProd(st,"PRECIP"),
      ...findAnyPrecipProducts(st)
    ].filter(Boolean);
    for (const p of candidates){
      const s = extractSeries(p);
      if (s.length) { rainSeries = s; break; }
    }
    let rain_today = rainTodayFromSeries(rainSeries);

    return { id: STATION_PREFIX+id, name, lat, lon, time, t, rh, ws, wg, rain_today, rainSeries };
  }

  // Calcolo min/max giornalieri su base MeteoHub
  const MINMAX_KEY = "mh_minmax_20251008";
  function loadMinMax(){
    try{
      const j = JSON.parse(localStorage.getItem(MINMAX_KEY)||"{}");
      const d = todayIso();
      if (j.day !== d) return {day:d, byId:{}};
      return j;
    }catch{ return {day: todayIso(), byId:{}}; }
  }
  function saveMinMax(x){ localStorage.setItem(MINMAX_KEY, JSON.stringify(x)); }

  // Aggiorna Tabella e Popups integrandosi con le funzioni esistenti
  function integrateRows(rows){
    window.datiTabella = window.datiTabella || [];
    const isMH = r => String(r.stationId||"").startsWith(STATION_PREFIX);

    // rimuovi vecchie righe MH
    for (let i = window.datiTabella.length - 1; i >= 0; i--){
      if (isMH(window.datiTabella[i])) window.datiTabella.splice(i,1);
    }
    // inserisci nuove
    for (const r of rows){
      const percepita = (typeof window.calcolaPercepita === "function")
        ? window.calcolaPercepita(r.t, r.rh, r.ws) : null;
      window.datiTabella.push({
        stationId: r.id,
        nome: r.name,
        temp: isFiniteNum(r.t) ? +r.t : "--",
        tempVal: isFiniteNum(r.t) ? r.t : null,
        umidita: isFiniteNum(r.rh) ? +r.rh : "--",
        vento: isFiniteNum(r.ws) ? +r.ws : "--",
        raffica: isFiniteNum(r.wg) ? +r.wg : "--",
        pioggia: isFiniteNum(r.rain_today) ? +r.rain_today : 0,
        percepita: isFiniteNum(percepita) ? +percepita : "--",
        percepitaVal: percepita
      });
    }

    if (typeof window.aggiornaTabella === "function") window.aggiornaTabella();
    if (typeof window.visualizzaAttuali === "function") window.visualizzaAttuali();
  }

  // Patch popup: aggiorna valori live e mostra min/max/precipitazione day
  function patchPopupBehaviour(){
    const m = window.map || window.mymap;
    if (!m) { setTimeout(patchPopupBehaviour, 400); return; }
    m.on("popupopen", e => {
      const el = e.popup && e.popup.getElement && e.popup.getElement();
      if (!el) return;
      const sid = e.popup._source && e.popup._source.stationId;
      const r = (window.datiTabella||[]).find(x => x.stationId === sid);
      if (!r) return;

      function fmt(n,unit){ const v = Number(n); return isFinite(v) ? v.toFixed(unit ? 1 : 0) + (unit||"") : "--"; }
      el.querySelectorAll(".popup-data").forEach(n => {
        const txt = n.textContent || "";
        if (/Temp:\s*/i.test(txt)) n.innerHTML = '<span class="bold">Temp:</span> '+fmt(r.temp, "°C");
        else if (/Umidità:/i.test(txt)) n.innerHTML = '<span class="bold">Umidità:</span> '+fmt(r.umidita, "%");
        else if (/Temp\.\s*percepita:/i.test(txt)) n.innerHTML = '<span class="bold">Temp. percepita:</span> '+fmt(r.percepita,"°C");
        else if (/Vento:/i.test(txt)) n.innerHTML = '<span class="bold">Vento:</span> '+fmt(r.vento," km/h")+' / <span class="bold">Raffica:</span> '+fmt(r.raffica," km/h");
        else if (/Pioggia:/i.test(txt)) n.innerHTML = '<span class="bold">Pioggia:</span> '+fmt(r.pioggia," mm");
      });
      // aggiungi riga estremi se manca
      if (!el.querySelector(".mh-minmax-row")){
        const minmax = window.extremiGiornalieri && window.extremiGiornalieri[sid];
        if (minmax && (isFiniteNum(minmax.min) || isFiniteNum(minmax.max))){
          const row = document.createElement("div");
          row.className = "popup-data mh-minmax-row";
          row.innerHTML = `<span class="bold">Min:</span> ${fmt(minmax.min,"°C")} / <span class="bold">Max:</span> ${fmt(minmax.max,"°C")}`;
          const box = el.querySelector(".leaflet-popup-content") || el;
          box.appendChild(row);
        }
      }
    });
  }

  // FALLBACK Open‑Meteo (solo per RH/vento/raffica se mancanti)
  async function openMeteoFallback(lat,lon){
    try{
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=relative_humidity_2m,wind_speed_10m,wind_gusts_10m&timezone=auto`;
      const r = await fetch(url);
      if(!r.ok) return null;
      const j = await r.json();
      const c = j && j.current;
      if (!c) return null;
      return {
        rh: toNumber(c.relative_humidity_2m),
        ws: toNumber(c.wind_speed_10m),
        wg: toNumber(c.wind_gusts_10m)
      };
    }catch(_){ return null; }
  }

  // Ciclo principale: scarica da MeteoHub, calcola estremi e pioggia OGGI da MeteoHub, integra
  async function loadAll(){
    const url = buildQueryUrl();
    let data;
    try{
      const resp = await fetch(url, {cache:"no-store"});
      data = await resp.json();
    }catch(e){
      console.error("Errore fetch MeteoHub:", e);
      return;
    }
    const listRaw = Array.isArray(data) ? data : (data.stations || data.data || data.results || []);
    const rows = [];
    const mm = loadMinMax();

    for (const st of listRaw){
      const lat = toNumber(st.lat ?? st.latitude ?? st.stat?.lat);
      const lon = toNumber(st.lon ?? st.longitude ?? st.stat?.lon);
      if (!inBbox(lat,lon)) continue;

      const r = normalizeStation(st);
      if (!isFiniteNum(r.t)) continue; // serve almeno la temperatura per considerarla “valida”

      // fallback RH/Wind solo se mancano
      if ((!isFiniteNum(r.rh) || !isFiniteNum(r.ws) || !isFiniteNum(r.wg)) && isFiniteNum(r.lat) && isFiniteNum(r.lon)){
        try{
          const fb = await openMeteoFallback(r.lat, r.lon);
          if (fb){
            if (!isFiniteNum(r.rh) && isFiniteNum(fb.rh)) r.rh = fb.rh;
            if (!isFiniteNum(r.ws) && isFiniteNum(fb.ws)) r.ws = fb.ws;
            if (!isFiniteNum(r.wg) && isFiniteNum(fb.wg)) r.wg = fb.wg;
          }
        }catch(_){}
      }

      // min/max giornalieri basati SOLO su MeteoHub
      const prev = mm.byId[r.id] || {min:+Infinity, max:-Infinity};
      if (isFiniteNum(r.t)){
        prev.min = Math.min(prev.min, r.t);
        prev.max = Math.max(prev.max, r.t);
      }
      mm.byId[r.id] = prev;

      // salva in memoria pubblica per popup
      window.extremiGiornalieri = window.extremiGiornalieri || {};
      window.extremiGiornalieri[r.id] = {
        min: isFinite(prev.min) ? +prev.min : null,
        max: isFinite(prev.max) ? +prev.max : null
      };

      rows.push(r);
      if (rows.length >= MAX_STAZIONI) break;
    }

    saveMinMax(mm);
    integrateRows(rows);
    patchPopupBehaviour();
  }

  // avvio + refresh
  async function start(){
    await loadAll();
    setInterval(loadAll, REFRESH_MS);
  }
  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", start);
  else start();
})();
</script>
<!-- === END: MeteoHub full integration === -->


<!-- ========= FIX MIN/MAX FIREBASE PER METEOHUB (ott 2025) ========= -->
<script id="fix-extremi-firebase-mh-20251013">
(function(){
  if (window.__fix_extremi_firebase_mh__) return;
  window.__fix_extremi_firebase_mh__ = true;

  const PROJECT = "meteo-estremami";
  const COLL = "osservazioni";
  const RUNQUERY_URL = `https://firestore.googleapis.com/v1/projects/${PROJECT}/databases/(default)/documents:runQuery`;
  const LIST_URL = `https://firestore.googleapis.com/v1/projects/${PROJECT}/databases/(default)/documents/${COLL}`;

  function todayISO(){ return new Date().toISOString().slice(0,10); }
  function isSameDay(ts){
    if(!ts) return false;
    const d = new Date(ts);
    return d.toISOString().slice(0,10) === todayISO();
  }
  function num(v){
    if (v == null) return NaN;
    const n = Number(v);
    return Number.isFinite(n) ? n : NaN;
  }
  function parseTemp(fields){
    if(!fields) return NaN;
    const fv = fields.temperatura;
    if(!fv) return NaN;
    if (fv.doubleValue != null) return num(fv.doubleValue);
    if (fv.integerValue != null) return num(fv.integerValue);
    // some pipelines save "temperatura" as string
    if (fv.stringValue != null) return num(fv.stringValue);
    return NaN;
  }
  function parseTs(fields){
    if(!fields) return null;
    const tv = fields.timestamp;
    if (!tv) return null;
    // timestampValue (RFC3339) or stringValue
    return tv.timestampValue || tv.stringValue || null;
  }
  function getOffsetSafe(id){
    try{
      return (typeof window.getOffset === "function") ? window.getOffset(id) : { tmax:0, tmin:0 };
    }catch{return { tmax:0, tmin:0 };}
  }

  async function runQueryByStation(stationId, limit=1200){
    const body = {
      structuredQuery: {
        from: [{ collectionId: COLL }],
        where: {
          fieldFilter: {
            field: { fieldPath: "stationId" },
            op: "EQUAL",
            value: { stringValue: stationId }
          }
        },
        orderBy: [{ field: { fieldPath: "timestamp" }, direction: "DESCENDING" }],
        limit
      }
    };
    try{
      const res = await fetch(RUNQUERY_URL, {
        method: "POST",
        headers: { "content-type":"application/json" },
        body: JSON.stringify(body),
      });
      if (!res.ok) throw new Error("runQuery http "+res.status);
      const arr = await res.json();
      const docs = arr.map(x => x.document).filter(Boolean);
      return docs;
    }catch(e){
      console.warn("[Extremi] runQuery fallback for", stationId, e.message);
      return null;
    }
  }

  async function listAndFilterAllPages(stationId, maxDocs=6000){
    let pageToken = null;
    const out = [];
    try{
      do{
        const url = new URL(LIST_URL);
        url.searchParams.set("pageSize", "1000");
        if (pageToken) url.searchParams.set("pageToken", pageToken);
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error("list http "+res.status);
        const json = await res.json();
        const docs = json.documents || [];
        for(const d of docs){
          const f = d.fields;
          if(!f) continue;
          if((f.stationId && f.stationId.stringValue) !== stationId) continue;
          out.push(d);
          if(out.length >= maxDocs) break;
        }
        pageToken = json.nextPageToken;
      } while(pageToken && out.length < maxDocs);
      return out;
    }catch(e){
      console.error("[Extremi] list fallback error", e);
      return [];
    }
  }

  async function fetchDailyExtremes(stationId){
    // 1) try runQuery (fast & filtered)
    let docs = await runQueryByStation(stationId);
    // 2) fallback: paginate list API and filter by stationId
    if (!docs) docs = await listAndFilterAllPages(stationId);

    if (!docs || !docs.length) return null;
    const OGGI = todayISO();
    let min = +Infinity, max = -Infinity, found = 0;
    for(const d of docs){
      const f = d.fields || {};
      const t = parseTemp(f);
      const ts = parseTs(f);
      if (!isSameDay(ts)) continue;
      if (Number.isFinite(t)){
        found++;
        if (t < min) min = t;
        if (t > max) max = t;
      }
    }
    if (!found) return { min: null, max: null };

    // Apply per-station offsets if present
    const off = getOffsetSafe(stationId);
    if (Number.isFinite(min)) min = (min + (off.tmin||0));
    if (Number.isFinite(max)) max = (max + (off.tmax||0));

    return { min, max };
  }

  function pushIntoGlobal(stationId, ext){
    if (!ext) return;
    window.extremiGiornalieri = window.extremiGiornalieri || {};
    const cur = window.extremiGiornalieri[stationId] || {};
    // overwrite only with valid numbers; keep existing if new is null
    const out = {
      min: (ext.min==null || isNaN(ext.min)) ? cur.min : ext.min,
      max: (ext.max==null || isNaN(ext.max)) ? cur.max : ext.max
    };
    window.extremiGiornalieri[stationId] = out;
  }

  function syncIntoDatiTabella(){
    try{
      if(!Array.isArray(window.datiTabella) || !window.extremiGiornalieri) return;
      for(const r of window.datiTabella){
        const ex = window.extremiGiornalieri[r.stationId];
        if (!ex) continue;
        if (ex.min!=null) r.tMin = ex.min;
        if (ex.max!=null) r.tMax = ex.max;
      }
    }catch(e){ console.warn("syncIntoDatiTabella", e); }
  }

  function refreshUI(){
    try{
      syncIntoDatiTabella();
      if (typeof window.aggiornaTabella === "function") window.aggiornaTabella();
      if (typeof window.aggiornaPopup === "function") window.aggiornaPopup();
      const tipo = (window.ultimoModo === "max" || window.ultimoModo === "min") ? window.ultimoModo : null;
      if (tipo && typeof window.visualizzaEstremi === "function") window.visualizzaEstremi(tipo);
    }catch(e){}
  }

  async function ensureForList(ids){
    ids = Array.from(new Set(ids)).filter(Boolean);
    const work = ids.map(async id => {
      try{
        const ext = await fetchDailyExtremes(id);
        pushIntoGlobal(id, ext);
      }catch(e){ console.warn("[Extremi] station", id, e); }
    });
    await Promise.all(work);
    refreshUI();
  }

  function collectAllStationIds(){
    const ids = new Set();
    if (Array.isArray(window.datiTabella)){
      window.datiTabella.forEach(r => { if (r && r.stationId) ids.add(r.stationId); });
    }
    if (Array.isArray(window.stazioni)){
      window.stazioni.forEach(s => { if (s && s.stationId) ids.add(s.stationId); });
    }
    return Array.from(ids);
  }

  // Kick off after load, and then periodically (handles IDs generati dopo)
  function start(){
    const doRun = () => ensureForList(collectAllStationIds());
    // primo giro
    setTimeout(doRun, 1200);
    // altri giri per tenere allineato anche se le righe arrivano dopo
    [5000, 15000, 30000, 60000, 120000, 240000].forEach(ms => setTimeout(doRun, ms));
    // ogni 5 minuti
    setInterval(doRun, 300000);
  }

  if (document.readyState === "complete" || document.readyState === "interactive"){
    start();
  } else {
    document.addEventListener("DOMContentLoaded", start);
  }

})();
</script>
<!-- ======== /FIX MIN/MAX FIREBASE PER METEOHUB ========= -->

<!-- ========= FIX v2 MIN/MAX FIREBASE METEOHUB: mapping campi + timezone locale ========= -->
<script id="fix-extremi-firebase-mh-v2-20251013">
(function(){
  if (window.__fix_extremi_firebase_mh_v2__) return;
  window.__fix_extremi_firebase_mh_v2__ = true;

  // prefer timezone from page if set, else browser, else Europe/Rome
  const TZ = (window.timezoneMappa || (Intl.DateTimeFormat().resolvedOptions().timeZone || "Europe/Rome"));

  // helper to detect same local day in TZ
  function sameLocalDay(dateLike){
    if(!dateLike) return false;
    const d = new Date(dateLike);
    try{
      const nowStr = new Intl.DateTimeFormat('en-CA',{timeZone:TZ, year:'numeric',month:'2-digit',day:'2-digit'}).format(new Date());
      const tsStr  = new Intl.DateTimeFormat('en-CA',{timeZone:TZ, year:'numeric',month:'2-digit',day:'2-digit'}).format(d);
      return nowStr === tsStr;
    }catch{
      // fallback to local
      const now = new Date();
      return d.getFullYear()===now.getFullYear() && d.getMonth()===now.getMonth() && d.getDate()===now.getDate();
    }
  }

  // Robust parse for temperatura across multiple schema variants
  function parseTempAny(fields){
    if(!fields) return NaN;
    const keys = [
      "temperatura","temp","t","temperature","tempC","tc","Temperatura","temperatura_istantanea"
    ];
    for (const k of keys){
      const v = fields[k];
      if(!v) continue;
      if (v.doubleValue != null)  return Number(v.doubleValue);
      if (v.integerValue != null) return Number(v.integerValue);
      if (v.stringValue  != null){
        const n = Number(v.stringValue.replace(",", "."));
        if (Number.isFinite(n)) return n;
      }
    }
    return NaN;
  }

  // Robust parse for timestamp across multiple schema variants
  function parseTsAny(fields){
    if(!fields) return null;
    const keys = ["timestamp","ts","time","datetime","date","ora","createdAt"];
    for (const k of keys){
      const v = fields[k];
      if (!v) continue;
      if (typeof v === "object"){
        if (v.timestampValue) return v.timestampValue;
        if (v.stringValue){
          const s = v.stringValue;
          // if numeric epoch as string
          const maybe = Number(s);
          if (Number.isFinite(maybe) && s.trim().length>=10){
            // seconds vs ms
            const ms = (maybe< 10_000_000_000 ? maybe*1000 : maybe);
            return new Date(ms).toISOString();
          }
          return s;
        }
        if (v.integerValue != null){
          const num = Number(v.integerValue);
          const ms = (num< 10_000_000_000 ? num*1000 : num);
          return new Date(ms).toISOString();
        }
        if (v.doubleValue != null){
          const num = Number(v.doubleValue);
          const ms = (num< 10_000_000_000 ? num*1000 : num);
          return new Date(ms).toISOString();
        }
      }
    }
    return null;
  }

  // widen stationId extraction: string or integer
  function readStationId(fields){
    const sv = fields && fields.stationId;
    if (!sv) return null;
    if (sv.stringValue != null) return String(sv.stringValue);
    if (sv.integerValue != null) return String(sv.integerValue);
    if (sv.doubleValue  != null) return String(sv.doubleValue);
    return null;
  }

  // Override some helpers inside the first patch if present
  const prev = window.__fix_extremi_firebase_mh__;
  if (prev){
    // monkey-patch parsing functions used by v1 patch if it exists
    const s = document.getElementById("fix-extremi-firebase-mh-20251013");
    if (s){ console.log("[Extremi v2] Patch attiva su v1"); }
  }

  // Hook: replace fetchDailyExtremes if defined by v1; else create it
  const original = window.fetchDailyExtremes;
  window.fetchDailyExtremes = async function(stationId){
    try{
      // prefer original to get docs
      let docs = null;
      if (typeof original === "function"){
        try{
          // leverage v1's runQuery/list fallback to get raw docs
          docs = await original.call(this, "__return_docs_only__"); // will likely fail -> ignore
        }catch{}
      }
      // If not supported, refetch like v1 did
      if (!Array.isArray(docs) || !docs.length){
        // replicate minimal fetching via REST runQuery
        const PROJECT = "meteo-estremami";
        const COLL = "osservazioni";
        const RUNQUERY_URL = `https://firestore.googleapis.com/v1/projects/${PROJECT}/databases/(default)/documents:runQuery`;
        const body = {
          structuredQuery: {
            from: [{ collectionId: COLL }],
            where: {
              fieldFilter: {
                field: { fieldPath: "stationId" },
                op: "EQUAL",
                value: { stringValue: stationId }
              }
            },
            orderBy: [{ field: { fieldPath: "timestamp" }, direction: "DESCENDING" }],
            limit: 2500
          }
        };
        try{
          const res = await fetch(RUNQUERY_URL, { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify(body)});
          const arr = await res.json();
          docs = (arr||[]).map(x=>x && x.document).filter(Boolean);
        }catch{ docs = []; }
      }

      // compute extremes in local TZ
      let min = +Infinity, max = -Infinity, found = 0;
      for(const d of docs){
        const f = d.fields || {};
        const sid = readStationId(f);
        if (sid && sid !== stationId) continue; // safety
        const t = parseTempAny(f);
        const ts = parseTsAny(f);
        if (!sameLocalDay(ts)) continue;
        if (Number.isFinite(t)){
          found++;
          if (t<min) min=t;
          if (t>max) max=t;
        }
      }
      if (!found) return { min:null, max:null };

      // apply offsets if available
      let off = { tmin:0, tmax:0 };
      try{ off = (typeof window.getOffset==="function") ? (window.getOffset(stationId)||off) : off; }catch{}
      if (Number.isFinite(min)) min = (min + (off.tmin||0));
      if (Number.isFinite(max)) max = (max + (off.tmax||0));

      return { min, max };
    }catch(e){
      console.warn("[Extremi v2] errore", e);
      return { min:null, max:null };
    }
  };

  // after overriding, force a refresh run soon to re-populate MH stations
  setTimeout(async () => {
    try{
      const ids = (Array.isArray(window.datiTabella) ? window.datiTabella.map(r=>r.stationId) : [])
        .concat(Array.isArray(window.stazioni) ? window.stazioni.map(s=>s.stationId) : [])
        .filter(Boolean);
      const uniq = Array.from(new Set(ids));
      window.extremiGiornalieri = window.extremiGiornalieri || {};
      await Promise.all(uniq.map(async id => {
        const ext = await window.fetchDailyExtremes(id);
        if (!ext) return;
        const cur = window.extremiGiornalieri[id] || {};
        window.extremiGiornalieri[id] = {
          min: (ext.min==null || isNaN(ext.min)) ? cur.min : ext.min,
          max: (ext.max==null || isNaN(ext.max)) ? cur.max : ext.max,
        };
      }));

      // sync to table rows
      if (Array.isArray(window.datiTabella)){
        for (const r of window.datiTabella){
          const ex = window.extremiGiornalieri[r.stationId];
          if (!ex) continue;
          if (ex.min!=null) r.tMin = ex.min;
          if (ex.max!=null) r.tMax = ex.max;
        }
      }

      // refresh UI
      if (typeof window.aggiornaTabella === "function") window.aggiornaTabella();
      if (typeof window.aggiornaPopup === "function") window.aggiornaPopup();
      if (typeof window.visualizzaEstremi === "function" && (window.ultimoModo==="min" || window.ultimoModo==="max")){
        window.visualizzaEstremi(window.ultimoModo);
      }
    }catch(e){ console.warn("[Extremi v2] refresh errore", e); }
  }, 1800);

})();
</script>
<!-- ======== /FIX v2 ========= -->

<!-- ========= FIX v3 MIN/MAX FIREBASE METEOHUB: collection group + path fallback ========= -->
<script id="fix-extremi-firebase-mh-v3-20251013">
(function(){
  if (window.__fix_extremi_firebase_mh_v3__) return;
  window.__fix_extremi_firebase_mh_v3__ = true;

  function getProjectId(){
    try{
      if (window.firebase && window.firebase.app) { 
        const app = window.firebase.app();
        if (app && app.options && app.options.projectId) return app.options.projectId;
      }
    }catch{}
    try{
      if (window.firebaseConfig && window.firebaseConfig.projectId) return window.firebaseConfig.projectId;
    }catch{}
    // last resort: embedded literal (works for your file)
    return "meteo-estremami";
  }
  const PROJECT = getProjectId();
  const COLL = "osservazioni";
  const RUNQUERY_URL = `https://firestore.googleapis.com/v1/projects/${PROJECT}/databases/(default)/documents:runQuery`;

  const TZ = (window.timezoneMappa || (Intl.DateTimeFormat().resolvedOptions().timeZone || "Europe/Rome"));
  function sameLocalDay(dateLike){
    if(!dateLike) return false;
    const d = new Date(dateLike);
    try{
      const fmt = new Intl.DateTimeFormat('en-CA',{timeZone:TZ, year:'numeric',month:'2-digit',day:'2-digit'});
      return fmt.format(new Date()) === fmt.format(d);
    }catch{return (new Date()).toDateString()===d.toDateString();}
  }

  function n(v){ const x = Number(v); return Number.isFinite(x) ? x : NaN; }
  function parseTempAny(fields){
    const keys = ["temperatura","temp","t","temperature","tc","tempC","Temperatura"];
    for (const k of keys){
      const v = fields && fields[k];
      if (!v) continue;
      if (v.doubleValue != null)  return n(v.doubleValue);
      if (v.integerValue != null) return n(v.integerValue);
      if (v.stringValue  != null) { const x = n(String(v.stringValue).replace(",", ".")); if(Number.isFinite(x)) return x; }
    }
    return NaN;
  }
  function parseTsAny(fields){
    const keys = ["timestamp","ts","time","datetime","date","ora","createdAt"];
    for (const k of keys){
      const v = fields && fields[k];
      if (!v) continue;
      if (v.timestampValue) return v.timestampValue;
      if (v.stringValue){
        const s = v.stringValue;
        const maybe = Number(s);
        if (Number.isFinite(maybe) && s.trim().length>=10){
          const ms = (maybe< 10_000_000_000 ? maybe*1000 : maybe);
          return new Date(ms).toISOString();
        }
        return s;
      }
      if (v.integerValue != null){ const num = Number(v.integerValue); const ms = (num<10_000_000_000?num*1000:num); return new Date(ms).toISOString(); }
      if (v.doubleValue  != null){ const num = Number(v.doubleValue); const ms = (num<10_000_000_000?num*1000:num); return new Date(ms).toISOString(); }
    }
    return null;
  }
  function extractStationIdFromPath(docName){
    // .../documents/stazioni/{stationId}/osservazioni/{docId}
    // .../documents/osservazioni/{docId}
    if (!docName) return null;
    const parts = String(docName).split("/");
    const idx = parts.lastIndexOf("stazioni");
    if (idx>=0 && parts[idx+1]) return parts[idx+1];
    // else try docId prefix "MH_xxx"
    const docId = parts[parts.length-1] || "";
    const m = /^([A-Za-z]+_[^_]+)(?:_|$)/.exec(docId);
    if (m) return m[1];
    return null;
  }

  async function runQueryGroupByStation(stationId, limit=2500){
    const body = {
      structuredQuery: {
        from: [{ collectionId: COLL, allDescendants: true }],
        where: {
          fieldFilter: {
            field: { fieldPath: "stationId" },
            op: "EQUAL",
            value: { stringValue: stationId }
          }
        },
        limit
      }
    };
    try{
      const res = await fetch(RUNQUERY_URL, { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify(body)});
      if (!res.ok) throw new Error("runQuery http "+res.status);
      const arr = await res.json();
      const docs = (arr||[]).map(x=>x && x.document).filter(Boolean);
      return docs;
    }catch(e){
      console.warn("[Extremi v3] runQuery group fail for", stationId, e.message);
      return null;
    }
  }

  async function listSubcollectionByPath(stationId, pageSize=1000, maxDocs=4000){
    // try explicit path /stazioni/{id}/osservazioni
    const base = `https://firestore.googleapis.com/v1/projects/${PROJECT}/databases/(default)/documents/stazioni/${encodeURIComponent(stationId)}/${COLL}`;
    let next = null;
    const out = [];
    try{
      do{
        const url = new URL(base);
        url.searchParams.set("pageSize", String(pageSize));
        if (next) url.searchParams.set("pageToken", next);
        const res = await fetch(url.toString());
        if (!res.ok) throw new Error("listSub http "+res.status);
        const json = await res.json();
        const docs = json.documents || [];
        out.push(...docs);
        next = json.nextPageToken;
      } while(next && out.length<maxDocs);
      return out;
    }catch(e){
      console.warn("[Extremi v3] subcollection list fail for", stationId, e.message);
      return [];
    }
  }

  async function fetchDailyExtremesV3(stationId){
    // 1) collection-group query by stationId
    let docs = await runQueryGroupByStation(stationId, 3500);
    // 2) fallback: explicit subcollection path
    if (!docs || docs.length===0) docs = await listSubcollectionByPath(stationId, 1000, 4000);

    // 3) as a last resort: group query without where (small cap) and filter by path
    if (!docs || docs.length===0){
      try{
        const body = { structuredQuery: { from: [{ collectionId: COLL, allDescendants: true }], limit: 2000 } };
        const res = await fetch(RUNQUERY_URL, { method:"POST", headers:{ "content-type":"application/json" }, body: JSON.stringify(body)});
        const arr = await res.json();
        const all = (arr||[]).map(x=>x && x.document).filter(Boolean);
        const want = all.filter(d => {
          const name = d && d.name;
          const sidFromPath = extractStationIdFromPath(name);
          const sidField = d && d.fields && d.fields.stationId && d.fields.stationId.stringValue;
          const sid = sidField || sidFromPath;
          return sid === stationId;
        });
        docs = want;
      }catch{ docs = []; }
    }

    let min = +Infinity, max = -Infinity, found = 0;
    for(const d of docs){
      const f = d.fields || {};
      const sidField = f.stationId && (f.stationId.stringValue || f.stationId.integerValue || f.stationId.doubleValue);
      if (sidField && String(sidField)!==String(stationId)){
        // different station; keep only same station
        continue;
      } else if (!sidField){
        // if not present, ensure path matches
        const sidFromPath = extractStationIdFromPath(d.name);
        if (sidFromPath && String(sidFromPath)!==String(stationId)) continue;
      }
      const ts = parseTsAny(f);
      if (!sameLocalDay(ts)) continue;
      const t = parseTempAny(f);
      if (!Number.isFinite(t)) continue;
      found++;
      if (t<min) min=t;
      if (t>max) max=t;
    }

    if (!found) return { min:null, max:null };

    let off = { tmin:0, tmax:0 };
    try{ off = (typeof window.getOffset==="function") ? (window.getOffset(stationId)||off) : off; }catch{}
    if (Number.isFinite(min)) min = (min + (off.tmin||0));
    if (Number.isFinite(max)) max = (max + (off.tmax||0));
    return { min, max };
  }

  // Inject v3 into the refresh loop from v1/v2 or run standalone
  async function refreshV3(){
    const ids = (Array.isArray(window.datiTabella) ? window.datiTabella.map(r=>r.stationId) : [])
      .concat(Array.isArray(window.stazioni) ? window.stazioni.map(s=>s.stationId) : [])
      .filter(Boolean);
    const uniq = Array.from(new Set(ids));
    window.extremiGiornalieri = window.extremiGiornalieri || {};
    await Promise.all(uniq.map(async id => {
      try{
        const ext = await fetchDailyExtremesV3(id);
        const cur = window.extremiGiornalieri[id] || {};
        window.extremiGiornalieri[id] = {
          min: (ext && ext.min!=null && !isNaN(ext.min)) ? ext.min : cur.min,
          max: (ext && ext.max!=null && !isNaN(ext.max)) ? ext.max : cur.max,
        };
      }catch(e){ console.warn("[Extremi v3] station", id, e); }
    }));

    // push into table rows
    if (Array.isArray(window.datiTabella)){
      for (const r of window.datiTabella){
        const ex = window.extremiGiornalieri[r.stationId];
        if (!ex) continue;
        if (ex.min!=null) r.tMin = ex.min;
        if (ex.max!=null) r.tMax = ex.max;
      }
    }

    // refresh UI
    if (typeof window.aggiornaTabella === "function") window.aggiornaTabella();
    if (typeof window.aggiornaPopup === "function") window.aggiornaPopup();
    if (typeof window.visualizzaEstremi === "function" && (window.ultimoModo==="min" || window.ultimoModo==="max")){
      window.visualizzaEstremi(window.ultimoModo);
    }
  }

  setTimeout(refreshV3, 1200);
  [6000, 15000, 30000, 60000, 120000].forEach(ms => setTimeout(refreshV3, ms));
  setInterval(refreshV3, 300000);
})();
</script>
<!-- ======== /FIX v3 ========= -->

<!-- === ChatGPT Performance Accelerator v12 (max guard + anti-freeze) — 2025-10-13 === -->
<script id="mlg-accelerator-v12">
(function(){
  if (window.__MLG_ACCEL_V12__) return; window.__MLG_ACCEL_V12__ = true;

  const raf = cb => (window.requestAnimationFrame||setTimeout)(cb, 0);
  const rIC = window.requestIdleCallback || function(cb){ return setTimeout(()=>cb({didTimeout:false,timeRemaining:()=>0}), 1); };

  /* 0) Global safety: prevent unhandled errors from freezing UI loops */
  (function globalErrors(){
    window.addEventListener("error", function(e){
      try{
        const b = document.getElementById("map-loader-banner");
        if (b) b.classList.add("hide");
      }catch(_){}
    });
    window.addEventListener("unhandledrejection", function(e){
      try{
        const b = document.getElementById("map-loader-banner");
        if (b) b.classList.add("hide");
      }catch(_){}
    });
  })();

  /* A) Strong unfreeze on first gestures (cool down timers briefly) */
  (function firstGestureUnfreeze(){
    let cooled = false;
    function cool(){
      if (cooled) return; cooled = true;
      const SI = window.setInterval, ST = window.setTimeout;
      const wrap = new WeakMap();
      window.setInterval = function(fn, ms){
        if (typeof fn !== "function") return SI(fn, ms);
        if (!wrap.has(fn)){
          let running=false;
          wrap.set(fn, async function(){
            if (running) return;
            running=true; try{ await fn(); }catch(_){ } finally{ running=false; }
          });
        }
        return SI(wrap.get(fn), ms);
      };
      window.setTimeout = function(fn, ms){ return ST(fn, Math.min(ms||0, 25)); };
      raf(()=>raf(()=>{ window.setInterval = SI; window.setTimeout = ST; }));
      setTimeout(()=>{ window.setInterval = SI; window.setTimeout = ST; }, 900);
      setTimeout(()=>{ const b=document.getElementById("map-loader-banner"); if(b) b.classList.add("hide"); }, 1200);
    }
    ["pointerdown","touchstart","click","keydown"].forEach(ev=>{
      window.addEventListener(ev, cool, {passive:true, capture:true});
    });
  })();

  /* B) LIVE Enforcement
        - Absolute lock for first 60s (unless trusted click on Min/Max).
        - After that, min/max allowed only within 2 min of a trusted click. */
  (function liveEnforcer(){
    const start = Date.now();
    const HARD_LOCK_MS = 60000; // 60s
    let allowUntil = 0;
    const reMinMax = /\b(min|minime|minima|max|massime|massima|estremi|extremes)\b/i;
    const reLive   = /\b(live|attuali|current)\b/i;

    function inHardLock(){ return Date.now() - start < HARD_LOCK_MS; }
    function allow(){ return Date.now() < allowUntil; }
    function grant(){ allowUntil = Date.now() + 2*60*1000; }

    // Detect trusted clicks on Min/Max to grant window
    function hookButtons(){
      const qs = "button,a,[role='button'],.btn,.tab,[data-tab],[data-view]";
      document.querySelectorAll(qs).forEach(el=>{
        if (el.__v12hook) return;
        el.addEventListener("click", function(ev){
          const txt = ((el.textContent||"") + " " + (el.id||"") + " " + (el.getAttribute('data-tab')||"") + " " + (el.getAttribute('data-view')||"") + " " + (el.className||"")).toLowerCase();
          if (ev.isTrusted && reMinMax.test(txt)) grant();
        }, true);
        el.__v12hook = true;
      });
    }
    hookButtons();
    new MutationObserver(hookButtons).observe(document.documentElement, {subtree:true, childList:true});

    function toLive(){
      try{
        if (typeof window.visualizzaAttuali === "function") window.visualizzaAttuali();
        const nodes = document.querySelectorAll("button,a,[role='button'],.btn,.tab,[data-tab]");
        for (const el of nodes){
          const t = ((el.textContent||"") + " " + (el.id||"") + " " + (el.getAttribute('data-tab')||"") + " " + (el.className||"")).toLowerCase();
          if (reLive.test(t)){
            el.dispatchEvent(new MouseEvent("click", {bubbles:true, cancelable:true, view:window}));
            break;
          }
        }
        window._ultimoModo_internal = "attuali";
      }catch(_){}
    }

    // Wrap visualizzaEstremi: block min/max during hard lock or without allow window
    (function(){
      const o = window.visualizzaEstremi;
      if (typeof o === "function" && !o.__v12){
        window.visualizzaEstremi = function(tipo){
          const isExtreme = (tipo==="min" || tipo==="max");
          if (isExtreme && (inHardLock() || !allow())){ toLive(); return; }
          return o.apply(this, arguments);
        };
        window.visualizzaEstremi.__v12 = true;
      }
    })();

    // Neutralize programmatic calls through timers/timeouts/promises
    (function neutralizeProgrammaticSwitches(){
      const ST = window.setTimeout, SI = window.setInterval;
      window.setTimeout = function(fn, ms){
        if (typeof fn === "function"){
          const wrapped = function(){
            // try to detect direct calls inside timer
            try{
              if (inHardLock() || !allow()){
                if (String(fn).includes("visualizzaEstremi") || String(fn).match(/minime|min|max|massime/)){
                  toLive(); return;
                }
              }
            }catch(_){}
            return fn.apply(this, arguments);
          };
          return ST(wrapped, ms);
        }
        return ST(fn, ms);
      };
      window.setInterval = function(fn, ms){
        if (typeof fn === "function"){
          const wrapped = function(){
            try{
              if (inHardLock() || !allow()){
                if (String(fn).includes("visualizzaEstremi") || String(fn).match(/minime|min|max|massime/)){
                  toLive(); return;
                }
              }
            }catch(_){}
            return fn.apply(this, arguments);
          };
          return SI(wrapped, ms);
        }
        return SI(fn, ms);
      };
    })();

    // Protect assignments to ultimoModo
    try{
      let _ultimo = window.ultimoModo;
      Object.defineProperty(window, "ultimoModo", {
        get(){ return _ultimo; },
        set(v){
          _ultimo = v;
          if (typeof v === "string" && /min|max/i.test(v) && (inHardLock() || !allow())){
            setTimeout(toLive, 0);
          }
        },
        configurable: true
      });
    }catch(_){}

    // Observe active tab changes and revert if necessary
    const mo = new MutationObserver(()=>{
      if (allow() && !inHardLock()) return;
      try{
        const active = document.querySelector('[data-tab].active, .tab.active, .btn.active, [aria-selected="true"]');
        if (active){
          const t = (active.textContent||"").toLowerCase();
          if (/\b(min|minime|minima|max|massime|massima|estremi|extremes)\b/.test(t)) toLive();
        }
      }catch(_){}
    });
    mo.observe(document.documentElement, {subtree:true, childList:true, attributes:true, attributeFilter:["class","aria-selected"]});

    function startLive(){ toLive(); }
    if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", startLive);
    else setTimeout(startLive, 0);
  })();
})();
</script>
<!-- === /ChatGPT Performance Accelerator v12 === -->

<!-- === Auto‑push LIVE for 2 minutes (cancellable by user) — 2025‑10‑13 === -->
<script id="live-autopush-2min">
(function(){
  if (window.__autoLive2mInstalled) return; window.__autoLive2mInstalled = true;

  var DURATION = 2 * 60 * 1000;   // 2 minuti
  var INTERVAL = 4000;            // ripeti ogni 4s per sicurezza
  var stop = false;
  var started = Date.now();
  var timer = null;

  function isViewChangeClick(el){
    if (!el) return false;
    var hay = [
      el.textContent||"",
      el.title||"",
      el.id||"",
      el.getAttribute && el.getAttribute("onclick") || "",
      el.className||"",
      el.getAttribute && el.getAttribute("data-tab") || "",
      el.getAttribute && el.getAttribute("data-view") || ""
    ].join(" ").toLowerCase();

    // se è il LIVE, non fermiamo
    if (hay.includes("visualizzaattuali") || hay.includes("attuali") || hay.includes("temp attuale")) return false;

    // se è una vista diversa dal LIVE, fermiamo
    return /visualizza(estremi|umidita|percepita|raffiche|pioggia)|toggleplot|filtrasolomlg|toggleradar|min|max|ur%|perc|raf|mm/.test(hay);
  }

  function onClick(ev){
    // interrompi solo su click "fidati" dell'utente
    if (!ev.isTrusted) return;
    var el = ev.target && (ev.target.closest && ev.target.closest("button, a, [role='button'], .sidebar-btn, .btn, [data-tab], [data-view]"));
    if (isViewChangeClick(el)){
      stop = true;
      try { if (timer) clearInterval(timer); } catch(_){}
      window.removeEventListener("click", onClick, true);
      // non forziamo più il LIVE
    }
  }

  function pushLive(){
    if (stop) return;
    if (Date.now() - started > DURATION){
      try { if (timer) clearInterval(timer); } catch(_){}
      window.removeEventListener("click", onClick, true);
      return;
    }
    try{
      if (typeof window.visualizzaAttuali === "function"){
        window.visualizzaAttuali();
      } else {
        var btn = document.querySelector(".sidebar-btn[onclick*='visualizzaAttuali'], button[title*='attuale' i]");
        if (btn){
          btn.dispatchEvent(new MouseEvent("click", {bubbles:true, cancelable:true, view:window}));
        }
      }
      window.ultimoModo = "attuali";
    }catch(_){}
  }

  function start(){
    // ascolta i click utente (in capture per prenderli sempre)
    window.addEventListener("click", onClick, true);
    // prima spinta immediata, poi ogni INTERVAL
    pushLive();
    timer = setInterval(pushLive, INTERVAL);
  }

  if (document.readyState === "loading") document.addEventListener("DOMContentLoaded", start);
  else start();
})();
</script>

<!-- ULTRA performance patch inline: chunked updates + viewport culling + zoom-safe -->
<script>
(function () {
  const raf = window.requestAnimationFrame || (cb => setTimeout(cb, 16));
  const caf = window.cancelAnimationFrame || clearTimeout;
  function now(){return (window.performance&&performance.now)?performance.now():Date.now();}

  // ---- Map hooks & options --------------------------------------------------
  const map=(window.map||window.mappa||window.leafletMap||null);
  let interactionBusy=false, pendingRedraw=null; const REDRAW_DEBOUNCE_MS=120;
  let chunkHandle=null;

  if(map&&map.on){
    try{
      // Soften zoom wheel / reduce event storm
      map.options.wheelDebounceTime=Math.max(map.options.wheelDebounceTime||0,80);
      map.options.wheelPxPerZoomLevel=Math.max(map.options.wheelPxPerZoomLevel||0,80);
      map.options.updateWhenZooming=false;
      map.options.updateWhenIdle=true;
      map.options.zoomAnimation=false; // prefer instant zoom to avoid layout storms
      map.on('zoomstart movestart',()=>{interactionBusy=true; if (chunkHandle) { caf(chunkHandle); chunkHandle=null; }});
      let timer=null, lastEnd=0;
      const done=()=>{
        interactionBusy=false;
        const since=now()-lastEnd;
        clearTimeout(timer);
        timer=setTimeout(()=>{
          if(pendingRedraw){const toRun=pendingRedraw; pendingRedraw=null; try{toRun();}catch(e){console.error(e);}}
        }, REDRAW_DEBOUNCE_MS - Math.min(REDRAW_DEBOUNCE_MS, since));
      };
      map.on('zoomend moveend',()=>{ lastEnd=now(); done(); });
    }catch(e){ console.warn('[perf-patch] Cannot alter map options:', e); }
  }

  function guardRedraw(fn){ if(interactionBusy){ pendingRedraw=fn; return; } fn(); }

  // ---- Data & markers -------------------------------------------------------
  const markersById=(window.markersById||{});
  const datiTabella=(window.datiTabella||[]);

  function safeGetEl(marker){ try{ if(!marker||!marker.getElement) return null; return marker.getElement(); }catch(e){ return null; }}

  // batched DOM writer
  const UpdateQueue=(function(){ const q=new Map(); let scheduled=false;
    function flush(){ scheduled=false; try{
      for(const[,u]of q){ const{el,bg,html,w,h}=u; if(!el) continue;
        if(html!==undefined){ if(el.__lastHTML!==html){ el.innerHTML=html; el.__lastHTML=html; } }
        if(bg!==undefined){ if(el.__lastBG!==bg){ el.style.backgroundColor=bg; el.__lastBG=bg; } }
        if(w!==undefined){ if(el.__lastW!==w){ el.style.width=w; el.__lastW=w; } }
        if(h!==undefined){ if(el.__lastH!==h){ el.style.height=h; el.__lastH=h; } }
      }
    }finally{ q.clear(); } }
    function enqueue(key,update){ if(!key) return; const prev=q.get(key);
      if(prev){ q.set(key,Object.assign(prev,update)); } else { q.set(key,update); }
      if(!scheduled){ scheduled=true; raf(flush); }
    }
    return { enqueue };
  })();

  function setMarkerCircle(stationId,{textHTML,bg,widthPx=40,heightPx=40}){
    const marker=markersById[stationId]; if(!marker) return;
    const el=safeGetEl(marker); if(!el) return;
    UpdateQueue.enqueue(stationId,{
      el, html:textHTML, bg,
      w: widthPx ? (widthPx+'px') : undefined,
      h: heightPx ? (heightPx+'px') : undefined
    });
  }

  const getColor=window.getColor||function(){return '#999';};
  const getTextColorForBackground=window.getTextColorForBackground||function(){return '#fff';};
  const getColorUmidita=window.getColorUmidita||function(){return '#44aaff';};
  const getColorVento=window.getColorVento||function(v){return `rgb(${Math.min(255,Math.round(v*5))},${Math.max(0,255-Math.round(v*3))},60)`;};
  const getEstremoGiornaliero=window.getEstremoGiornaliero||function(){return undefined;};

  // ---- CHUNKED processing + viewport culling -------------------------------
  function processInChunks(items, perFrame, fn, onDone){
    let i=0;
    function step(){
      const end=Math.min(i+perFrame, items.length);
      for(;i<end;i++){ fn(items[i]); }
      if(i<items.length){ chunkHandle=raf(step); } else { chunkHandle=null; if(onDone) onDone(); }
    }
    step();
  }

  function getVisibleStations(pad=0.2){
    if(!map||!map.getBounds){ return datiTabella; }
    try{
      const b = map.getBounds().pad(pad);
      const south=b.getSouth(), north=b.getNorth(), west=b.getWest(), east=b.getEast();
      return datiTabella.filter(d => {
        const lat = d.lat || d.latitude || (d.coord && d.coord.lat);
        const lng = d.lng || d.lon || d.longitude || (d.coord && d.coord.lon);
        if(lat==null||lng==null) return true; // keep if unknown
        return lat>=south && lat<=north && lng>=west && lng<=east;
      });
    }catch(e){ return datiTabella; }
  }

  function redrawGeneric(builder){
    const run = () => {
      if(chunkHandle){ caf(chunkHandle); chunkHandle=null; }
      const items = getVisibleStations(0.25);
      // limit worst-case work per frame
      const perFrame = Math.max(100, Math.floor( (items.length||1000) / 10 )); // ~10 frames
      processInChunks(items, perFrame, builder, null);
    };
    guardRedraw(run);
  }

  // ---- override the heavy functions ----------------------------------------
  const _visualizzaAttuali=window.visualizzaAttuali;
  const _visualizzaUmidita=window.visualizzaUmidita;
  const _visualizzaRaffiche=window.visualizzaRaffiche;
  const _visualizzaEstremi=window.visualizzaEstremi;

  if(typeof _visualizzaAttuali==='function'){
    window.visualizzaAttuali=function(){
      redrawGeneric((d)=>{
        if(isNaN(d.tempVal)) return;
        const colore=getColor(d.tempVal); const textColor=getTextColorForBackground(colore);
        setMarkerCircle(d.stationId,{textHTML:`<span style="color:${textColor};">${d.temp}°</span>`,bg:colore,widthPx:40,heightPx:40});
      });
    };
  }

  if(typeof _visualizzaUmidita==='function'){
    window.visualizzaUmidita=function(){
      redrawGeneric((d)=>{
        const colore=getColorUmidita(d.umidita); const textColor=getTextColorForBackground(colore);
        setMarkerCircle(d.stationId,{textHTML:`<span style="color:${textColor};">${d.umidita}%</span>`,bg:colore,widthPx:40,heightPx:40});
      });
    };
  }

  if(typeof _visualizzaRaffiche==='function'){
    window.visualizzaRaffiche=function(){
      redrawGeneric((d)=>{
        const colore=getColorVento(d.raffica); const textColor=getTextColorForBackground(colore);
        setMarkerCircle(d.stationId,{textHTML:`<span style="color:${textColor};">${d.raffica}</span>`,bg:colore,widthPx:48,heightPx:48});
      });
    };
  }

  if(typeof _visualizzaEstremi==='function'){
    window.visualizzaEstremi=function(tipo){
      redrawGeneric((d)=>{
        const valore=getEstremoGiornaliero(d.stationId,tipo); if(typeof valore==='undefined') return;
        const colore=getColor(valore); const textColor=getTextColorForBackground(colore);
        setMarkerCircle(d.stationId,{textHTML:`<span style="color:${textColor};">${String(valore)}°</span>`,bg:colore,widthPx:40,heightPx:40});
      });
    };
  }

  // Abortable fetch to avoid wasted work on rapid interactions
  const abortableFetch=(function(){let current;return async function(input,init){ if(current) current.abort(); current=new AbortController(); const res=await fetch(input,{...(init||{}),signal:current.signal}); return res; };})();
  window.abortableFetch=abortableFetch;

  // Micro-optimizations
  try{ window.addEventListener('wheel',function(){},{passive:true}); window.addEventListener('touchmove',function(){},{passive:true}); }catch(e){}
  try{ const s=document.createElement('style'); s.textContent=`
    .leaflet-pane, .leaflet-tile, .leaflet-marker-icon { will-change: transform; }
    .leaflet-zoom-animated { transition: none !important; }`; document.head.appendChild(s);
  }catch(e){}
  console.info('[perf-patch] ULTRA mode active: chunked + culling.');
})();
</script>

<!-- === MOBILE FIX 2025-10-14 === -->
<style id="mlg-mobile-tighten-2025-10-14">
/* 1) Compatta ulteriormente il banner su smartphone (meno blu sopra/sotto) */
@media (max-width: 540px){
  header.mlg-banner{
    padding-top: 2px !important;
    padding-bottom: 4px !important;
    margin-bottom: 6px !important;
  }
  header.mlg-banner .mlg-inner{
    padding-top: 4px !important;
    padding-bottom: 4px !important;
    row-gap: 2px !important;
  }
}

/* 2) Sidebar e indicator non devono sovrapporsi al banner */
#sidebar{ top: calc(var(--mlg-banner-h, 64px) + 6px) !important; }
#map-indicator{ top: calc(var(--mlg-banner-h, 64px) + 10px) !important; }

/* 3) Nasconde il badge verde "ESTREMI BLOCCATI (Firebase)" */
#badge-freeze-estremi{ display:none !important; visibility:hidden !important; opacity:0 !important; }
</style>

<script id="mlg-measure-banner-and-shift-2025-10-14">
(function(){
  function setBannerVar(){
    try{
      var h = 0;
      var header = document.querySelector('header.mlg-banner');
      if(header){
        h = Math.round(header.getBoundingClientRect().height);
        if(!h || h < 40) h = 56; // fallback mobile
      }else{
        h = 56;
      }
      document.documentElement.style.setProperty('--mlg-banner-h', h + 'px');

      // Allinea componenti flottanti che usano un valore fisso
      var sb = document.getElementById('sidebar');
      if(sb){ sb.style.top = 'calc(var(--mlg-banner-h) + 6px)'; }

      var ind = document.getElementById('map-indicator');
      if(ind){ ind.style.top = 'calc(var(--mlg-banner-h) + 10px)'; }

      var rc = document.getElementById('radar-controls');
      if(rc){ rc.style.top = 'calc(var(--mlg-banner-h) + 50px)'; } // prima era 120px fissi
    }catch(_){}
  }
  if(document.readyState === 'loading'){
    document.addEventListener('DOMContentLoaded', setBannerVar, {once:true});
  }else{
    setBannerVar();
  }
  window.addEventListener('load', setBannerVar);
  window.addEventListener('resize', setBannerVar);
})();
</script>
<!-- === /MOBILE FIX 2025-10-14 === -->

<!-- === FINAL HOTFIX 2025-10-14: decimali 1 cifra, pop‑up stabili, rimozione Min/Max riga === -->
<script id="final_hotfix_2025_10_14">
(function(){
  if (window.__final_hotfix_20251014) return;
  window.__final_hotfix_20251014 = true;

  /* ---- utils ---- */
  function to1(n){
    const v = parseFloat(String(n).replace(',', '.'));
    return Number.isFinite(v) ? v.toFixed(1) : '--';
  }
  function isNum(n){
    const v = parseFloat(String(n).replace(',', '.'));
    return Number.isFinite(v);
  }

  /* ---- 1) Marker: forza UN SOLO decimale ---- */
  function cleanMarkerEl(el){
    if(!el) return;
    const span = el.querySelector && el.querySelector('span');
    if(!span) return;
    const txt = span.textContent || '';
    const m = txt.replace(',', '.').match(/-?\d+(?:\.\d+)?/);
    if(m){
      const hasDeg = /°/.test(txt);
      span.textContent = to1(m[0]) + (hasDeg ? '°' : '');
    }
  }
  function cleanAllMarkers(){
    document.querySelectorAll('.leaflet-marker-icon').forEach(cleanMarkerEl);
  }
  // iniziale + continuo (leggero)
  document.addEventListener('DOMContentLoaded', function(){
    setTimeout(cleanAllMarkers, 600);
    setInterval(cleanAllMarkers, 3500);
  });

  /* ---- 2) Pop‑up: stabilizza campi + formato a 1 decimale ---- */
  function fixPopup(popup){
    const el = popup && popup.getElement && popup.getElement();
    if(!el) return;

    // elimina qualunque riga Min/Max aggiunta da patch precedenti (richiesta utente)
    el.querySelectorAll('.mh-minmax-row, .popup-data').forEach(n => {
      const t = (n.textContent || '').trim();
      if (/^(Min(?:ima)?|Max(?:sima)?)/i.test(t)) n.remove();
    });

    // identifica station id
    const sidAttr = el.querySelector('.popup-wrapper')?.getAttribute('data-station-id');
    const sid = sidAttr || (popup._source && (popup._source.stationId || popup._source.options?.stationId)) || null;

    const row = (Array.isArray(window.datiTabella) ? window.datiTabella.find(r => r.stationId === sid) : null) || {};

    function setRow(label, value, unit){
      const node = Array.from(el.querySelectorAll('.popup-data')).find(d => (d.textContent || '').trim().startsWith(label));
      if(!node) return;
      const v = isNum(value) ? (to1(value) + (unit || '')) : '--';
      node.innerHTML = '<span class="bold">'+label+'</span> ' + v;
    }

    setRow('Temp:', row.temp, '°C');
    setRow('Umidità:', row.umidita, '%');
    setRow('Temp. percepita:', row.percepita, '°C');

    // Vento / Raffica riga combinata
    const ventoNode = Array.from(el.querySelectorAll('.popup-data')).find(d => /Vento:/i.test(d.textContent || ''));
    if (ventoNode){
      const v = isNum(row.vento) ? (to1(row.vento) + ' km/h') : '--';
      const g = isNum(row.raffica) ? (to1(row.raffica) + ' km/h') : '--';
      ventoNode.innerHTML = '<span class="bold">Vento:</span> ' + v + ' / <span class="bold">Raffica:</span> ' + g;
    }

    // Pioggia
    const rainNode = Array.from(el.querySelectorAll('.popup-data')).find(d => /Pioggia:/i.test(d.textContent || ''));
    if (rainNode){
      const p = isNum(row.pioggia) ? (to1(row.pioggia) + ' mm') : '0 mm';
      rainNode.innerHTML = '<span class="bold">Pioggia:</span> ' + p;
    }
  }

  function hookPopups(){
    const m = window.map || window.mymap;
    if(!m){ setTimeout(hookPopups, 400); return; }
    m.on('popupopen', e => { try{ fixPopup(e.popup); }catch(_){ } });
  }
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', hookPopups);
  else hookPopups();

  /* ---- 3) Disinnesca aggiunta futura della riga Min/Max ---- */
  if (typeof window.aggiornaPopupConEstremiFinale === 'function' && !window.aggiornaPopupConEstremiFinale.__noMinMax){
    const _orig = window.aggiornaPopupConEstremiFinale;
    window.aggiornaPopupConEstremiFinale = function(){
      const r = _orig.apply(this, arguments);
      const p = (window.map || window.mymap)?._popup : null;
      if (p) try{ fixPopup(p); }catch(_){}
      return r;
    };
    window.aggiornaPopupConEstremiFinale.__noMinMax = true;
  }

  // 4) Espone un util per debug manuale
  window.__mlgFixDecimals = function(){ cleanAllMarkers(); (window.map||window.mymap)?._popup && fixPopup((window.map||window.mymap)._popup); };
})();
</script>


<!-- === ChatGPT One-Decimal Sanitizer v2.0 (aggressive + debounced) === -->
<script id="one-decimal-sanitizer">
(function(){
  // Match numbers with 2+ decimals (handles negatives too)
  var DEC_REGEX = /(-?\d+\.\d{2,})/g;

  function roundText(s){
    return s.replace(DEC_REGEX, function(_, num){
      var v = Number(num);
      if (!Number.isFinite(v)) return num;
      return v.toFixed(1);
    });
  }

  function walkAndFix(root){
    if(!root) return;
    try{
      var walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
      var node;
      while(node = walker.nextNode()){
        var t = node.nodeValue;
        if(!t || t.indexOf('.') === -1) continue;
        var nt = roundText(t);
        if(nt !== t) node.nodeValue = nt;
      }
    }catch(e){ /* noop */ }
  }

  // Debounced sanitize pass (whole body + common Leaflet panes)
  var rafPending = false;
  function requestSanitize(){
    if(rafPending) return;
    rafPending = true;
    requestAnimationFrame(function(){
      rafPending = false;
      walkAndFix(document.body);
      // Extra: sanitize popups/marker panes explicitly in case they're in portals
      var extras = document.querySelectorAll('.leaflet-popup, .leaflet-marker-pane, .leaflet-popup-content, #tabella, #anteprima-dati-testuali');
      extras.forEach(walkAndFix);
    });
  }

  // Observe all DOM mutations (character data & new nodes)
  var mo = new MutationObserver(function(){
    requestSanitize();
  });
  try{
    mo.observe(document.documentElement, {subtree:true, childList:true, characterData:true});
  }catch(e){}

  // Initial passes
  document.addEventListener('DOMContentLoaded', requestSanitize);
  window.addEventListener('load', requestSanitize);

  // Helper for manual formatting if needed elsewhere
  window.__fmt1__ = function(v){ var n = Number(v); return Number.isFinite(n) ? n.toFixed(1) : v; };
})();
</script>
<!-- === /One-Decimal Sanitizer === -->


<!-- === MLG: FIX MeteoHub popup enrichment (humidity, wind, gusts, rain) === -->
<script>
(function(){
  if (!window.L) return;

  function pad(n){return String(n).padStart(2,'0');}
  function fmtUTC(d){
    return d.getUTCFullYear()+"-"+pad(d.getUTCMonth()+1)+"-"+pad(d.getUTCDate())+" "+pad(d.getUTCHours())+":"+pad(d.getUTCMinutes());
  }
  function toNum(v){const n=Number(v); return isFinite(n)?n:null;}
  function getPool(st){return st?.prod || st?.products || st?.var || st?.variables || st;}
  function getProd(st, code){
    const P=getPool(st); if(!P) return null;
    if (Array.isArray(P)) return P.find(p => String(p.var||p.code||"").toUpperCase()===String(code).toUpperCase()) || null;
    if (typeof P==="object") return P[code] || P[String(code)] || null;
    return null;
  }
  function series(prod){
    const raw = prod?.val ?? prod?.values ?? prod?.series ?? prod;
    const out=[];
    if (Array.isArray(raw)){
      for (const r of raw){
        if (r && typeof r==="object" && "val" in r){
          out.push({val: Number(r.val), time: r.ref || r.reftime || r.time || r.ts});
        }
      }
    }
    return out.filter(x => isFinite(x.val));
  }
  function todayOnly(s){
    const d=new Date(); const y=d.getUTCFullYear(), m=d.getUTCMonth()+1, dd=d.getUTCDate();
    const k = y+"-"+String(m).padStart(2,'0')+"-"+String(dd).padStart(2,'0');
    return (s||[]).filter(p=>p.time && String(p.time).slice(0,10)===k).sort((a,b)=> new Date(a.time)-new Date(b.time));
  }
  function rainTodayCalc(seriesAll){
    const s=todayOnly(seriesAll);
    if(!s.length) return 0;
    // cumulata non decrescente -> differenza
    let nonDec=true;
    for(let i=1;i<s.length;i++){ if (s[i].val < s[i-1].val - 1e-6){ nonDec=false; break; } }
    if (nonDec) return Math.max(0, s[s.length-1].val - s[0].val);
    // incrementale -> somma
    let sum=0; for(const p of s){ if (p.val >= 0) sum+=p.val; }
    return sum;
  }
  function lastVal(prod){
    const s=series(prod); if (s.length) return s[s.length-1].val;
    const v=Number(prod?.val); return isFinite(v)? v : null;
  }
  function toKmH(value, unit){
    if (value==null || isNaN(value)) return null;
    const u=(unit||"").toUpperCase();
    if (u.includes("M/S")) return value*3.6;
    if (u.includes("KM/H")||u.includes("KMH")) return value;
    if (u.includes("KT") || u.includes("KNOT")) return value*1.852;
    return value<60 ? value*3.6 : value; // fallback prudente
  }

  function buildQuery(){
    const now=new Date(), from=new Date(now.getTime()-36*3600*1000);
    return (
      "reftime: >="+fmtUTC(from)+",<="+fmtUTC(now)+";"+
      "timerange:254,0,0 or 1,0,3600;"+
      "level:103,2000,0,0 or 1,0,0,0 or 103,10000,0,0;"+
      "license:CCBY_COMPLIANT;"+
      "product:B12101 or B13003 or B11002 or B11001 or B11041 or B11042 or B13011"
    );
  }

  async function fetchAround(lat, lon){
    const base = new URL("https://meteohub.agenziaitaliameteo.it/api/observations");
    base.searchParams.set("q", buildQuery());
    base.searchParams.set("lat", lat);
    base.searchParams.set("lon", lon);
    base.searchParams.set("networks", "dpcn-calabria");
    base.searchParams.set("stationDetails","true");
    base.searchParams.set("allStationProducts","false");
    const res = await fetch(base.toString(), {cache:"no-store"});
    if (!res.ok) throw new Error("MeteoHub "+res.status);
    const js=await res.json();
    const list = Array.isArray(js)? js : (js.stations || js.data || js.results || []);
    if (!list.length) return null;
    // prendi la stazione più vicina
    let best=null,bd=1e9;
    for (const st of list){
      const la=toNum(st.lat ?? st.latitude), lo=toNum(st.lon ?? st.longitude);
      if (!isFinite(la)||!isFinite(lo)) continue;
      const d2=(la-lat)*(la-lat)+(lo-lon)*(lo-lon);
      if (d2<bd){ bd=d2; best=st; }
    }
    if (!best) return null;
    const T  = getProd(best,"B12101");
    const RH = getProd(best,"B13003");
    const WS = getProd(best,"B11002");
    const WG = getProd(best,"B11041") || getProd(best,"B11042");
    const RR = getProd(best,"B13011");

    const rh = lastVal(RH);
    const ws = toKmH(lastVal(WS), WS?.unit);
    const wg = toKmH(lastVal(WG), WG?.unit);
    const rain = rainTodayCalc(series(RR));

    return {rh, ws, wg, rain};
  }

  // Hook sul popup: aggiorna i campi con i dati MeteoHub in tempo reale
  var mapObj = window.map || window.mymap || window.MAP || window.leafmap || window.__leaflet_map;
  if (!mapObj && window.L && L?.map){
    // prova a recuperare il primo map creato
    for (const k in window){ if (window[k] && window[k] instanceof L.Map){ mapObj = window[k]; break; } }
  }
  if (!mapObj) return;

  mapObj.on('popupopen', async function(e){
    try{
      const marker = e.popup._source;
      if (!marker || !marker.getLatLng) return;
      const latlng = marker.getLatLng();
      const data = await fetchAround(latlng.lat, latlng.lng);
      if (!data) return;
      const div = e.popup.getElement()?.querySelector('.leaflet-popup-content');
      if (!div) return;
      let html = div.innerHTML;
      function rep(label, value, suffix){
        const re = new RegExp("("+label+"\\s*:\\s*)([^<]*)");
        html = html.replace(re, function(_,p1){ return p1 + (value!=null && !isNaN(value) ? (suffix==="%"? value.toFixed(0)+suffix : value.toFixed(suffix==="mm"?1:0)+" "+(suffix||"")).trim() : "--"); });
      }
      rep("Umidità", data.rh, "%");
      // Vento/Raffica riga combinata
      html = html.replace(/(Vento:\s*)([^<]*)(\s*\/\s*Raffica:\s*)([^<]*)/, function(){
        const v = (data.ws!=null && !isNaN(data.ws)) ? data.ws.toFixed(0)+" km/h" : "--";
        const g = (data.wg!=null && !isNaN(data.wg)) ? data.wg.toFixed(0)+" km/h" : "--";
        return "Vento: "+v+" / Raffica: "+g;
      });
      rep("Pioggia", data.rain, "mm");
      div.innerHTML = html;
    }catch(err){
      console.warn("Popup MeteoHub enrich error:", err);
    }
  });
})();
</script>


<script>
// === Estensione: aggiorna anche il pannello testuale in basso quando si apre un popup ===
(function(){
  function replaceInBlock(el, data){
    if (!el) return;
    let html = el.innerHTML;
    function rep(label, value, suffix){
      const re = new RegExp("("+label+"\\s*:\\s*)([^<]*)", "i");
      html = html.replace(re, function(_,p1){ return p1 + (value!=null && !isNaN(value) ? (suffix==="%"? value.toFixed(0)+suffix : value.toFixed(suffix==="mm"?1:0)+" "+(suffix||"")).trim() : "--"); });
    }
    // riga vento/raffica
    html = html.replace(/(Vento:\s*)([^<]*)(\s*\/\s*Raffica:\s*)([^<]*)/i, function(){
      const v = (data.ws!=null && !isNaN(data.ws)) ? data.ws.toFixed(0)+" km/h" : "--";
      const g = (data.wg!=null && !isNaN(data.wg)) ? data.wg.toFixed(0)+" km/h" : "--";
      return "Vento: "+v+" / Raffica: "+g;
    });
    rep("Umidità", data.rh, "%");
    rep("Pioggia", data.rain, "mm");
    el.innerHTML = html;
  }

  function updatePanelForName(name, data){
    if (!name || !data) return;
    const root = document.body;
    // Cerca blocchi che contengono il nome della stazione
    const nodes = Array.from(root.querySelectorAll("*"))
      .filter(n => n.children.length===0 && n.textContent && n.textContent.indexOf(name) !== -1)
      .map(n => n.parentElement);
    const uniq = new Set();
    for (const el of nodes){
      if (!el) continue;
      if (uniq.has(el)) continue;
      uniq.add(el);
      replaceInBlock(el, data);
    }
  }

  // Hook sullo stesso evento del popup (se definito dallo script precedente)
  var mapObj = window.map || window.mymap || window.MAP || window.leafmap || window.__leaflet_map;
  if (!mapObj && window.L && L?.map){
    for (const k in window){ if (window[k] && window[k] instanceof L.Map){ mapObj = window[k]; break; } }
  }
  if (!mapObj) return;

  mapObj.on('popupopen', function(e){
    const popupEl = e.popup.getElement()?.querySelector('.leaflet-popup-content');
    if (!popupEl) return;
    const title = popupEl.querySelector('div, b, strong, h1, h2, h3, h4');
    const name = (title ? title.textContent : popupEl.textContent).split("\\n")[0].trim();
    // L'altro script ha già fatto la fetch e aggiornato il popup; intercettiamo i valori già presenti
    // se disponibili. In caso contrario, lasciamo al primo script fare la fetch e poi rileggiamo dopo 800ms.
    setTimeout(function(){
      const text = popupEl.textContent;
      const rx = {
        rh: /Umidità:\s*([0-9]+)%/i,
        ws: /Vento:\s*([0-9]+)\s*km\/h/i,
        wg: /Raffica:\s*([0-9]+)\s*km\/h/i,
        rain: /Pioggia:\s*([0-9]+(?:\.[0-9]+)?)\s*mm/i
      };
      const data = {
        rh: rx.rh.test(text)? Number(text.match(rx.rh)[1]) : null,
        ws: rx.ws.test(text)? Number(text.match(rx.ws)[1]) : null,
        wg: rx.wg.test(text)? Number(text.match(rx.wg)[1]) : null,
        rain: rx.rain.test(text)? Number(text.match(rx.rain)[1]) : null
      };
      updatePanelForName(name, data);
    }, 900);
  });
})();
</script>

</body>







<!-- === Metric reconcile patch 2025‑07‑11 v4 === -->
<script id="metric_reconcile_20250711_v4">
(function(){
  if(globalThis.__metricReconcileV4) return;
  globalThis.__metricReconcileV4=true;

  /* ------------------ Parametri regolabili -------------------------------- */
  const MAX_DIST_KM      = 6;     // raggio max per considerare la WU
  const MAX_WU_WEIGHT    = 0.6;   // contributo massimo della WU (0‑1)
  const THR_TEMP         = 1.5;   // soglia minima di scarto per intervenire (°C)
  const THR_HUM          = 6;     // soglia umidità (%)
  const THR_EXTREMI      = 0.8;   // soglia estremi (°C)

  /* ------------------ Funzioni d'aiuto ------------------------------------ */
  const toRad=d=>d*Math.PI/180;
  const distKm=(la1,lo1,la2,lo2)=>{const R=6371,dLat=toRad(la2-la1),dLon=toRad(lo2-lo1);const a=Math.sin(dLat/2)**2+Math.cos(toRad(la1))*Math.cos(toRad(la2))*Math.sin(dLon/2)**2;return 2*R*Math.asin(Math.sqrt(a));};
  const isNum=v=>Number.isFinite(v);
  const lerp=(a,b,w)=>a+w*(b-a);

  /* Jitter deterministico in base all'id stazione: restituisce -delta..+delta */
  function jitter(id, delta){
     const h=Array.from(id).reduce((s,c)=>((s<<5)-s)+c.charCodeAt(0),0);
     return ((h%100)/100 - 0.5)*2*delta;   // range [-delta, +delta]
  }

  const getG=()=>{try{return{datiTabella,stazioni}}catch(_){return null;}};

  function reconcile(){
     const g=getG(); if(!g) return;
     const {datiTabella,stazioni}=g;
     const meta=Object.create(null);
     stazioni.forEach(s=>meta[s.stationId]=s);

     const wuRows=datiTabella.filter(r=>{const m=meta[r.stationId];return m&&!m.openMeteo&&isNum(+r.tempVal);});

     let changed=false;

     datiTabella.forEach(r=>{
        const m=meta[r.stationId]; if(!m||!m.openMeteo) return;

        /* Trova WU più vicina */
        let near=null,best=Infinity;
        for(const w of wuRows){
          const wm=meta[w.stationId]; if(!wm) continue;
          const d=distKm(m.lat,m.lon,wm.lat,wm.lon);
          if(d<best){best=d;near=w;}
        }
        if(!near||best>MAX_DIST_KM) return;

        const W = MAX_WU_WEIGHT * (1 - best / MAX_DIST_KM);   // peso dinamico 0..MAX_WU_WEIGHT

        /* ---------------- Temperatura ------------------------------------ */
        const omT = +r.tempVal, wuT = +near.tempVal;
        if(isNum(omT)&&isNum(wuT)){
           if(Math.abs(omT-wuT)>=THR_TEMP){
              const newT=+lerp(omT,wuT,W) + jitter(r.stationId,0.15);
              const adjT=+newT;
              if(adjT!==r.tempVal){r.tempVal=adjT;r.temp=adjT;changed=true;}
           }
        }else if(!isNum(omT)&&isNum(wuT)){
           /* Fallback: OM mancante -> adotta WU + jitter */
           const adj=+((wuT + jitter(r.stationId,0.25)));
           if(adj!==r.tempVal){r.tempVal=adj;r.temp=adj;changed=true;}
        }

        /* ---------------- Umidità ---------------------------------------- */
        const omH=+r.umidita, wuH=+near.umidita;
        if(isNum(omH)&&isNum(wuH)){
           if(Math.abs(omH-wuH)>=THR_HUM){
              const newH=Math.round(lerp(omH,wuH,W) + jitter(r.stationId,2));
              if(newH!==r.umidita){r.umidita=newH;changed=true;}
           }
        }else if(!isNum(omH)&&isNum(wuH)){
           const adj=Math.round(wuH + jitter(r.stationId,3));
           if(adj!==r.umidita){r.umidita=adj;changed=true;}
        }

        /* ---------------- Estremi giornalieri ---------------------------- */
        function adjExt(keyOM,keyWU,thr,delta){
           const om=isNum(+r[keyOM])?+r[keyOM]:null;
           const wu=isNum(+near[keyWU])?+near[keyWU]:null;
           if(wu==null) return;

           if(om!=null){
              if(Math.abs(om-wu)>=thr){
                 const val=+lerp(om,wu,W)+jitter(r.stationId,delta);
                 const adj=+val;
                 if(adj!==r[keyOM]){r[keyOM]=adj;changed=true;}
              }
           }else{
              const adj=+((wu + jitter(r.stationId,delta)));
              if(adj!==r[keyOM]){r[keyOM]=adj;changed=true;}
           }
        }
        adjExt('tMin','tMin',THR_EXTREMI,0.15);
        adjExt('tMax','tMax',THR_EXTREMI,0.15);

        if(window.extremiGiornalieri){
           const ext=window.extremiGiornalieri[r.stationId]=window.extremiGiornalieri[r.stationId]||{};
           if(isNum(+r.tMin))ext.min=+r.tMin;
           if(isNum(+r.tMax))ext.max=+r.tMax;
        }
     
        /* === APPLY OFFSET AFTER ALIGNMENT === */
        if(window.stationOffsets){
          (function(){
            function norm(s){return (s||'').toString().trim().toLowerCase();}
            const OFF = window.stationOffsets||{};
            function isNum(v){return typeof v==='number' && !isNaN(v);}
            function findOff(r){
              const keys=[r.stationId,r.nome,(meta[r.stationId] && meta[r.stationId].nome)];
              for(const k in OFF){
                const lk=norm(k);
                for(const ky of keys){
                  if(!ky) continue;
                  const nk=norm(ky);
                  if(nk===lk || nk.includes(lk) || lk.includes(nk)) return OFF[k];
                }
              }
              return null;
            }
            const of = findOff(r);
            if(of && !r.__chatgptOff){
               function add(field,key,mirror){
                  if(r[field]!=null && isNum(+r[field]) && typeof of[key]==='number'){
                    const v = +( (+r[field]) + of[key] );
                    if(v!==r[field]){ r[field]=v; changed=true; }
                    if(mirror){ r[mirror]=typeof r[mirror]==='number'? v : v.toFixed ? v:v; }
                  }
               }
               add('tempVal','temp','temp');
               add('tMax','tmax',null);
               add('tMin','tmin',null);
               add('umidita','umidita',null);
               add('pioggia','pioggia',null);
               add('percepitaVal','percepita','percepita');
               add('raffica','raffica',null);
               r.__chatgptOff=true;
               if(window.extremiGiornalieri){
                  const ext=window.extremiGiornalieri[r.stationId]=window.extremiGiornalieri[r.stationId]||{};
                  if(isNum(+r.tMin))ext.min=+r.tMin;
                  if(isNum(+r.tMax))ext.max=+r.tMax;
               }
            }
          })();
        }
        /* === END OFFSET AFTER ALIGNMENT === */

        // OFFSET finale
        applyOffsetRow(r);
});

     if(changed){
        if(typeof aggiornaTabella==='function') aggiornaTabella();
        const active=sel=>!!document.querySelector('.sidebar-btn.attivo[onclick*="'+sel+'"]');
        if(active('visualizzaAttuali')&&typeof visualizzaAttuali==='function')visualizzaAttuali();
        if(active('visualizzaUmidita')&&typeof visualizzaUmidita==='function')visualizzaUmidita();
        if(active('visualizzaEstremi')&&typeof visualizzaEstremi==='function')visualizzaEstremi();
     }
  }

  /* Hook push & render ---------------------------------------------------- */
  (function boot(){
     const g=getG(); if(!g){setTimeout(boot,300);return;}
     const {datiTabella}=g;
     if(Array.isArray(datiTabella)&&!datiTabella.__metricHooked){
        const push=datiTabella.push.bind(datiTabella);
        datiTabella.push=function(...a){const res=push(...a);setTimeout(reconcile,0);return res;};
        datiTabella.__metricHooked=true;
     }
     ['visualizzaAttuali','visualizzaUmidita','visualizzaEstremi'].forEach(fn=>{
        const f=window[fn]; if(typeof f!=='function'||f.__metricWrap) return;
        window[fn]=function(...a){reconcile();return f.apply(this,a);};
        window[fn].__metricWrap=true;
     });
     reconcile();
  })();
})();
</script>
<!-- === /Metric reconcile patch === -->

<!-- === Auto‑Repeat Display Patch – 26 Jul 2025 (incl. MM) === -->
<script id="auto-repeat-display">
(function(){
  let activeFn=null, activeArgs=[], rafId=null;

  function loop(){
    if(typeof activeFn==='function'){
      try{ activeFn.apply(window, activeArgs); }catch(e){}
      rafId = requestAnimationFrame(loop);
    }
  }

  function start(fn, args){
    activeFn = fn;
    activeArgs = args;
    if(rafId) cancelAnimationFrame(rafId);
    rafId = requestAnimationFrame(loop);
  }

  function wrap(name){
    const orig = window[name];
    if(typeof orig!=='function' || orig.__autoRepeatWrapped) return;
    window[name] = function(...args){
      const res = orig.apply(this, args);
      if(name !== 'visualizzaAttuali'){
        start(orig, args);
      } else {
        activeFn = null;
        if(rafId){ cancelAnimationFrame(rafId); rafId=null; }
      }
      return res;
    };
    window[name].__autoRepeatWrapped = true;
  }

  function boot(){
    ['visualizzaAttuali',
     'visualizzaUmidita',
     'visualizzaPercepita',
     'visualizzaRaffiche',
     'visualizzaEstremi',
     'visualizzaPioggia'].forEach(wrap);
  }

  if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', boot);
  else boot();
})();
</script>


<!-- === MeteoHub BULK adapter v5 (bbox Calabria + chunked rendering + hard guards) === -->
<script>
(function(){
  const DIRECT_ENDPOINT = "https://meteohub.agenziaitaliameteo.it/api/observations";
  const PROXY_ENDPOINT  = ""; // es. https://mh-proxy.tuonome.workers.dev

  // Limita ai punti entro la Calabria per evitare 3000+ marker che bloccano la pagina
  const BBOX = { minLat: 37.8, maxLat: 40.4, minLon: 15.0, maxLon: 17.6 };
  const MAX_STAZIONI = 600;      // ulteriore guardrail
  const CHUNK_SIZE   = 120;      // inserisce i marker a piccoli blocchi per non bloccare il thread
  const AGGIUNGI_IN_TABELLA = true;

  function pad(n){ return String(n).padStart(2,'0'); }
  function fmtUTC(d){ return `${d.getUTCFullYear()}-${pad(d.getUTCMonth()+1)}-${pad(d.getUTCDate())} ${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}`; }
  function buildUrl(base, minutesBack){
    const now = new Date();
    const from = new Date(now.getTime() - minutesBack*60*1000);
    const q = `reftime: >=${fmtUTC(from)},<=${fmtUTC(now)};product:B12101;license:CCBY_COMPLIANT;timerange:254,0,0;level:103,2000,0,0`;
    const u = new URL(base);
    u.searchParams.set("q", q);
    u.searchParams.set("reliabilityCheck", "true");
    u.searchParams.set("last", "true");
    u.searchParams.set("ts", Date.now());
    return u.toString();
  }

  async function fetchJson(url){
    console.log("[MHv5] fetch:", url);
    const r = await fetch(url, { cache:"no-store" });
    if(!r.ok) throw new Error("HTTP "+r.status);
    return await r.json();
  }

  // Estrae il prodotto B12101 anche quando è dentro array/oggetti annidati
  function pickProd(st, code){
    const arr = st?.prod || st?.products || st?.var || st?.variables || [];
    let p = null;
    if (Array.isArray(arr)) {
      p = arr.find(x => String(x.var || x.code).toUpperCase() === String(code).toUpperCase());
    } else if (arr && typeof arr === "object") {
      p = arr[code] || arr[String(code)];
    }
    if (!p) return null;

    if (typeof p === "number") return p;
    if (p.val != null && typeof p.val === "number") return Number(p.val);
    if (Array.isArray(p.val) && p.val.length) {
      const last = p.val[p.val.length-1];
      if (last && last.val != null) return Number(last.val);
    }
    if (p.value != null) return Number(p.value);
    if (Array.isArray(p) && p.length && p[0].val != null) return Number(p[0].val);
    return null;
  }

  function normalize(st){
    const lat = Number(st.lat ?? st.latitude ?? st.stat?.lat);
    const lon = Number(st.lon ?? st.longitude ?? st.stat?.lon);
    const detailsArr = Array.isArray(st.stat?.details) ? st.stat.details : null;
const longNameMH = detailsArr?.find(d => String(d.var || d.code || "").toUpperCase() === "B01019")?.val;
const name = st.name
          || st.station_name
          || st.stat?.name
          || longNameMH
          || (st.stat && (st.stat["LONG STATION OR SITE NAME"] || st.stat["Long station or site name"]))
          || "Stazione";
    const time = st.time || st.timestamp || st.reftime || st.obs_time || new Date().toISOString();
    let t  = pickProd(st, "B12101");
    if (t == null) t = Number(st.temperature ?? st.temp ?? st.t);
    if (Number.isFinite(t) && (t > 120 || t < -100)) t = t - 273.15;
    let rh = Number(st.humidity ?? st.rh ?? NaN);
    if (!Number.isFinite(rh)) {
      const _rh = pickProd(st, "B13003");
      if (Number.isFinite(_rh)) rh = _rh;
    }
    const ws = Number(st.wind_speed ?? st.ws ?? NaN);
    const wg = Number(st.wind_gust  ?? st.wg ?? ws ?? NaN);
    const rr = Number(st.rain_1h    ?? st.rain ?? st.precip ?? 0);
    return {
      id: String(st.id || st.station_id || st.code || st.slug || `${lat},${lon}`),
      name, lat, lon, time,
      t: Number.isFinite(t) ? t : null,
      rh: Number.isFinite(rh) ? rh : null,
      ws: Number.isFinite(ws) ? ws : null,
      wg: Number.isFinite(wg) ? wg : null,
      rr: Number.isFinite(rr) ? rr : 0
    };
  }

  function inBbox(s){
    return Number.isFinite(s.lat) && Number.isFinite(s.lon) &&
           s.lat >= BBOX.minLat && s.lat <= BBOX.maxLat &&
           s.lon >= BBOX.minLon && s.lon <= BBOX.maxLon;
  }

  const EXT_KEY = "mh_extremes_v1";
  function loadExt(){
    try{
      const x = JSON.parse(localStorage.getItem(EXT_KEY)||"{}");
      const day = new Date().toISOString().slice(0,10);
      if(x.day !== day) return {day, byId:{}};
      return x;
    }catch{ return {day:new Date().toISOString().slice(0,10), byId:{}}; }
  }
  function saveExt(x){ localStorage.setItem(EXT_KEY, JSON.stringify(x)); }

  async function caricaMeteoHub(){
    let data=null;
    try { data = await fetchJson(buildUrl(DIRECT_ENDPOINT, 360)); }
    catch(e){
      console.warn("[MHv5] direct failed:", e.message);
      if(PROXY_ENDPOINT){
        try{ data = await fetchJson(buildUrl(PROXY_ENDPOINT, 360)); }
        catch(e2){ console.error("[MHv5] proxy failed:", e2.message); }
      }
    }
    if(!data){ console.error("[MHv5] nessun dato"); return; }

    const listRaw = Array.isArray(data) ? data : (data.stations || data.data || data.results || []);
    let list = [];
    for(const st of listRaw){
      const s = normalize(st);
      if (inBbox(s) && Number.isFinite(s.t)) list.push(s);
      if (list.length >= MAX_STAZIONI) break;
    }
    console.log(`[MHv5] records totali: ${listRaw.length}, usati (Calabria): ${list.length}`);
    if(!list.length) return;

    window.datiTabella = window.datiTabella || [];
    window.extremiGiornalieri = window.extremiGiornalieri || {};
    window.markersById = window.markersById || {};
    const ext = loadExt();

    // Inserimento a blocchi per non bloccare la pagina
    let i = 0;
    async function processChunk(){
      const end = Math.min(i + CHUNK_SIZE, list.length);
      for(; i<end; i++){
        const s = list[i];
        const stationId = `MH_${s.id}`;
        const punto = {
          metric: { temp: s.t, precipTotal: s.rr },
          humidity: s.rh,
          windSpeed: s.ws,
          windGust: s.wg,
          obsTimeUtc: s.time
        };

        try{
          const info = { stationId, nome: s.name, lat: s.lat, lon: s.lon, area: s.area || s.municipality || s.comune || "--", provincia: s.provincia || s.province || s.prov || "--", openMeteo:false };
          if(typeof window.aggiungiMarker === "function") window.aggiungiMarker(info, punto);
        }catch(e){ /* ignora singoli errori */ }

        if (AGGIUNGI_IN_TABELLA){
          let percepitaVal = NaN;
          if (typeof window.calcolaPercepita === "function") {
            try{ percepitaVal = window.calcolaPercepita(s.t, s.rh, s.ws); }catch{ percepitaVal = NaN; }
          }
          window.datiTabella.push({
            stationId,
            nome: s.name,
            temp: Number.isFinite(s.t) ? s.t : "--",
            tempVal: Number.isFinite(s.t) ? s.t : null,
            pioggia: Number.isFinite(s.rr) ? s.rr : 0,
            umidita: Number.isFinite(s.rh) ? s.rh : "--",
            raffica: Number.isFinite(s.wg) ? s.wg : "--",
            percepita: Number.isFinite(percepitaVal) ? percepitaVal : "--",
            percepitaVal
          });

          // estremi rolling
          const prev = ext.byId[stationId] || {min:+Infinity, max:-Infinity};
          prev.min = Math.min(prev.min, s.t);
          prev.max = Math.max(prev.max, s.t);
          ext.byId[stationId] = prev;
          window.extremiGiornalieri[stationId] = {
            min: Number.isFinite(prev.min) ? prev.min : "--",
            max: Number.isFinite(prev.max) ? prev.max : "--"
          };
        }
      }
      if (typeof window.visualizzaAttuali === "function") window.visualizzaAttuali();
      if (typeof window.aggiornaTabella === "function") window.aggiornaTabella();
      saveExt(ext);
      if (i < list.length) {
        setTimeout(processChunk, 0); // cedi il controllo per evitare "pagina non risponde"
      }
    }
    processChunk();
  }

  async function start(){
    await caricaMeteoHub();
    setInterval(async ()=>{
      try{
        // rimuovi vecchie righe MH
        const ids = new Set((window.datiTabella||[]).filter(r => String(r.stationId||"").startsWith("MH_")).map(r=>r.stationId));
        if(Array.isArray(window.datiTabella)){
          for(let i=window.datiTabella.length-1;i>=0;i--){
            if(ids.has(window.datiTabella[i].stationId)) window.datiTabella.splice(i,1);
          }
        }
        await caricaMeteoHub();
      }catch(e){ console.error("refresh MH", e); }
    }, 180000); // 3 minuti
  }
  if(document.readyState === "loading") document.addEventListener("DOMContentLoaded", start);
  else start();
})();
</script>
<!-- === /MeteoHub BULK adapter v5 === -->
</html>
<script>
function aggiornaPopupConEstremi(marker, stazione) {
  marker.on('click', async () => {
    const stationId = stazione.stationId;
    const popup = L.popup().setLatLng([stazione.lat, stazione.lon]);
    let contenuto = `<div class='popup-title'>${stazione.nome}</div>`;

    try {
      const q = firebase.firestore().collection("osservazioni").where("stationId", "==", stationId);
      const snapshot = await q.get();
      let min = Infinity, max = -Infinity;
      let count = 0;
      snapshot.forEach(doc => {
        const data = doc.data();
        const temp = data.temperatura;
        if (typeof temp === 'number') {
          if (temp < min) min = temp;
          if (temp > max) max = temp;
          count++;
        }
      });

      contenuto += `<div class='popup-sub'>Estremi giornalieri</div>`;
      contenuto += `<div class='popup-data'>Min: <span class='bold'>${min !== Infinity ? min : '-' }°C</span></div>`;
      contenuto += `<div class='popup-data'>Max: <span class='bold'>${max !== -Infinity ? max : '-' }°C</span></div>`;
      contenuto += `<div class='popup-data'><em>Debug: ${count} valori trovati</em></div>`;
    } catch (e) {
      contenuto += `<div class='popup-data'>Errore: ${e.message}</div>`;
    }

    popup.setContent(contenuto);
    popup.openOn(mymap);
  });
}

function getColorPioggia(mm) {
  mm = parseFloat(mm);
  if (isNaN(mm) || mm === 0) return "#d5e8ff";   // very light blue
  if (mm <= 0.9)  return "#b9dbff";
  if (mm <= 2.9)  return "#9dceff";
  if (mm <= 4.9)  return "#8ac7ff";
  if (mm <= 9.9)  return "#5aa9ff";
  if (mm <= 19.9) return "#2a8cff";
  if (mm <= 29.9) return "#116dff";
  if (mm <= 49.9) return "#006fd6";
  if (mm <= 99.9) return "#004c8c";
  return "#003060"; // 100 mm +
}


function visualizzaRaffiche() {
  datiTabella.forEach((d) => {
    const marker = markersById[d.stationId];
    if (!marker) return;

    const val = parseFloat(d.raffica);
    if (!Number.isFinite(val)) return;

    const colore = (typeof getColorVento === "function")
      ? getColorVento(val)
      : val > 80 ? "#8B0000"
      : val > 60 ? "#B22222"
      : val > 40 ? "#DC143C"
      : val > 20 ? "#FF4500"
      : "#FF8C00";

    const el = marker.getElement();
    if (el) {
      el.innerHTML = `<span style='color:${getTextColorForBackground(colore)}; font-size:11px; font-weight:bold;'>${val.toFixed(0)}</span>`;
      el.style.backgroundColor = colore;
      el.style.width = "48px";
      el.style.height = "48px";
      el.style.display = "flex";
      el.style.alignItems = "center";
      el.style.justifyContent = "center";
    }
  });
}

</script>
(marker, stazione) {
  marker.on('click', async () =&gt; {
    const stationId = stazione.stationId;
    const popup = L.popup().setLatLng([stazione.lat, stazione.lon]);
    let contenuto = `<div class="popup-title">${stazione.nome}</div>`;

    try {
      const { min, max } = await getExtremesFromFirebase(stationId);
      contenuto += `<div class="popup-sub">Estremi giornalieri</div>`;
      contenuto += `<div class="popup-data">Min: <span class="bold">${min !== null ? min : '-' }°C</span></div>`;
      contenuto += `<div class="popup-data">Max: <span class="bold">${max !== null ? max : '-' }°C</span></div>`;
    } catch (e) {
      contenuto += `<div class="popup-data">Errore nel recupero estremi</div>`;
    }

    popup.setContent(contenuto);
    popup.openOn(mymap);
  });
}


<!-- ========= FASTLOAD PATCH 2025‑07‑24 v8.1 (fix overlay & first-zoom freeze) ========= -->
<script id="fastload_20250724_v81">
(function(){
  if (window.__fastload20250724_v81) return;
  window.__fastload20250724_v81 = true;

  const IS_MOBILE = /Android|iPhone|iPad|iPod|Mobile/i.test(navigator.userAgent);
  const CPU = Math.max(1, navigator.hardwareConcurrency || 2);

  // Priorità WU
  const WU_MAX = Math.min(8, Math.max(2, CPU * (IS_MOBILE ? 1 : 2)));
  const OM_MAX = Math.min(6, Math.max(1, CPU - 1));

  const VISUALIZZA_DEBOUNCE = 100;
  const FETCH_TIMEOUT_MS    = 9000;

  // --- nuovo: fase di “grazia” iniziale per NON bloccare lo zoom/pan ---
  const GRACE_MS                 = 1500;     // entro questa finestra limitiamo al massimo gli aggiornamenti
  const MARKERS_PER_FRAME_GRACE  = 2;
  const MARKERS_PER_FRAME_NORMAL = IS_MOBILE ? 6 : 20;
  const MAX_VISIBLE_MOBILE       = 400;
  const MAX_VISIBLE_DESKTOP      = 1200;

  let currentGeneration = 0;
  let started = false;
  let inGrace = true;
  let graceTimer = null;
  let PAUSE_UI = false;

  // 0) Togli SUBITO l'overlay (e anche pointer-events)
  requestAnimationFrame(()=>{
    const ov = document.getElementById('overlay') || document.querySelector('#loading,.overlay,[data-overlay]');
    if (ov){
      ov.style.opacity = '0';
      ov.style.pointerEvents = 'none';
      ov.style.display = 'none';
    }
    document.documentElement.classList.add('fastload-ready');
  });

  function debounce(fn, wait, leading=false){
    let t, pendingArgs=null, pendingThis=null, invoked=false;
    const fire = ()=>{
      t=null;
      if (!leading || invoked){
        if (pendingArgs){
          fn.apply(pendingThis, pendingArgs);
          pendingArgs=pendingThis=null;
        }
        invoked=false;
      }
    };
    return function(...args){
      pendingArgs=args; pendingThis=this;
      if (!t){
        t=setTimeout(fire, wait);
        if (leading && !invoked){
          invoked=true;
          fn.apply(this, args);
        }
      }else{
        clearTimeout(t);
        t=setTimeout(fire, wait);
      }
    };
  }

  if (typeof window.visualizzaAttuali === 'function' && !window.visualizzaAttuali.__debounced_v81){
    const _orig = window.visualizzaAttuali;
    const deb = debounce(()=>{
      if (PAUSE_UI) return;
      requestAnimationFrame(_orig);
    }, VISUALIZZA_DEBOUNCE, true);
    deb.__orig = _orig;
    window.visualizzaAttuali = deb;
    window.visualizzaAttuali.__debounced_v81 = true;
  }

  // scheduler
  const MarkerScheduler = (function(){
    let queue = [];
    let running = false;
    function loop(gen){
      running = true;
      const start = performance.now();
      let count = 0;
      const BATCH = inGrace ? MARKERS_PER_FRAME_GRACE : MARKERS_PER_FRAME_NORMAL;
      while(queue.length && count < BATCH){
        if (gen !== currentGeneration){ queue = []; break; }
        const job = queue.shift();
        try{ job.fn(); }catch(e){ console.error('[v8.1] job err', e); }
        count++;
        if (performance.now() - start > 6) break;
      }
      if (queue.length && gen === currentGeneration){
        requestAnimationFrame(()=>loop(gen));
      } else {
        running = false;
      }
    }
    return {
      push(fn){
        queue.push({ fn, gen: currentGeneration });
        if (!running) requestAnimationFrame(()=>loop(currentGeneration));
      },
      clearAndBump(){
        currentGeneration++;
        queue = [];
      }
    };
  })();

  if (typeof window.aggiungiMarker === 'function' && !window.aggiungiMarker.__fastload_v81){
    const _orig = window.aggiungiMarker;
    window.aggiungiMarker = function(){
      const args = arguments;
      const gen = currentGeneration;
      MarkerScheduler.push(()=>{ if(gen === currentGeneration) _orig.apply(window, args); });
    };
    window.aggiungiMarker.__fastload_v81 = true;
  }

  function getMap(){
    return window.mymap || window.map || window.leafletMap || (window.L && window.L.map && window.L.mapInstance);
  }
  function inBounds(st, bounds){
    return st.lat >= bounds.getSouth() && st.lat <= bounds.getNorth() &&
           st.lon >= bounds.getWest()  && st.lon <= bounds.getEast();
  }
  function gridSizeForZoom(z){
    return Math.max(0.02, 1.5 * Math.pow(0.5, (z - 3) / 2));
  }
  function thinByGrid(stations, map){
    const z = map.getZoom ? map.getZoom() : 6;
    const grid = gridSizeForZoom(z);
    const buckets = new Map();
    for (const st of stations){
      const key = `${Math.round(st.lat/grid)}:${Math.round(st.lon/grid)}`;
      if (!buckets.has(key)) buckets.set(key, st);
    }
    let reduced = Array.from(buckets.values());
    const cap = IS_MOBILE ? MAX_VISIBLE_MOBILE : MAX_VISIBLE_DESKTOP;
    if (reduced.length > cap) reduced = reduced.slice(0, cap);
    return reduced;
  }

  // Worker (WU first)
  const workerCode = `
    const FETCH_TIMEOUT_MS = ${FETCH_TIMEOUT_MS};
    function withTimeout(p, ms){
      return new Promise((resolve, reject)=>{
        const t = setTimeout(()=>reject(new Error('timeout')), ms);
        p.then(v=>{ clearTimeout(t); resolve(v); },
               e=>{ clearTimeout(t); reject(e); });
      });
    }
    async function fetchJSON(url){
      const r = await withTimeout(fetch(url), FETCH_TIMEOUT_MS);
      return r.json();
    }
    async function pool(list, max, tag, makeUrl){
      const q = list.slice();
      async function worker(){
        while(q.length){
          const st = q.shift();
          try{
            const url = makeUrl(st);
            const d = await fetchJSON(url);
            postMessage({type: tag, data: { st, d }});
          }catch(e){}
          await new Promise(r=>setTimeout(r,0));
        }
      }
      await Promise.all(Array.from({length: Math.min(max, q.length)}, worker).map(f=>f()));
    }
    async function run(payload){
      const { stazioni, wuMax, omMax } = payload;
      const wu = stazioni.filter(s=>s.apiKey);
      const om = stazioni.filter(s=>s.openMeteo);

      await pool(wu, wuMax, 'wu', st =>
        \`https://api.weather.com/v2/pws/observations/current?stationId=\${st.stationId}&format=json&units=m&apiKey=\${st.apiKey}\`
      );
      await pool(om, omMax, 'om', st =>
        \`https://api.open-meteo.com/v1/forecast?latitude=\${st.lat}&longitude=\${st.lon}&current=temperature_2m,relativehumidity_2m,precipitation,wind_gusts_10m,wind_speed_10m&timezone=auto\`
      );

      postMessage({type:'done'});
    }
    onmessage = (e)=>{ if (e.data?.type==='start') run(e.data.payload); };
  `;
  const worker = new Worker(URL.createObjectURL(new Blob([workerCode], {type:'application/javascript'})));

  worker.onmessage = (e)=>{
    const { type, data } = e.data || {};
    if (type === 'wu'){
      if (typeof window.processWU === 'function'){
        const st = data.st, d = data.d;
        MarkerScheduler.push(()=>window.processWU(st, d));
      }
      if (typeof window.visualizzaAttuali === 'function') window.visualizzaAttuali();
    } else if (type === 'om'){
      const st = data.st, d = data.d;
      const t2 = d?.current?.temperature_2m;
      const rh = d?.current?.relativehumidity_2m;
      const ws = d?.current?.wind_speed_10m;
      let perc = null;
      try{ if (typeof calcolaPercepita === 'function') perc = calcolaPercepita(t2, rh, ws); }catch(_){}
      const entry = {
        stationId   : st.stationId,
        temp        : t2,
        tempVal     : t2,
        pioggia     : d?.current?.precipitation,
        umidita     : rh,
        raffica     : d?.current?.wind_gusts_10m,
        percepita   : (perc!=null && isFinite(perc)) ? perc : '--',
        percepitaVal: perc
      };
      window.datiTabella = window.datiTabella || [];
      window.datiTabella.push(entry);
      if (typeof window.visualizzaAttuali === 'function') window.visualizzaAttuali();
    } else if (type === 'done'){
      if (typeof window.visualizzaAttuali === 'function') window.visualizzaAttuali();
      console.log('[FASTLOAD v8.1] done');
    }
  };

  function bootstrap(){
    const map = getMap();
    if (!Array.isArray(window.stazioni) || !window.stazioni.length || !map || !map.getBounds){
      setTimeout(bootstrap, 100);
      return;
    }
    if (started) return;
    started = true;

    // disabilita OM legacy
    if (window.caricaDatiOpenMeteo && !window.caricaDatiOpenMeteo.__disabledBy_v81){
      const _orig = window.caricaDatiOpenMeteo;
      window.caricaDatiOpenMeteo = function(){ console.warn('[v8.1] caricaDatiOpenMeteo disabilitata (gestita dal worker)'); };
      window.caricaDatiOpenMeteo.__disabledBy_v81 = true;
      window.caricaDatiOpenMeteo.__orig = _orig;
    }

    // inizia GRACE WINDOW
    graceTimer = setTimeout(()=>{ inGrace = false; }, GRACE_MS);

    // Primo render (solo per togliere overlay e mostrare UI)
    if (typeof window.visualizzaAttuali === 'function') window.visualizzaAttuali();

    // Lancia il worker SUBITO ma con rendering ultra throttled (inGrace)
    worker.postMessage({
      type: 'start',
      payload: { stazioni: window.stazioni.slice(), wuMax: WU_MAX, omMax: OM_MAX }
    });

    // Evita il blocco iniziale allo zoom: durante lo zoom/pan metti in pausa la UI
    if (!map.__fastload_v81_bound){
      const reRender = debounce(()=>{
        MarkerScheduler.clearAndBump();
        if (typeof window.visualizzaAttuali === 'function') window.visualizzaAttuali();
      }, 80);

      map.on('movestart', ()=>{
        PAUSE_UI = true;
        MarkerScheduler.clearAndBump();
      });
      map.on('zoomstart', ()=>{
        PAUSE_UI = true;
        MarkerScheduler.clearAndBump();
      });
      map.on('moveend', ()=>{
        PAUSE_UI = false;
        reRender();
      });
      map.on('zoomend', ()=>{
        PAUSE_UI = false;
        reRender();
      });

      // Se l’utente interagisce per primo (zoom/pan), usciamo subito dalla fase grace
      const stopGraceNow = ()=>{
        if (inGrace){
          inGrace = false;
          if (graceTimer) clearTimeout(graceTimer);
        }
      };
      map.on('zoomstart', stopGraceNow);
      map.on('movestart', stopGraceNow);

      map.__fastload_v81_bound = true;
    }
  }

  function getMap(){
    return window.mymap || window.map || window.leafletMap || (window.L && window.L.map && window.L.mapInstance);
  }

  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(bootstrap, 0);
  } else {
    document.addEventListener('DOMContentLoaded', bootstrap, { once: true });
  }
})();
</script>
<!-- ========= /FASTLOAD PATCH 2025‑07‑24 v8.1 ========= -->


<!-- ========= PATCH: BLOCCO ESTREMI INIZIALI (hard-freeze) ========= -->
<script id="freeze-estremi-lock-20251013">
(function(){
  if (window.__freezeEstremiInstalled__) return;
  window.__freezeEstremiInstalled__ = true;

  // Stato globale del blocco
  window.__freezeEstremi = false;
  window.__frozenExtremes = {};     // { stationId: {min, max} }
  window.__frozenAt = null;
  window.__frozenNote = "Blocca min/max di tutte le stazioni ai primi secondi utili";

  // Utilità
  function isNum(x){ return typeof x === 'number' && isFinite(x); }
  function toNum(x){
    const n = Number(x);
    return isFinite(n) ? +(+n) : NaN;
  }

  function collectIds(){
    const ids = new Set();
    if (Array.isArray(window.stazioni)) window.stazioni.forEach(s=>s?.stationId && ids.add(s.stationId));
    if (Array.isArray(window.datiTabella)) window.datiTabella.forEach(r=>r?.stationId && ids.add(r.stationId));
    return Array.from(ids);
  }

  function currentMin(id){
    // prova varie sorgenti
    if (typeof window.getEstremoGiornaliero === "function"){
      const v = window.getEstremoGiornaliero(id, 'min');
      if (isNum(v)) return +(+v);
    }
    const e = window.extremiGiornalieri && window.extremiGiornalieri[id];
    if (e && isNum(toNum(e.min))) return toNum(e.min);
    const row = (window.datiTabella||[]).find(r=>r.stationId===id);
    if (row && isNum(toNum(row.tMin))) return toNum(row.tMin);
    return NaN;
  }
  function currentMax(id){
    if (typeof window.getEstremoGiornaliero === "function"){
      const v = window.getEstremoGiornaliero(id, 'max');
      if (isNum(v)) return +(+v);
    }
    const e = window.extremiGiornalieri && window.extremiGiornalieri[id];
    if (e && isNum(toNum(e.max))) return toNum(e.max);
    const row = (window.datiTabella||[]).find(r=>r.stationId===id);
    if (row && isNum(toNum(row.tMax))) return toNum(row.tMax);
    return NaN;
  }

  function freezeNow(){
    const ids = collectIds();
    let countOk = 0;
    const snap = {};
    ids.forEach(id=>{
      const mn = currentMin(id);
      const mx = currentMax(id);
      if (isNum(mn) || isNum(mx)){
        snap[id] = {
          min: isNum(mn) ? +mn : undefined,
          max: isNum(mx) ? +mx : undefined
        };
        if (isNum(mn) && isNum(mx)) countOk++;
      }
    });
    if (Object.keys(snap).length === 0) return false; // niente da congelare
    window.__frozenExtremes = snap;
    window.__freezeEstremi = true;
    window.__frozenAt = new Date();

    // 1) Proxy su extremiGiornalieri: letture/ scritture
    try {
      const base = window.extremiGiornalieri || {};
      window.__extremiBase = base;
      window.extremiGiornalieri = new Proxy(base, {
        get(target, prop, receiver){
          if (window.__freezeEstremi && Object.prototype.hasOwnProperty.call(window.__frozenExtremes, prop)){
            return window.__frozenExtremes[prop];
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver){
          // durante il freeze ignoriamo scritture sui singoli id
          if (window.__freezeEstremi) return true;
          return Reflect.set(target, prop, value, receiver);
        }
      });
    } catch(e){ console.warn("Proxy extremiGiornalieri non supportato:", e); }

    // 2) Wrap getEstremoGiornaliero per forzare la snapshot
    (function wrapGet(){
      const orig = window.getEstremoGiornaliero;
      window.getEstremoGiornaliero = function(stationId, tipo){
        if (window.__freezeEstremi){
          const f = window.__frozenExtremes && window.__frozenExtremes[stationId];
          if (f){
            const v = (tipo==='max') ? f.max : f.min;
            if (isNum(v)) return +(+v);
          }
        }
        if (typeof orig === 'function') return orig.apply(this, arguments);
        // fallback
        const e = (window.__extremiBase||window.extremiGiornalieri||{})[stationId] || {};
        const v = (tipo==='max') ? e.max : e.min;
        return toNum(v);
      };
      window.getEstremoGiornaliero.__frozenWrapped = true;
    })();

    // 3) Evita che i marker vengano sovrascritti con attuali quando si è in modalità min/max
    function guard(fnName){
      const orig = window[fnName];
      if (typeof orig !== 'function') return;
      if (orig.__freezeGuard) return;
      window[fnName] = function(){
        const mode = (window.ultimoModo || '').toLowerCase();
        if (window.__freezeEstremi && (mode==='min' || mode==='max') && (fnName!=='visualizzaEstremi')){
          // blocca aggiornamento non coerente
          return;
        }
        return orig.apply(this, arguments);
      };
      window[fnName].__freezeGuard = true;
    }
    ['visualizzaAttuali','visualizzaUmidita','visualizzaPercepita','visualizzaRaffiche','aggiornaPopupConEstremiFinale','aggiornaTabellaConEstremi'].forEach(guard);

    // 4) Refresh coerente: mantieni la modalità attuale senza forzare MIN
    try{
if (typeof window.aggiornaTabella === 'function') window.aggiornaTabella();
      if (typeof window.aggiornaPopup === 'function') window.aggiornaPopup();
            if (window.ultimoModo==='max' || window.ultimoModo==='min'){
        if (typeof window.visualizzaEstremi === 'function') window.visualizzaEstremi(window.ultimoModo);
      } else if (typeof window.visualizzaAttuali === 'function') {
        window.visualizzaAttuali();
      }
    }catch{}
// 5) Etichetta discreta in pagina (opzionale)
    try{
      const b = document.createElement('div');
      b.id = 'badge-freeze-estremi';
      b.textContent = 'ESTREMI BLOCCATI';
      Object.assign(b.style, {
        position:'fixed', bottom:'10px', right:'10px', zIndex:10000,
        background:'#1a3a9b', color:'#fff', padding:'6px 10px',
        borderRadius:'8px', font:'600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial'
      });
      document.body.appendChild(b);
    }catch{}
    console.log('[FreezeEstremi] Congelati', Object.keys(window.__frozenExtremes).length, 'ID. Ora i min/max non verranno più sovrascritti.');
    return true;
  }

  // Tentativo automatico: usa i "primi secondi" finché non c'è almeno un set completo
  (function autoFreeze(){
    const t0 = Date.now();
    const MAX_MS = 12000; // fino a 12s
    const tick = () => {
      if (window.__freezeEstremi) return; // già fatto
      // condizione di "pronto": markers e almeno qualche estremo numerico disponibile
      const pronto = !!(window.markersById && Object.keys(window.markersById).length);
      let hasExt = false;
      if (window.extremiGiornalieri) {
        for (const k in window.extremiGiornalieri){
          const e = window.extremiGiornalieri[k];
          if (e && (isNum(toNum(e.min)) || isNum(toNum(e.max)))) { hasExt = true; break; }
        }
      }
      if (pronto && hasExt){
        if (freezeNow()) return; // done
      }
      if (Date.now() - t0 < MAX_MS){
        setTimeout(tick, 300);
      } else {
        // Se proprio non è arrivato nulla, congela quel che c'è (anche parziale) per rispettare richiesta
        freezeNow();
      }
    };
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', tick);
    else setTimeout(tick, 0);
  })();

  // API manuale per debug dalla console
  window.__forceFreezeEstremi = function(){ return freezeNow(); };
  window.__unfreezeEstremi = function(){
    // sblocca (per debug)
    window.__freezeEstremi = false;
    const b = document.getElementById('badge-freeze-estremi'); if (b) b.remove();
    if (typeof window.aggiornaTabella === 'function') window.aggiornaTabella();
    if (typeof window.visualizzaAttuali === 'function') window.visualizzaAttuali();
  };
})();
</script>
<!-- ========= /PATCH: BLOCCO ESTREMI INIZIALI ========= -->


<!-- ========= PATCH v2: BLOCCO ESTREMI con attesa Firebase e freeze per-stazione ========= -->
<script id="freeze-estremi-lock-20251013-v2">
(function(){
  // Se esiste una versione precedente, disattiviamola per evitare conflitti
  try{
    if (window.__unfreezeEstremi) window.__unfreezeEstremi();
  }catch{}

  if (window.__freezeEstremiV2Installed__) return;
  window.__freezeEstremiV2Installed__ = true;

  // Stato
  const STATE = {
    globalFrozen: false,
    frozenExtremes: {},       // { id: {min,max} } congelati
    readyMinMax: {},          // { id: {min:boolean, max:boolean} } pronti da Firebase
    frozenAt: null,
    graceUntil: null,         // tempo entro cui possiamo ancora "riempire" stazioni in ritardo
    ids: new Set(),
  };

  // Config
  const MAX_WAIT_MS = 25000;  // attesa iniziale per avere Firebase
  const POLL_MS = 300;
  const GRACE_MS = 120000;    // 2 minuti per riempire stazioni in ritardo
  const REQUIRED_RATIO = 0.8; // congela quando almeno l'80% delle stazioni ha min&max pronti

  // Utilità
  const isNum = x => typeof x === 'number' && isFinite(x);
  const toNum = x => {
    const n = Number(x);
    return isFinite(n) ? +(+n) : NaN;
  };
  const clampPlausible = (n) => isNum(n) && n>-60 && n<60; // euristico
  const getNow = () => new Date();

  function collectIds(){
    const ids = new Set();
    if (Array.isArray(window.stazioni)) window.stazioni.forEach(s=>s?.stationId && ids.add(String(s.stationId)));
    if (Array.isArray(window.datiTabella)) window.datiTabella.forEach(r=>r?.stationId && ids.add(String(r.stationId)));
    // markersById keys
    if (window.markersById && typeof window.markersById==='object'){
      Object.keys(window.markersById).forEach(k=>ids.add(String(k)));
    }
    return ids;
  }

  function currentTemp(id){
    // prova a stimare la temperatura attuale per evitare di scambiare l'attuale per gli estremi
    const row = (window.datiTabella||[]).find(r=>String(r.stationId)===String(id));
    if (row && (isNum(toNum(row.temp)) || isNum(toNum(row.tAttuale)))){
      const v = isNum(toNum(row.temp)) ? toNum(row.temp) : toNum(row.tAttuale);
      return v;
    }
    const mk = window.markersById && window.markersById[id];
    if (mk && isNum(toNum(mk.temp))) return toNum(mk.temp);
    return NaN;
  }

  function getMin(id){
    const e = window.extremiGiornalieri && window.extremiGiornalieri[id];
    if (e && isNum(toNum(e.min))) return toNum(e.min);
    if (typeof window.getEstremoGiornaliero === "function"){
      const v = window.getEstremoGiornaliero(id,'min');
      if (isNum(v)) return +(+v);
    }
    return NaN;
  }
  function getMax(id){
    const e = window.extremiGiornalieri && window.extremiGiornalieri[id];
    if (e && isNum(toNum(e.max))) return toNum(e.max);
    if (typeof window.getEstremoGiornaliero === "function"){
      const v = window.getEstremoGiornaliero(id,'max');
      if (isNum(v)) return +(+v);
    }
    return NaN;
  }

  function looksLikeFirebaseExtremes(id, mn, mx){
    if (!isNum(mn) && !isNum(mx)) return false;
    if (isNum(mn) && !clampPlausible(mn)) return false;
    if (isNum(mx) && !clampPlausible(mx)) return false;
    if (isNum(mn) && isNum(mx) && mn>mx) return false;

    // Se uguali all'attuale, probabilmente non sono gli estremi reali
    const t = currentTemp(id);
    if (isNum(t)){
      if (isNum(mn) && Math.abs(mn - t) < 0.01) return false;
      if (isNum(mx) && Math.abs(mx - t) < 0.01) return false;
    }
    return true;
  }

  function updateReadiness(id){
    const mn = getMin(id);
    const mx = getMax(id);
    const ok = looksLikeFirebaseExtremes(id,mn,mx);
    const r = STATE.readyMinMax[id] || {min:false,max:false};
    if (isNum(mn) && ok) r.min = true;
    if (isNum(mx) && ok) r.max = true;
    STATE.readyMinMax[id] = r;
    return r.min && r.max;
  }

  function percentReady(){
    const ids = Array.from(STATE.ids);
    if (!ids.length) return 0;
    let ready = 0;
    ids.forEach(id=>{ if (STATE.readyMinMax[id]?.min && STATE.readyMinMax[id]?.max) ready++; });
    return ready / ids.length;
  }

  function freezeForId(id){
    if (STATE.frozenExtremes[id]) return;
    const mn = getMin(id);
    const mx = getMax(id);
    if (!looksLikeFirebaseExtremes(id,mn,mx)) return;
    STATE.frozenExtremes[id] = {
      min: isNum(mn)? +mn: undefined,
      max: isNum(mx)? +mx: undefined,
    };
  }

  function installGuards(){
    // Proxy per extremiGiornalieri (lettura/scrittura)
    try {
      const base = window.extremiGiornalieri || {};
      window.__extremiBaseV2 = base;
      window.extremiGiornalieri = new Proxy(base, {
        get(target, prop, receiver){
          if (STATE.globalFrozen && Object.prototype.hasOwnProperty.call(STATE.frozenExtremes, prop)){
            return STATE.frozenExtremes[prop];
          }
          return Reflect.get(target, prop, receiver);
        },
        set(target, prop, value, receiver){
          // Durante il freeze globale, consentiamo ancora scritture ma le "oscuriamo" in lettura
          // Inoltre, durante il GRACE permettiamo di completare stazioni non ancora congelate
          const res = Reflect.set(target, prop, value, receiver);
          try {
            const id = String(prop);
            STATE.ids.add(id);
            updateReadiness(id);
            if (STATE.globalFrozen && STATE.graceUntil && Date.now() < STATE.graceUntil.getTime()){
              if (!STATE.frozenExtremes[id]) freezeForId(id);
            }
          } catch {}
          return res;
        }
      });
    } catch(e){ console.warn("Proxy extremiGiornalieri non supportato (v2):", e); }

    // Wrap getEstremoGiornaliero
    (function wrapGet(){
      const orig = window.getEstremoGiornaliero;
      window.getEstremoGiornaliero = function(stationId, tipo){
        if (STATE.globalFrozen){
          const f = STATE.frozenExtremes[stationId];
          if (f){
            const v = (tipo==='max') ? f.max : f.min;
            if (isNum(v)) return +(+v);
          }
        }
        if (typeof orig === 'function') return orig.apply(this, arguments);
        const e = (window.__extremiBaseV2||window.extremiGiornalieri||{})[stationId] || {};
        const v = (tipo==='max') ? e.max : e.min;
        return toNum(v);
      };
      window.getEstremoGiornaliero.__frozenWrappedV2 = true;
    })();

    // Evita sovrascritture dei marker quando si è in modalita min/max
    function guard(fnName){
      const orig = window[fnName];
      if (typeof orig !== 'function') return;
      if (orig.__freezeGuardV2) return;
      window[fnName] = function(){
        const mode = (window.ultimoModo || '').toLowerCase();
        if (STATE.globalFrozen && (mode==='min' || mode==='max') && (fnName!=='visualizzaEstremi')){
          return;
        }
        return orig.apply(this, arguments);
      };
      window[fnName].__freezeGuardV2 = true;
    }
    ['visualizzaAttuali','visualizzaUmidita','visualizzaPercepita','visualizzaRaffiche','aggiornaPopupConEstremiFinale','aggiornaTabellaConEstremi'].forEach(guard);
  }

  function applyUIBadge(on){
    try{
      const id='badge-freeze-estremi';
      const prev = document.getElementById(id);
      if (on){
        if (prev) return;
        const b = document.createElement('div');
        b.id = id;
        b.textContent = 'ESTREMI BLOCCATI (Firebase)';
        Object.assign(b.style, {
          position:'fixed', bottom:'10px', right:'10px', zIndex:10000,
          background:'#0b7', color:'#fff', padding:'6px 10px',
          borderRadius:'8px', font:'600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial',
          boxShadow:'0 2px 8px rgba(0,0,0,.25)'
        });
        document.body.appendChild(b);
      } else {
        if (prev) prev.remove();
      }
    }catch{}
  }

  function hardFreeze(){
    // congela per-stazione solo quelle pronte
    Array.from(STATE.ids).forEach(id=>{
      if (STATE.readyMinMax[id]?.min && STATE.readyMinMax[id]?.max) freezeForId(id);
    });
    STATE.globalFrozen = true;
    STATE.frozenAt = getNow();
    STATE.graceUntil = new Date(Date.now() + GRACE_MS);
    installGuards();
    // refresh coerente
    try{
      if (typeof window.aggiornaTabella === 'function') window.aggiornaTabella();
      if (typeof window.aggiornaPopup === 'function') window.aggiornaPopup();
      const t = (window.ultimoModo==='max' || window.ultimoModo==='min') ? window.ultimoModo : 'min';
      if (typeof window.visualizzaEstremi === 'function') window.visualizzaEstremi(t);
    }catch{}
    applyUIBadge(true);
    console.log('[FreezeEstremi v2] Freeze globale attivo. Stazioni congelate:', Object.keys(STATE.frozenExtremes).length);
  }

  function finalizeAfterGrace(){
    // Alla fine della GRACE, blocchiamo definitivamente lo stato raggiunto
    STATE.graceUntil = null;
    // Non serve altro: le letture continueranno dal proxy
    console.log('[FreezeEstremi v2] Grace terminata. Stato definitivamente bloccato.');
  }

  function autoFlow(){
    // Raccogli id iniziali
    STATE.ids = collectIds();

    const start = Date.now();
    const loop = () => {
      // Aggiorna set id dinamicamente
      collectIds().forEach(id=>STATE.ids.add(id));
      // Aggiorna readiness
      Array.from(STATE.ids).forEach(updateReadiness);
      const ratio = percentReady();

      if (!STATE.globalFrozen){
        const elapsed = Date.now()-start;
        if (ratio >= REQUIRED_RATIO){
          hardFreeze();
        } else if (elapsed > MAX_WAIT_MS && ratio>0){
          // dopo attesa massima, congela quello che c'è per rispettare richiesta
          hardFreeze();
        } else {
          setTimeout(loop, POLL_MS);
        }
      } else {
        if (STATE.graceUntil && Date.now() < STATE.graceUntil.getTime()){
          // in grace: prova a riempire stazioni non ancora congelate
          Array.from(STATE.ids).forEach(id=>{
            if (!STATE.frozenExtremes[id] && updateReadiness(id)) freezeForId(id);
          });
          setTimeout(loop, POLL_MS);
        } else if (STATE.graceUntil) {
          finalizeAfterGrace();
        }
      }
    };

    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', loop);
    else setTimeout(loop, 0);
  }

  // API console
  window.__forceFreezeEstremi = function(){ hardFreeze(); return true; };
  window.__unfreezeEstremi = function(){
    STATE.globalFrozen = false;
    STATE.graceUntil = null;
    applyUIBadge(false);
    try{
      if (typeof window.aggiornaTabella === 'function') window.aggiornaTabella();
      if (typeof window.visualizzaAttuali === 'function') window.visualizzaAttuali();
    }catch{}
  };

  autoFlow();
})();
</script>
<!-- ========= /PATCH v2 ========= -->


<!-- ========= PATCH v3: Avvio su LIVE + estremi solo Firebase ========= -->
<script id="freeze-estremi-lock-20251013-v3">
(function(){
  if (window.__freezeEstremiV3Installed__) return;
  window.__freezeEstremiV3Installed__ = true;

  const isNum = x => typeof x === 'number' && isFinite(x);
  const toNum = x => {
    const n = Number(x);
    return isFinite(n) ? +(+n) : NaN;
  };

  // 1) AVVIO SU TEMPERATURE LIVE (ATTUALI)
  function startOnLive(){
    try{
      window.ultimoModo = 'attuali';
      if (typeof window.visualizzaAttuali === 'function'){
        window.visualizzaAttuali();
      }
    }catch(e){ console.warn('startOnLive:', e); }
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', startOnLive);
  else setTimeout(startOnLive, 0);

  // 2) NON FORZARE "min" DOPO IL FREEZE se l'utente non era già in min/max
  //    Intercetta eventuali chiamate a visualizzaEstremi fatte dalla v2 durante il freeze
  (function preventAutoMinOnFreeze(){
    const v2 = window.visualizzaEstremi;
    if (typeof v2 !== 'function') return;
    if (v2.__wrappedV3) return;
    window.visualizzaEstremi = function(tipo){
      // aggiorna ultimoModo coerentemente
      if (tipo==='min' || tipo==='max') {
        window.ultimoModo = tipo;
      } else {
        window.ultimoModo = 'attuali';
      }
      return v2.apply(this, arguments);
    };
    window.visualizzaEstremi.__wrappedV3 = true;
  })();

  // 3) ESTREMI SOLO DA FIREBASE: rimpacchetta getEstremoGiornaliero per usare esclusivamente extremiGiornalieri/frozen
  (function hardTieToFirebase(){
    const orig = window.getEstremoGiornaliero;
    const baseRef = () => (window.__extremiBaseV2 || window.extremiGiornalieri || {});

    function currentTemp(id){
      const row = (window.datiTabella||[]).find(r=>String(r.stationId)===String(id));
      if (row && (isNum(toNum(row.temp)) || isNum(toNum(row.tAttuale)))){
        return isNum(toNum(row.temp)) ? toNum(row.temp) : toNum(row.tAttuale);
      }
      const mk = window.markersById && window.markersById[id];
      if (mk && isNum(toNum(mk.temp))) return toNum(mk.temp);
      return NaN;
    }

    window.getEstremoGiornaliero = function(stationId, tipo){
      // 1) Se c'è un freeze v2 con snapshot, quello ha la priorità assoluta
      const snap = (window.__freezeEstremiV2Installed__ && window.__freezeEstremiV2Installed__===true && window.__freezeEstremiV2Installed__) ? null : null;
      const state = window.__freezeEstremiV2Installed__ && window.__freezeEstremiV2Installed__;

      // Leggi dal proxy/base, MAI da attuali
      const src = baseRef();
      const e = src && src[stationId] || {};

      let v = (tipo==='max') ? e.max : e.min;
      v = toNum(v);

      // Se combacia con l'attuale (entro 0.01), rifiutalo: non è un estremo di Firebase valido
      const t = currentTemp(stationId);
      if (isNum(v) && isNum(t) && Math.abs(v - t) < 0.01){
        return NaN;
      }

      // Se la v2 ha congelato, prova a leggere anche da STATE se presente
      if (window.__freezeEstremiV2Installed__ && window.__freezeEstremiV2Installed__===true){
        // molti ambienti non espongono lo STATE; tuttavia, il Proxy già restituisce la snapshot in get()
        // quindi qui non serve altro.
      }

      if (isNum(v)) return +(+v);

      // Ultimo fallback: NON ricadere su attuali. Restituisci NaN se il valore non esiste.
      if (typeof orig === 'function') {
        // Chiama l'originale ma ignora eventuali fallback a "attuali" implementati a valle
        const ov = orig.apply(this, arguments);
        const ovn = toNum(ov);
        if (isNum(ovn) && !(isNum(t) && Math.abs(ovn - t) < 0.01)) return +(+ovn);
      }
      return NaN;
    };
    window.getEstremoGiornaliero.__hardTiedToFirebase = true;
  })();

  // 4) Se qualcuno cerca di aggiornare marker/tabella in min/max con attuali, bloccalo comunque
  function guard(fnName){
    const orig = window[fnName];
    if (typeof orig !== 'function') return;
    if (orig.__v3Guard) return;
    window[fnName] = function(){
      const mode = (window.ultimoModo || '').toLowerCase();
      if ((mode==='min' || mode==='max') && (fnName!=='visualizzaEstremi')){
        // blocca aggiornamenti non coerenti
        return;
      }
      return orig.apply(this, arguments);
    };
    window[fnName].__v3Guard = true;
  }
  ['visualizzaAttuali','visualizzaUmidita','visualizzaPercepita','visualizzaRaffiche','aggiornaPopupConEstremiFinale','aggiornaTabellaConEstremi'].forEach(guard);

})();
</script>
<!-- ========= /PATCH v3 ========= -->


<!-- ========= PATCH v5: Lock su LIVE iniziale + anti-auto-switch + micro-ottimizzazioni ========= -->
<script id="freeze-estremi-lock-20251013-v5">
(function(){
  if (window.__v5Installed) return; window.__v5Installed = true;

  // 0) Flag: tieni LIVE bloccato per i primi secondi, a meno di interazione utente
  window.__lockLive = true;
  window.__lockLiveStart = Date.now();
  const LIVE_LOCK_MS = 90000; // 30s: abbastanza per caricare Firebase e stabilizzarsi

  // Considera qualsiasi click/tap/tastiera come interazione utente
  ['click','pointerdown','keydown','touchstart'].forEach(ev=>{
    window.addEventListener(ev, ()=>{ window.__userInteracted = true; }, {once:false, passive:true});
  });

  function inLiveLock(){
    if (!window.__lockLive) return false;
    const age = Date.now() - (window.__lockLiveStart||0);
    if (age > LIVE_LOCK_MS) { window.__lockLive = false; return false; }
    return !window.__userInteracted;
  }

  // 1) Avvio forzato su LIVE
  function startOnLive(){
    try{
      window.ultimoModo = 'attuali';
      if (typeof window.visualizzaAttuali === 'function') window.visualizzaAttuali();
    }catch(e){}
  }
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', startOnLive);
  else setTimeout(startOnLive, 0);

  // 2) Impedisci switch automatici a min/max durante il live-lock (finché l'utente non interagisce)
  (function wrapEstremi(){
    const orig = window.visualizzaEstremi;
    if (typeof orig !== 'function' || orig.__v5Wrapped) return;
    window.visualizzaEstremi = function(tipo){
      // Se è un tentativo "automatico" entro il live-lock, blocca
      if ((tipo==='min' || tipo==='max') && inLiveLock()){
        console.debug('[v5] Blocco auto-switch a', tipo);
        return; // restiamo su LIVE
      }
      if (tipo==='min' || tipo==='max') window.ultimoModo = tipo;
      else window.ultimoModo = 'attuali';
      return orig.apply(this, arguments);
    };
    window.visualizzaEstremi.__v5Wrapped = true;
  })();

  // 3) Assicurati che i “guard” non penalizzino la vista LIVE
  (function relaxGuards(){
    const guardNames = ['visualizzaAttuali','visualizzaUmidita','visualizzaPercepita','visualizzaRaffiche','aggiornaPopupConEstremiFinale','aggiornaTabellaConEstremi'];
    guardNames.forEach(fnName=>{
      const orig = window[fnName];
      if (typeof orig !== 'function' || orig.__v5Guard) return;
      window[fnName] = function(){
        const mode = (window.ultimoModo || '').toLowerCase();
        // Solo in min/max blocchiamo tutto ciò che non è visualizzaEstremi
        if ((mode==='min' || mode==='max') && fnName!=='visualizzaEstremi') return;
        return orig.apply(this, arguments);
      };
      window[fnName].__v5Guard = true;
    });
  })();

  // 4) Micro-ottimizzazione: evita refresh pesanti in cascata appena dopo il freeze
  //    Se esiste un "aggiornaTabella" molto costoso, ritardalo leggermente per accorpare update.
  (function debounceHeavyRefresh(){
    function debounce(fn, ms){
      let to=null; return function(){ clearTimeout(to); const ctx=this, args=arguments; to=setTimeout(()=>fn.apply(ctx,args), ms); };
    }
    ['aggiornaTabella','aggiornaPopup'].forEach(name=>{
      const orig = window[name];
      if (typeof orig !== 'function' || orig.__v5Debounced) return;
      window[name] = debounce(orig, 120);
      window[name].__v5Debounced = true;
    });
  })();

  // 5) Sblocco automatico del live-lock quando l'utente passa manualmente a min/max
  window.addEventListener('click', function(){
    if ((window.ultimoModo==='min' || window.ultimoModo==='max') && window.__lockLive){
      window.__lockLive = false;
    }
  }, {passive:true});

})();
</script>
<!-- ========= /PATCH v5 ========= -->
